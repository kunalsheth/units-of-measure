/*
 * Copyright 2019 Kunal Sheth
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

@file:Suppress("NOTHING_TO_INLINE", "EXPERIMENTAL_FEATURE_WARNING")

package info.kunalsheth.units.generated

import kotlin.math.abs
import kotlin.math.sign
import kotlin.jvm.JvmName

/**
 * Created by kunal on 8/6/17.
 */
@Suppress("UNCHECKED_CAST")
interface Quan<This> : Comparable<This> where
This : Quan<This> {
    val siValue: Double
    val abrev: String

    fun new(siValue: Double): This

    operator fun unaryPlus(): This
    operator fun unaryMinus(): This

    operator fun plus(that: This): This
    operator fun minus(that: This): This
    operator fun times(that: Number): This
    operator fun div(that: Number): This
    operator fun rem(that: This): This

    infix fun min(that: This): This
    infix fun max(that: This): This

    val abs: This
    val signum: Double
    val isNegative: Boolean
    val isZero: Boolean
    val isPositive: Boolean

    override fun compareTo(other: This): Int
}

interface UomConverter<Q : Quan<Q>> {
    val unitName: String
    operator fun invoke(x: Double): Q
    operator fun invoke(x: Q): Double
}

@Deprecated(
        message = "Explicit boxing should only be used to circumnavigate compiler bugs",
        replaceWith = ReplaceWith("a newer version of Kotlin")
)
fun <Q : Quan<Q>> box(x: Q) = x as Quan<Q>

typealias `Dimensionless` = L0A0M0T0I0Theta0N0J0
inline class L0A0M0T0I0Theta0N0J0(internal val underlying: Double) : Quan<`Dimensionless`> {
    override val siValue get() = underlying
    override val abrev get() = ""

    override fun new(siValue: Double) = `Dimensionless`(siValue)

    override operator fun unaryPlus() = `Dimensionless`(+underlying)
    override operator fun unaryMinus() = `Dimensionless`(-underlying)

    override operator fun plus(that: `Dimensionless`) = `Dimensionless`(this.underlying + that.underlying)
    override operator fun minus(that: `Dimensionless`) = `Dimensionless`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `Dimensionless`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `Dimensionless`(this.underlying / that.toDouble())
    override operator fun rem(that: `Dimensionless`) = `Dimensionless`(this.underlying % that.underlying)

    override infix fun min(that: `Dimensionless`) = if (this < that) this else that
    override infix fun max(that: `Dimensionless`) = if (this > that) this else that

    override val abs get() = `Dimensionless`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `Dimensionless`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `Dimensionless` && this.siValue == other.siValue
}

inline val Number.`Turn`: `Dimensionless` get() = `Dimensionless`(toDouble() * 6.283185307179586)
inline val `Dimensionless`.`Turn` get() = siValue * 0.15915494309189535
object `Turn` : UomConverter<`Dimensionless`>,
    Quan<`Dimensionless`> by box(`Dimensionless`(6.283185307179586)) {
    override val unitName = "Turn"
    override fun invoke(x: Double) = x.`Turn`
    override fun invoke(x: `Dimensionless`) = x.`Turn`
}

inline val Number.`Degree`: `Dimensionless` get() = `Dimensionless`(toDouble() * 0.017453292519943295)
inline val `Dimensionless`.`Degree` get() = siValue * 57.29577951308232
object `Degree` : UomConverter<`Dimensionless`>,
    Quan<`Dimensionless`> by box(`Dimensionless`(0.017453292519943295)) {
    override val unitName = "Degree"
    override fun invoke(x: Double) = x.`Degree`
    override fun invoke(x: `Dimensionless`) = x.`Degree`
}

inline val Number.`Percent`: `Dimensionless` get() = `Dimensionless`(toDouble() * 0.01)
inline val `Dimensionless`.`Percent` get() = siValue * 100.0
object `Percent` : UomConverter<`Dimensionless`>,
    Quan<`Dimensionless`> by box(`Dimensionless`(0.01)) {
    override val unitName = "Percent"
    override fun invoke(x: Double) = x.`Percent`
    override fun invoke(x: `Dimensionless`) = x.`Percent`
}


@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.div(that: Quan<`Dimensionless`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.div(that: `Dimensionless`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`Dimensionless`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`Dimensionless`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `Dimensionless`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`Dimensionless`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.div(that: Quan<`L`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.div(that: `L`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`L`>) = `L`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `L`) = `L`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`M`>) = `M`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `M`) = `M`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `Dimensionless`.div(that: Quan<`T`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `Dimensionless`.div(that: `T`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`T`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`T`>) = `T`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `T`) = `T`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`T`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`I`>) = `I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `I`) = `I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta1N0J0_generic")
operator fun `Dimensionless`.div(that: Quan<`Θ`>) = `Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `Dimensionless`.div(that: `Θ`) = `Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta1N0J0_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`Θ`>) = thiz.run { `Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta1N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`Θ`>) = `Θ`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `Dimensionless`.times(that: `Θ`) = `Θ`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta1N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`Θ`>) = thiz.run { `Θ`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N1J0_generic")
operator fun `Dimensionless`.times(that: Quan<`N`>) = `N`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `Dimensionless`.times(that: `N`) = `N`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N1J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`N`>) = thiz.run { `N`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J1_generic")
operator fun `Dimensionless`.times(that: Quan<`J`>) = `J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J1_concrete")
operator fun `Dimensionless`.times(that: `J`) = `J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`J`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `Dimensionless`.div(that: Quan<`T⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `Dimensionless`.div(that: `T⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`T⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `Dimensionless`.times(that: Quan<`T⁻¹`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `Dimensionless`.times(that: `T⁻¹`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`∠`>) = `∠`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `∠`) = `∠`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`∠`>) = thiz.run { `∠`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A2M0T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`∠²`>) = `∠²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `∠²`) = `∠²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A2M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`∠²`>) = thiz.run { `∠²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅M⋅T⁻²`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `Dimensionless`.times(that: `L⋅M⋅T⁻²`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `Dimensionless`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `Dimensionless`.div(that: `L⁻¹⋅M⋅T⁻²`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻²`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻³`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻³`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`T⋅I`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `T⋅I`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`T⋅I`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `Dimensionless`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `Dimensionless`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `Dimensionless`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `Dimensionless`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `Dimensionless`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `Dimensionless`.div(that: `M⋅T⁻²⋅I⁻¹`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `Dimensionless`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `Dimensionless`.times(that: `M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `Dimensionless`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `Dimensionless`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A2M0T0I0Theta0N0J1_generic")
operator fun `Dimensionless`.times(that: Quan<`∠²⋅J`>) = `∠²⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A2M0T0I0Theta0N0J1_concrete")
operator fun `Dimensionless`.times(that: `∠²⋅J`) = `∠²⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A2M0T0I0Theta0N0J1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`∠²⋅J`>) = thiz.run { `∠²⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J1_per_L2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅J`>) = `L⁻²⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J1_per_L2_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅J`) = `L⁻²⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J1_per_L2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅J`>) = thiz.run { `L⁻²⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅T⁻²`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `Dimensionless`.times(that: `L²⋅T⁻²`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `Dimensionless`.times(that: Quan<`T⁻¹⋅N`>) = `T⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `Dimensionless`.times(that: `T⁻¹⋅N`) = `T⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `T⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.div(that: Quan<`L²`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.div(that: `L²`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L²`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`L²`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `L²`) = `L²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`L³`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `L³`) = `L³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L³`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅T⁻¹`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `Dimensionless`.times(that: `L⋅T⁻¹`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `Dimensionless`.times(that: Quan<`L³⋅T⁻¹`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `Dimensionless`.times(that: `L³⋅T⁻¹`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅T⁻²`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `Dimensionless`.times(that: `L⋅T⁻²`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅T⁻³`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `Dimensionless`.times(that: `L⋅T⁻³`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T4_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅T⁻⁴`>) = `L⋅T⁻⁴`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T4_concrete")
operator fun `Dimensionless`.times(that: `L⋅T⁻⁴`) = `L⋅T⁻⁴`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T4_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅T⁻⁴`>) = thiz.run { `L⋅T⁻⁴`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `Dimensionless`.times(that: Quan<`∠⋅T⁻¹`>) = `∠⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `Dimensionless`.times(that: `∠⋅T⁻¹`) = `∠⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `∠⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T2_generic")
operator fun `Dimensionless`.times(that: Quan<`∠⋅T⁻²`>) = `∠⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T2_concrete")
operator fun `Dimensionless`.times(that: `∠⋅T⁻²`) = `∠⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`∠⋅T⁻²`>) = thiz.run { `∠⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅M⋅T⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `Dimensionless`.times(that: `L⋅M⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A1T2_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A1T2_concrete")
operator fun `Dimensionless`.times(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A1T2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = thiz.run { `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅M⋅T⁻³`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `Dimensionless`.times(that: `L⋅M⋅T⁻³`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `Dimensionless`.div(that: Quan<`L⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `Dimensionless`.div(that: `L⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅M`>) = `L⁻²⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅M`) = `L⁻²⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⁻²⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `Dimensionless`.div(that: Quan<`L⁻³⋅M`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `Dimensionless`.div(that: `L⁻³⋅M`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻³⋅M`>) = `L⁻³⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `Dimensionless`.times(that: `L⁻³⋅M`) = `L⁻³⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L⁻³⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `Dimensionless`.div(that: Quan<`L³⋅M⁻¹`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `Dimensionless`.div(that: `L³⋅M⁻¹`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L³⋅M⁻¹`>) = `L³⋅M⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `Dimensionless`.times(that: `L³⋅M⁻¹`) = `L³⋅M⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L³⋅M⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `Dimensionless`.div(that: Quan<`L⁻³⋅N`>) = `L³⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `Dimensionless`.div(that: `L⁻³⋅N`) = `L³⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L³⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻³⋅N`>) = `L⁻³⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `Dimensionless`.times(that: `L⁻³⋅N`) = `L⁻³⋅N`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L⁻³⋅N`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `Dimensionless`.div(that: Quan<`L³⋅N⁻¹`>) = `L⁻³⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `Dimensionless`.div(that: `L³⋅N⁻¹`) = `L⁻³⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L⁻³⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `Dimensionless`.times(that: Quan<`L³⋅N⁻¹`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `Dimensionless`.times(that: `L³⋅N⁻¹`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0N0J0_per_T2Theta1_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0N0J0_per_T2Theta1_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0J0_per_T2Theta1N1_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0J0_per_T2Theta1N1_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0J0_per_T2Theta1N1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `Dimensionless`.times(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `Dimensionless`.times(that: Quan<`M⋅T⁻²`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `Dimensionless`.times(that: `M⋅T⁻²`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `Dimensionless`.times(that: Quan<`M⋅T⁻³`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `Dimensionless`.times(that: `M⋅T⁻³`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0N0J0_per_T3Theta1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0N0J0_per_T3Theta1_concrete")
operator fun `Dimensionless`.times(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0N0J0_per_T3Theta1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅T⁻¹`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `Dimensionless`.times(that: `L²⋅T⁻¹`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅T⋅I`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻³⋅T⋅I`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `Dimensionless`.times(that: `L⁻³⋅T⋅I`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅I`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅I`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `Dimensionless`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `Dimensionless`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `Dimensionless`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T3I2Theta0J0_per_M1N1_generic")
operator fun `Dimensionless`.times(that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T3I2Theta0J0_per_M1N1_concrete")
operator fun `Dimensionless`.times(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T3I2Theta0J0_per_M1N1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = thiz.run { `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `Dimensionless`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `Dimensionless`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `Dimensionless`.div(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `Dimensionless`.times(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `Dimensionless`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹⋅I`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹⋅I`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T1I0Theta0N0J1_generic")
operator fun `Dimensionless`.times(that: Quan<`T⋅J`>) = `T⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T1I0Theta0N0J1_concrete")
operator fun `Dimensionless`.times(that: `T⋅J`) = `T⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T1I0Theta0N0J1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`T⋅J`>) = thiz.run { `T⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I0Theta0N0J1_per_L2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅T⋅J`>) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I0Theta0N0J1_per_L2_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅T⋅J`) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I0Theta0N0J1_per_L2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅T⋅J`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `Dimensionless`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `Dimensionless`.times(that: `M⁻¹⋅T⋅I`) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅T⁻³`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `Dimensionless`.times(that: `L²⋅T⁻³`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `Dimensionless`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `Dimensionless`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `Dimensionless`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `Dimensionless`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹⋅M`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹⋅M`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹⋅T⋅I`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `Dimensionless`.div(that: Quan<`M⁻¹⋅N`>) = `M⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `Dimensionless`.div(that: `M⁻¹⋅N`) = `M⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `M⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `Dimensionless`.times(that: Quan<`M⁻¹⋅N`>) = `M⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `Dimensionless`.times(that: `M⁻¹⋅N`) = `M⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `M⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `Dimensionless`.div(that: Quan<`M⋅N⁻¹`>) = `M⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `Dimensionless`.div(that: `M⋅N⁻¹`) = `M⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `M⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `Dimensionless`.times(that: Quan<`M⋅N⁻¹`>) = `M⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `Dimensionless`.times(that: `M⋅N⁻¹`) = `M⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `M⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `Dimensionless`.div(that: Quan<`L⁻²`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `Dimensionless`.div(that: `L⁻²`) = `L²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²`>) = `L⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `Dimensionless`.times(that: `L⁻²`) = `L⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `Dimensionless`.times(that: Quan<`M⋅T⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `Dimensionless`.times(that: `M⋅T⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0T0I1Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅I`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0T0I1Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `L²⋅I`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅I`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹⋅M⋅T⁻³`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `Dimensionless`.div(that: Quan<`Θ⁻¹`>) = `Θ`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `Dimensionless`.div(that: `Θ⁻¹`) = `Θ`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`Θ⁻¹`>) = thiz.run { `Θ`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `Dimensionless`.times(that: Quan<`Θ⁻¹`>) = `Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `Dimensionless`.times(that: `Θ⁻¹`) = `Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`Θ⁻¹`>) = thiz.run { `Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹⋅Θ`>) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹⋅Θ`) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `Dimensionless`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `Dimensionless`.div(that: `M⁻¹⋅T²⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `Dimensionless`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `Dimensionless`.times(that: `M⁻¹⋅T²⋅I`) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `Dimensionless`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `Dimensionless`.div(that: `L⋅M⁻¹⋅T²`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `L⋅M⁻¹⋅T²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `Dimensionless`.times(that: `L⋅M⁻¹⋅T²`) = `L⋅M⁻¹⋅T²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `Dimensionless`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `Dimensionless`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `Dimensionless`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `Dimensionless`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `Dimensionless`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `Dimensionless`.times(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `Dimensionless`.times(that: `L³⋅T⁻¹⋅N⁻¹`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1T0I0Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅M`>) = `L²⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1T0I0Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `L²⋅M`) = `L²⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅M`>) = thiz.run { `L²⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `Dimensionless`.times(that: Quan<`T⁻²`>) = `T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `Dimensionless`.times(that: `T⁻²`) = `T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`T⁻²`>) = thiz.run { `T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `Dimensionless`.times(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0T0I1Theta0N0J0_generic")
operator fun `Dimensionless`.times(that: Quan<`∠⋅I`>) = `∠⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0T0I1Theta0N0J0_concrete")
operator fun `Dimensionless`.times(that: `∠⋅I`) = `∠⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0A1M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`∠⋅I`>) = thiz.run { `∠⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `Dimensionless`.div(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `Dimensionless`.div(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun div(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A2T3_generic")
operator fun `Dimensionless`.times(that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `Dimensionless`.times(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `Dimensionless`.times(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `Dimensionless`.times(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `Dimensionless`.times(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `Dimensionless`.times(that: `∠⁻²⋅M⋅T⁻³`) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `Dimensionless`.times(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `Dimensionless`.times(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun times(thiz: Quan<`Dimensionless`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L` = L1A0M0T0I0Theta0N0J0
inline class L1A0M0T0I0Theta0N0J0(internal val underlying: Double) : Quan<`L`> {
    override val siValue get() = underlying
    override val abrev get() = "m"

    override fun new(siValue: Double) = `L`(siValue)

    override operator fun unaryPlus() = `L`(+underlying)
    override operator fun unaryMinus() = `L`(-underlying)

    override operator fun plus(that: `L`) = `L`(this.underlying + that.underlying)
    override operator fun minus(that: `L`) = `L`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L`(this.underlying / that.toDouble())
    override operator fun rem(that: `L`) = `L`(this.underlying % that.underlying)

    override infix fun min(that: `L`) = if (this < that) this else that
    override infix fun max(that: `L`) = if (this > that) this else that

    override val abs get() = `L`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L` && this.siValue == other.siValue
}

inline val Number.`Metre`: `Length` get() = `L`(toDouble() * 1.0)
inline val `L`.`Metre` get() = siValue * 1.0
object `Metre` : UomConverter<`L`>,
    Quan<`L`> by box(`L`(1.0)) {
    override val unitName = "Metre"
    override fun invoke(x: Double) = x.`Metre`
    override fun invoke(x: `L`) = x.`Metre`
}

inline val Number.`Mile`: `Length` get() = `L`(toDouble() * 1609.34)
inline val `L`.`Mile` get() = siValue * 6.213727366498068E-4
object `Mile` : UomConverter<`L`>,
    Quan<`L`> by box(`L`(1609.34)) {
    override val unitName = "Mile"
    override fun invoke(x: Double) = x.`Mile`
    override fun invoke(x: `L`) = x.`Mile`
}

inline val Number.`Foot`: `Length` get() = `L`(toDouble() * 0.3048)
inline val `L`.`Foot` get() = siValue * 3.280839895013123
object `Foot` : UomConverter<`L`>,
    Quan<`L`> by box(`L`(0.3048)) {
    override val unitName = "Foot"
    override fun invoke(x: Double) = x.`Foot`
    override fun invoke(x: `L`) = x.`Foot`
}


typealias `Length` = `L`

@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L`.div(that: Quan<`Dimensionless`>) = `L`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L`.div(that: `Dimensionless`) = `L`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`Dimensionless`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L`.div(that: Quan<`L`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L`.div(that: `L`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L`.times(that: Quan<`Dimensionless`>) = `L`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L`.times(that: `Dimensionless`) = `L`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`Dimensionless`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L`.times(that: Quan<`L`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L`.times(that: `L`) = `L²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L`.div(that: Quan<`T`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L`.div(that: `T`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`T`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L`.times(that: Quan<`T⁻¹`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L`.times(that: `T⁻¹`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L`.times(that: Quan<`L⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L`.times(that: `L⋅M⋅T⁻²`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L`.times(that: `L⁻¹⋅M⋅T⁻²`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L`.div(that: Quan<`L²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L`.div(that: `L²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L`.times(that: Quan<`L²`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L`.times(that: `L²`) = `L³`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L²`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L`.div(that: Quan<`L³`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L`.div(that: `L³`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L³`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L`.div(that: Quan<`L⋅T⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L`.div(that: `L⋅T⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L`.times(that: Quan<`L⋅T⁻¹`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L`.times(that: `L⋅T⁻¹`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L`.times(that: Quan<`L⋅T⁻²`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L`.times(that: `L⋅T⁻²`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L`.times(that: Quan<`L⋅T⁻³`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L`.times(that: `L⋅T⁻³`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L`.times(that: Quan<`L⋅M⋅T⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L`.times(that: `L⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L`.times(that: Quan<`L⋅M⋅T⁻³`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L`.times(that: `L⋅M⋅T⁻³`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L`.div(that: Quan<`L⁻¹`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L`.div(that: `L⁻¹`) = `L²`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L⁻¹`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L`.times(that: Quan<`L⁻¹`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L`.times(that: `L⁻¹`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻¹`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L`.div(that: Quan<`L⁻²⋅M`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L`.div(that: `L⁻²⋅M`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L`.times(that: Quan<`L⁻²⋅M`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L`.times(that: `L⁻²⋅M`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L`.times(that: Quan<`L⁻³⋅M`>) = `L⁻²⋅M`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L`.times(that: `L⁻³⋅M`) = `L⁻²⋅M`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L⁻²⋅M`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L`.div(that: Quan<`L³⋅M⁻¹`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L`.div(that: `L³⋅M⁻¹`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L`.div(that: Quan<`M⋅T⁻²`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L`.div(that: `M⋅T⁻²`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L`.times(that: Quan<`M⋅T⁻²`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L`.times(that: `M⋅T⁻²`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L`.times(that: Quan<`M⋅T⁻³`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L`.times(that: `M⋅T⁻³`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L`.times(that: Quan<`L²⋅T⁻¹`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L`.times(that: `L²⋅T⁻¹`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L`.times(that: `L⁻²⋅T⋅I`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L`.times(that: Quan<`L⁻³⋅T⋅I`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L`.times(that: `L⁻³⋅T⋅I`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L`.times(that: Quan<`L⁻²⋅I`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L`.times(that: `L⁻²⋅I`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L`.times(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L`.times(that: Quan<`L⁻¹⋅I`>) = `I`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L`.times(that: `L⁻¹⋅I`) = `I`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L`.times(that: Quan<`L⁻¹⋅M`>) = `M`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L`.times(that: `L⁻¹⋅M`) = `M`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L`.times(that: `L⁻¹⋅T⋅I`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L`.div(that: Quan<`L⁻²`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L`.div(that: `L⁻²`) = `L³`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L⁻²`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L`.times(that: Quan<`L⁻²`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L`.times(that: `L⁻²`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L`.times(that: Quan<`M⋅T⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L`.times(that: `M⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L`.times(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L`.times(that: `L⁻¹⋅M⋅T⁻³`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `L`.times(that: Quan<`L⁻¹⋅Θ`>) = `Θ`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `L`.times(that: `L⁻¹⋅Θ`) = `Θ`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `Θ`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L`.div(that: `M⁻¹⋅T²⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L`.div(that: `L⋅M⁻¹⋅T²`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L`.times(that: Quan<`T⁻²`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L`.times(that: `T⁻²`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`T⁻²`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L`.div(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L`.div(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun div(thiz: Quan<`L`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L`.times(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L`.times(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L`.times(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L`.times(that: `∠⁻²⋅M⋅T⁻³`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `L`.times(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `L`.times(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun times(thiz: Quan<`L`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L⁻¹` = A0M0T0I0Theta0N0J0_per_L1
inline class A0M0T0I0Theta0N0J0_per_L1(internal val underlying: Double) : Quan<`L⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹"

    override fun new(siValue: Double) = `L⁻¹`(siValue)

    override operator fun unaryPlus() = `L⁻¹`(+underlying)
    override operator fun unaryMinus() = `L⁻¹`(-underlying)

    override operator fun plus(that: `L⁻¹`) = `L⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹`) = `L⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹`) = `L⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹`) = if (this > that) this else that

    override val abs get() = `L⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹` && this.siValue == other.siValue
}


typealias `Wavenumber` = `L⁻¹`

typealias `OpticalPower` = `L⁻¹`

typealias `Curvature` = `L⁻¹`

typealias `SpatialFrequency` = `L⁻¹`

@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹`.div(that: Quan<`Dimensionless`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹`.div(that: `Dimensionless`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹`.div(that: Quan<`L⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹`.div(that: `L⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹`.times(that: Quan<`Dimensionless`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹`.times(that: `Dimensionless`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⁻¹`>) = `L⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹`.times(that: `L⁻¹`) = `L⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹`.div(that: Quan<`L`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹`.div(that: `L`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹`.times(that: Quan<`L`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹`.times(that: `L`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⁻¹`.times(that: Quan<`M`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⁻¹`.times(that: `M`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`M`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⁻¹`.times(that: Quan<`I`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⁻¹`.times(that: `I`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`I`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L⁻¹`.times(that: Quan<`Θ`>) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L⁻¹`.times(that: `Θ`) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta1N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`Θ`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹`.times(that: Quan<`L⋅M⋅T⁻²`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹`.times(that: `L⋅M⋅T⁻²`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅M⋅T⁻²`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹`.times(that: `L²⋅M⋅T⁻²`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅M⋅T⁻³`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹`.times(that: `L²⋅M⋅T⁻³`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L⁻¹`.times(that: Quan<`T⋅I`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L⁻¹`.times(that: `T⋅I`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻¹`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅T⁻²`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹`.times(that: `L²⋅T⁻²`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹`.times(that: Quan<`L²`>) = `L`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹`.times(that: `L²`) = `L`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹`.times(that: Quan<`L³`>) = `L²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹`.times(that: `L³`) = `L²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L³`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⋅T⁻¹`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹`.times(that: `L⋅T⁻¹`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹`.times(that: Quan<`L³⋅T⁻¹`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹`.times(that: `L³⋅T⁻¹`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹`.times(that: Quan<`L⋅T⁻²`>) = `T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹`.times(that: `L⋅T⁻²`) = `T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⋅M⋅T⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹`.times(that: `L⋅M⋅T⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅M⋅T⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹`.times(that: `L²⋅M⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹`.times(that: Quan<`L⋅M⋅T⁻³`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹`.times(that: `L⋅M⋅T⁻³`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹`.times(that: Quan<`L⁻²⋅M`>) = `L⁻³⋅M`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹`.times(that: `L⁻²⋅M`) = `L⁻³⋅M`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⁻³⋅M`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹`.times(that: Quan<`M⋅T⁻²`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹`.times(that: `M⋅T⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹`.times(that: Quan<`M⋅T⁻³`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹`.times(that: `M⋅T⁻³`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L1A0M1I0N0J0_per_T3Theta1_generic")
operator fun `L⁻¹`.div(that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L1A0M1I0N0J0_per_T3Theta1_concrete")
operator fun `L⁻¹`.div(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L1A0M1I0N0J0_per_T3Theta1_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅T⁻¹`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹`.times(that: `L²⋅T⁻¹`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻¹`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹`.times(that: `L⁻²⋅T⋅I`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻¹`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻¹`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⁻¹⋅I`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹`.times(that: `L⁻¹⋅I`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅T⁻³`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹`.times(that: `L²⋅T⁻³`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻¹`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻¹`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⁻¹⋅M`>) = `L⁻²⋅M`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹`.times(that: `L⁻¹⋅M`) = `L⁻²⋅M`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⁻²⋅M`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹`.div(that: Quan<`L⁻²`>) = `L`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹`.div(that: `L⁻²`) = `L`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹`.times(that: Quan<`M⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹`.times(that: `M⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `L⁻¹`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `L⁻¹`.div(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L⁻¹`.div(that: Quan<`Θ⁻¹`>) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L⁻¹`.div(that: `Θ⁻¹`) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `L⁻¹`.div(that: Quan<`L⁻¹⋅Θ`>) = `Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `L⁻¹`.div(that: `L⁻¹⋅Θ`) = `Θ⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L⁻¹`.times(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L⁻¹`.times(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⁻¹`.times(that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⁻¹`.times(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L2M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⁻¹`.times(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⁻¹`.times(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⁻¹`.times(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⁻¹`.times(that: `∠⁻²⋅M⋅T⁻³`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L1_Multiply_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`L⁻¹`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L²` = L2A0M0T0I0Theta0N0J0
inline class L2A0M0T0I0Theta0N0J0(internal val underlying: Double) : Quan<`L²`> {
    override val siValue get() = underlying
    override val abrev get() = "m²"

    override fun new(siValue: Double) = `L²`(siValue)

    override operator fun unaryPlus() = `L²`(+underlying)
    override operator fun unaryMinus() = `L²`(-underlying)

    override operator fun plus(that: `L²`) = `L²`(this.underlying + that.underlying)
    override operator fun minus(that: `L²`) = `L²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²`) = `L²`(this.underlying % that.underlying)

    override infix fun min(that: `L²`) = if (this < that) this else that
    override infix fun max(that: `L²`) = if (this > that) this else that

    override val abs get() = `L²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²` && this.siValue == other.siValue
}


typealias `Area` = `L²`

@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²`.div(that: Quan<`Dimensionless`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²`.div(that: `Dimensionless`) = `L²`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²`.div(that: Quan<`L²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²`.div(that: `L²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²`.times(that: Quan<`Dimensionless`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²`.times(that: `Dimensionless`) = `L²`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²`.div(that: Quan<`L`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²`.div(that: `L`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²`.times(that: Quan<`L`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²`.times(that: `L`) = `L³`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²`.times(that: Quan<`M`>) = `L²⋅M`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²`.times(that: `M`) = `L²⋅M`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`M`>) = thiz.run { `L²⋅M`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²`.div(that: Quan<`T`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²`.div(that: `T`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`T`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²`.times(that: Quan<`I`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²`.times(that: `I`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`I`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²`.times(that: Quan<`T⁻¹`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²`.times(that: `T⁻¹`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²`.div(that: Quan<`L⋅M⋅T⁻²`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²`.div(that: `L⋅M⋅T⁻²`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L²`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L²`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J1_per_L2_generic")
operator fun `L²`.times(that: Quan<`L⁻²⋅J`>) = `J`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J1_per_L2_concrete")
operator fun `L²`.times(that: `L⁻²⋅J`) = `J`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J1_per_L2_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻²⋅J`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L²`.div(that: Quan<`L³`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L²`.div(that: `L³`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L³`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²`.times(that: Quan<`L⋅T⁻¹`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²`.times(that: `L⋅T⁻¹`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²`.div(that: Quan<`L⁻¹`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²`.div(that: `L⁻¹`) = `L³`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L⁻¹`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²`.times(that: Quan<`L⁻¹`>) = `L`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²`.times(that: `L⁻¹`) = `L`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻¹`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L²`.times(that: Quan<`L⁻²⋅M`>) = `M`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²`.times(that: `L⁻²⋅M`) = `M`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L²`.times(that: Quan<`L⁻³⋅M`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L²`.times(that: `L⁻³⋅M`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L²`.div(that: Quan<`L³⋅M⁻¹`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L²`.div(that: `L³⋅M⁻¹`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²`.times(that: Quan<`M⋅T⁻²`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²`.times(that: `M⋅T⁻²`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L²`.times(that: Quan<`M⋅T⁻³`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L²`.times(that: `M⋅T⁻³`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²`.div(that: Quan<`L²⋅T⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²`.div(that: `L²⋅T⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L²`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L²`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L²`.times(that: Quan<`L⁻²⋅T⋅I`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L²`.times(that: `L⁻²⋅T⋅I`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L²`.times(that: Quan<`L⁻³⋅T⋅I`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L²`.times(that: `L⁻³⋅T⋅I`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L²`.times(that: Quan<`L⁻²⋅I`>) = `I`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L²`.times(that: `L⁻²⋅I`) = `I`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T1I0Theta0N0J1_per_L2_generic")
operator fun `L²`.times(that: Quan<`L⁻²⋅T⋅J`>) = `T⋅J`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T1I0Theta0N0J1_per_L2_concrete")
operator fun `L²`.times(that: `L⁻²⋅T⋅J`) = `T⋅J`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T1I0Theta0N0J1_per_L2_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻²⋅T⋅J`>) = thiz.run { `T⋅J`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L²`.div(that: Quan<`L⁻¹⋅M`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²`.div(that: `L⁻¹⋅M`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²`.times(that: Quan<`L⁻²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²`.times(that: `L⁻²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²`.times(that: Quan<`M⋅T⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²`.times(that: `M⋅T⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L²`.times(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L²`.times(that: `L⁻¹⋅M⋅T⁻³`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L²`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L²`.div(that: `M⁻¹⋅T²⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L²`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L²`.div(that: `L⋅M⁻¹⋅T²`) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²`.times(that: Quan<`T⁻²`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²`.times(that: `T⁻²`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`T⁻²`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L²`.times(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L²`.times(that: `∠⁻²⋅M⋅T⁻³`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `L²`.times(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `L²`.times(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun times(thiz: Quan<`L²`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `M` = L0A0M1T0I0Theta0N0J0
inline class L0A0M1T0I0Theta0N0J0(internal val underlying: Double) : Quan<`M`> {
    override val siValue get() = underlying
    override val abrev get() = "kg"

    override fun new(siValue: Double) = `M`(siValue)

    override operator fun unaryPlus() = `M`(+underlying)
    override operator fun unaryMinus() = `M`(-underlying)

    override operator fun plus(that: `M`) = `M`(this.underlying + that.underlying)
    override operator fun minus(that: `M`) = `M`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M`(this.underlying / that.toDouble())
    override operator fun rem(that: `M`) = `M`(this.underlying % that.underlying)

    override infix fun min(that: `M`) = if (this < that) this else that
    override infix fun max(that: `M`) = if (this > that) this else that

    override val abs get() = `M`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M` && this.siValue == other.siValue
}

inline val Number.`Kilogram`: `Mass` get() = `M`(toDouble() * 1.0)
inline val `M`.`Kilogram` get() = siValue * 1.0
object `Kilogram` : UomConverter<`M`>,
    Quan<`M`> by box(`M`(1.0)) {
    override val unitName = "Kilogram"
    override fun invoke(x: Double) = x.`Kilogram`
    override fun invoke(x: `M`) = x.`Kilogram`
}

inline val Number.`Ounce`: `Mass` get() = `M`(toDouble() * 0.0283495)
inline val `M`.`Ounce` get() = siValue * 35.27399072294044
object `Ounce` : UomConverter<`M`>,
    Quan<`M`> by box(`M`(0.0283495)) {
    override val unitName = "Ounce"
    override fun invoke(x: Double) = x.`Ounce`
    override fun invoke(x: `M`) = x.`Ounce`
}

inline val Number.`Gram`: `Mass` get() = `M`(toDouble() * 0.001)
inline val `M`.`Gram` get() = siValue * 1000.0
object `Gram` : UomConverter<`M`>,
    Quan<`M`> by box(`M`(0.001)) {
    override val unitName = "Gram"
    override fun invoke(x: Double) = x.`Gram`
    override fun invoke(x: `M`) = x.`Gram`
}

inline val Number.`Pound`: `Mass` get() = `M`(toDouble() * 0.453592)
inline val `M`.`Pound` get() = siValue * 2.2046244201837775
object `Pound` : UomConverter<`M`>,
    Quan<`M`> by box(`M`(0.453592)) {
    override val unitName = "Pound"
    override fun invoke(x: Double) = x.`Pound`
    override fun invoke(x: `M`) = x.`Pound`
}


typealias `Mass` = `M`

@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M`.div(that: Quan<`Dimensionless`>) = `M`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M`.div(that: `Dimensionless`) = `M`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`Dimensionless`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `M`.div(that: Quan<`M`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `M`.div(that: `M`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`M`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M`.times(that: Quan<`Dimensionless`>) = `M`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M`.times(that: `Dimensionless`) = `M`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`Dimensionless`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `M`.div(that: Quan<`L`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `M`.div(that: `L`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `M`.div(that: Quan<`T`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `M`.div(that: `T`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`T`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N1J0_generic")
operator fun `M`.div(that: Quan<`N`>) = `M⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `M`.div(that: `N`) = `M⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N1J0_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`N`>) = thiz.run { `M⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M`.times(that: Quan<`T⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M`.times(that: `T⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M`.times(that: Quan<`L²⋅T⁻²`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M`.times(that: `L²⋅T⁻²`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `M`.div(that: Quan<`L²`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `M`.div(that: `L²`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`L²`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `M`.times(that: Quan<`L²`>) = `L²⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `M`.times(that: `L²`) = `L²⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L²`>) = thiz.run { `L²⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `M`.div(that: Quan<`L³`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `M`.div(that: `L³`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`L³`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M`.times(that: Quan<`L⋅T⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M`.times(that: `L⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M`.times(that: Quan<`L⋅T⁻²`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M`.times(that: `L⋅T⁻²`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `M`.times(that: Quan<`L⋅T⁻³`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `M`.times(that: `L⋅T⁻³`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `M`.times(that: Quan<`L⁻¹`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `M`.times(that: `L⁻¹`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `M`.div(that: Quan<`L⁻²⋅M`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `M`.div(that: `L⁻²⋅M`) = `L²`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `M`.div(that: Quan<`L⁻³⋅M`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `M`.div(that: `L⁻³⋅M`) = `L³`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `M`.times(that: Quan<`L³⋅M⁻¹`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `M`.times(that: `L³⋅M⁻¹`) = `L³`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `M`.times(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `M`.times(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M`.times(that: Quan<`L²⋅T⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M`.times(that: `L²⋅T⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `M`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `M`.times(that: `M⁻¹⋅T⋅I`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `M`.times(that: Quan<`L²⋅T⁻³`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `M`.times(that: `L²⋅T⁻³`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `M`.div(that: Quan<`L⁻¹⋅M`>) = `L`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `M`.div(that: `L⁻¹⋅M`) = `L`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `M`.times(that: Quan<`M⁻¹⋅N`>) = `N`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `M`.times(that: `M⁻¹⋅N`) = `N`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `N`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `M`.div(that: Quan<`M⋅N⁻¹`>) = `N`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `M`.div(that: `M⋅N⁻¹`) = `N`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `N`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `M`.div(that: Quan<`L⁻²`>) = `L²⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `M`.div(that: `L⁻²`) = `L²⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`L⁻²`>) = thiz.run { `L²⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `M`.times(that: Quan<`L⁻²`>) = `L⁻²⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `M`.times(that: `L⁻²`) = `L⁻²⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻²⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M`.div(that: Quan<`M⋅T⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M`.div(that: `M⋅T⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L2A0M1T0I0Theta0N0J0_generic")
operator fun `M`.div(that: Quan<`L²⋅M`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Divide_L2A0M1T0I0Theta0N0J0_concrete")
operator fun `M`.div(that: `L²⋅M`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Divide_L2A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M`>, that: Quan<`L²⋅M`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M`.times(that: Quan<`T⁻²`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M`.times(that: `T⁻²`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`M`>, that: Quan<`T⁻²`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }


typealias `T` = L0A0M0T1I0Theta0N0J0
inline class L0A0M0T1I0Theta0N0J0(internal val underlying: Double) : Quan<`T`> {
    override val siValue get() = underlying
    override val abrev get() = "s"

    override fun new(siValue: Double) = `T`(siValue)

    override operator fun unaryPlus() = `T`(+underlying)
    override operator fun unaryMinus() = `T`(-underlying)

    override operator fun plus(that: `T`) = `T`(this.underlying + that.underlying)
    override operator fun minus(that: `T`) = `T`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `T`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `T`(this.underlying / that.toDouble())
    override operator fun rem(that: `T`) = `T`(this.underlying % that.underlying)

    override infix fun min(that: `T`) = if (this < that) this else that
    override infix fun max(that: `T`) = if (this > that) this else that

    override val abs get() = `T`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `T`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `T` && this.siValue == other.siValue
}

inline val Number.`Second`: `Time` get() = `T`(toDouble() * 1.0)
inline val `T`.`Second` get() = siValue * 1.0
object `Second` : UomConverter<`T`>,
    Quan<`T`> by box(`T`(1.0)) {
    override val unitName = "Second"
    override fun invoke(x: Double) = x.`Second`
    override fun invoke(x: `T`) = x.`Second`
}

inline val Number.`Hour`: `Time` get() = `T`(toDouble() * 3600.0)
inline val `T`.`Hour` get() = siValue * 2.777777777777778E-4
object `Hour` : UomConverter<`T`>,
    Quan<`T`> by box(`T`(3600.0)) {
    override val unitName = "Hour"
    override fun invoke(x: Double) = x.`Hour`
    override fun invoke(x: `T`) = x.`Hour`
}

inline val Number.`Minute`: `Time` get() = `T`(toDouble() * 60.0)
inline val `T`.`Minute` get() = siValue * 0.016666666666666666
object `Minute` : UomConverter<`T`>,
    Quan<`T`> by box(`T`(60.0)) {
    override val unitName = "Minute"
    override fun invoke(x: Double) = x.`Minute`
    override fun invoke(x: `T`) = x.`Minute`
}


typealias `Time` = `T`

@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T`.div(that: Quan<`Dimensionless`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T`.div(that: `Dimensionless`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`Dimensionless`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `T`.div(that: Quan<`T`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `T`.div(that: `T`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`T`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T`.times(that: Quan<`Dimensionless`>) = `T`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T`.times(that: `Dimensionless`) = `T`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`Dimensionless`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `T`.times(that: Quan<`I`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `T`.times(that: `I`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`I`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J1_generic")
operator fun `T`.times(that: Quan<`J`>) = `T⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J1_concrete")
operator fun `T`.times(that: `J`) = `T⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`J`>) = thiz.run { `T⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T`.times(that: Quan<`T⁻¹`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T`.times(that: `T⁻¹`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `T`.times(that: Quan<`L⋅M⋅T⁻²`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `T`.times(that: `L⋅M⋅T⁻²`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `T`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `T`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `T`.times(that: Quan<`L²⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `T`.times(that: `L²⋅M⋅T⁻²`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `T`.times(that: Quan<`L²⋅M⋅T⁻³`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `T`.times(that: `L²⋅M⋅T⁻³`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `T`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `T`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `T`.div(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `T`.div(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `T`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `T`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `T`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `T`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `T`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `T`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `T`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `T`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `T`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `T`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J1_per_L2_generic")
operator fun `T`.times(that: Quan<`L⁻²⋅J`>) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J1_per_L2_concrete")
operator fun `T`.times(that: `L⁻²⋅J`) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J1_per_L2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⁻²⋅J`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T`.times(that: Quan<`L²⋅T⁻²`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T`.times(that: `L²⋅T⁻²`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `T`.times(that: Quan<`T⁻¹⋅N`>) = `N`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `T`.times(that: `T⁻¹⋅N`) = `N`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `N`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T`.times(that: Quan<`L⋅T⁻¹`>) = `L`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T`.times(that: `L⋅T⁻¹`) = `L`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T`.times(that: Quan<`L³⋅T⁻¹`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T`.times(that: `L³⋅T⁻¹`) = `L³`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T`.times(that: Quan<`L⋅T⁻²`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T`.times(that: `L⋅T⁻²`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `T`.times(that: Quan<`L⋅T⁻³`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `T`.times(that: `L⋅T⁻³`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T4_generic")
operator fun `T`.times(that: Quan<`L⋅T⁻⁴`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T4_concrete")
operator fun `T`.times(that: `L⋅T⁻⁴`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M0I0Theta0N0J0_per_T4_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⋅T⁻⁴`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `T`.times(that: Quan<`∠⋅T⁻¹`>) = `∠`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `T`.times(that: `∠⋅T⁻¹`) = `∠`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `∠`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T2_generic")
operator fun `T`.times(that: Quan<`∠⋅T⁻²`>) = `∠⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T2_concrete")
operator fun `T`.times(that: `∠⋅T⁻²`) = `∠⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`∠⋅T⁻²`>) = thiz.run { `∠⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T`.times(that: Quan<`L²⋅M⋅T⁻¹`>) = `L²⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T`.times(that: `L²⋅M⋅T⁻¹`) = `L²⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `T`.times(that: Quan<`L⋅M⋅T⁻³`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `T`.times(that: `L⋅M⋅T⁻³`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L2A0M1I0N0J0_per_T2Theta1_generic")
operator fun `T`.div(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_L2A0M1I0N0J0_per_T2Theta1_concrete")
operator fun `T`.div(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L2A0M1I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `T`.times(that: Quan<`M⋅T⁻²`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `T`.times(that: `M⋅T⁻²`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `T`.times(that: Quan<`M⋅T⁻³`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `T`.times(that: `M⋅T⁻³`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T`.times(that: Quan<`L²⋅T⁻¹`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T`.times(that: `L²⋅T⁻¹`) = `L²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `T`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `T`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `T`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `T`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `T`.times(that: Quan<`L⁻²⋅I`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `T`.times(that: `L⁻²⋅I`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `T`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `T`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `T`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `T`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `T`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `T`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `T`.times(that: Quan<`L⁻¹⋅I`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `T`.times(that: `L⁻¹⋅I`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `T`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `T`.times(that: `M⁻¹⋅T⋅I`) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `T`.times(that: Quan<`L²⋅T⁻³`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `T`.times(that: `L²⋅T⁻³`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `T`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `T`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T`.times(that: Quan<`M⋅T⁻¹`>) = `M`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T`.times(that: `M⋅T⁻¹`) = `M`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `T`.times(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `T`.times(that: `L⁻¹⋅M⋅T⁻³`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `T`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `T`.div(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `T`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `T`.div(that: `L⋅M⁻¹⋅T²`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`T`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `T`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `T`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `T`.times(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `T`.times(that: `L³⋅T⁻¹⋅N⁻¹`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T`.times(that: Quan<`T⁻²`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T`.times(that: `T⁻²`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T`>, that: Quan<`T⁻²`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }


typealias `T⁻¹` = L0A0M0I0Theta0N0J0_per_T1
inline class L0A0M0I0Theta0N0J0_per_T1(internal val underlying: Double) : Quan<`T⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "s⁻¹"

    override fun new(siValue: Double) = `T⁻¹`(siValue)

    override operator fun unaryPlus() = `T⁻¹`(+underlying)
    override operator fun unaryMinus() = `T⁻¹`(-underlying)

    override operator fun plus(that: `T⁻¹`) = `T⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `T⁻¹`) = `T⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `T⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `T⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `T⁻¹`) = `T⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `T⁻¹`) = if (this < that) this else that
    override infix fun max(that: `T⁻¹`) = if (this > that) this else that

    override val abs get() = `T⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `T⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `T⁻¹` && this.siValue == other.siValue
}

inline val Number.`Hertz`: `T⁻¹` get() = `T⁻¹`(toDouble() * 1.0)
inline val `T⁻¹`.`Hertz` get() = siValue * 1.0
object `Hertz` : UomConverter<`T⁻¹`>,
    Quan<`T⁻¹`> by box(`T⁻¹`(1.0)) {
    override val unitName = "Hertz"
    override fun invoke(x: Double) = x.`Hertz`
    override fun invoke(x: `T⁻¹`) = x.`Hertz`
}

inline val Number.`Becquerel`: `T⁻¹` get() = `T⁻¹`(toDouble() * 1.0)
inline val `T⁻¹`.`Becquerel` get() = siValue * 1.0
object `Becquerel` : UomConverter<`T⁻¹`>,
    Quan<`T⁻¹`> by box(`T⁻¹`(1.0)) {
    override val unitName = "Becquerel"
    override fun invoke(x: Double) = x.`Becquerel`
    override fun invoke(x: `T⁻¹`) = x.`Becquerel`
}


typealias `Frequency` = `T⁻¹`

typealias `Radioactivity` = `T⁻¹`

@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻¹`.div(that: Quan<`Dimensionless`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻¹`.div(that: `Dimensionless`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.div(that: Quan<`T⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.div(that: `T⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻¹`.times(that: Quan<`Dimensionless`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻¹`.times(that: `Dimensionless`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.times(that: Quan<`T⁻¹`>) = `T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.times(that: `T⁻¹`) = `T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻¹`.times(that: Quan<`L`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻¹`.times(that: `L`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `T⁻¹`.times(that: Quan<`M`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `T⁻¹`.times(that: `M`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`M`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `T⁻¹`.div(that: Quan<`T`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `T⁻¹`.div(that: `T`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`T`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `T⁻¹`.times(that: Quan<`T`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `T⁻¹`.times(that: `T`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`T`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N1J0_generic")
operator fun `T⁻¹`.times(that: Quan<`N`>) = `T⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `T⁻¹`.times(that: `N`) = `T⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N1J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`N`>) = thiz.run { `T⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A1M0T0I0Theta0N0J0_generic")
operator fun `T⁻¹`.times(that: Quan<`∠`>) = `∠⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `T⁻¹`.times(that: `∠`) = `∠⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A1M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`∠`>) = thiz.run { `∠⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `T⁻¹`.times(that: Quan<`L⋅M⋅T⁻²`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻¹`.times(that: `L⋅M⋅T⁻²`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `T⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `T⁻¹`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `T⁻¹`.times(that: Quan<`L²⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻¹`.times(that: `L²⋅M⋅T⁻²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `T⁻¹`.times(that: Quan<`T⋅I`>) = `I`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `T⁻¹`.times(that: `T⋅I`) = `I`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `T⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `T⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `T⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `T⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `T⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `T⁻¹`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `T⁻¹`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `T⁻¹`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `T⁻¹`.div(that: `M⋅T⁻²⋅I⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `T⁻¹`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `T⁻¹`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T⁻¹`.times(that: Quan<`L²⋅T⁻²`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻¹`.times(that: `L²⋅T⁻²`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻¹`.times(that: Quan<`L²`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻¹`.times(that: `L²`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻¹`.times(that: Quan<`L³`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻¹`.times(that: `L³`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L³`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.div(that: `L⋅T⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.times(that: Quan<`L⋅T⁻¹`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.times(that: `L⋅T⁻¹`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T⁻¹`.times(that: Quan<`L⋅T⁻²`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻¹`.times(that: `L⋅T⁻²`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `T⁻¹`.times(that: Quan<`L⋅T⁻³`>) = `L⋅T⁻⁴`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `T⁻¹`.times(that: `L⋅T⁻³`) = `L⋅T⁻⁴`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `L⋅T⁻⁴`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.times(that: Quan<`∠⋅T⁻¹`>) = `∠⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.times(that: `∠⋅T⁻¹`) = `∠⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `∠⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.times(that: Quan<`L⋅M⋅T⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.times(that: `L⋅M⋅T⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.times(that: Quan<`L²⋅M⋅T⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.times(that: `L²⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `T⁻¹`.div(that: Quan<`L⁻¹`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `T⁻¹`.div(that: `L⁻¹`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `T⁻¹`.div(that: Quan<`L⁻³⋅N`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `T⁻¹`.div(that: `L⁻³⋅N`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `T⁻¹`.times(that: Quan<`L³⋅N⁻¹`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `T⁻¹`.times(that: `L³⋅N⁻¹`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `T⁻¹`.times(that: Quan<`M⋅T⁻²`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻¹`.times(that: `M⋅T⁻²`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.div(that: `L²⋅T⁻¹`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.times(that: Quan<`L²⋅T⁻¹`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.times(that: `L²⋅T⁻¹`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `T⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `T⁻¹`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `T⁻¹`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `T⁻¹`.times(that: `L⁻²⋅T⋅I`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `T⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `T⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J1_generic")
operator fun `T⁻¹`.times(that: Quan<`T⋅J`>) = `J`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J1_concrete")
operator fun `T⁻¹`.times(that: `T⋅J`) = `J`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`T⋅J`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I0Theta0N0J1_per_L2_generic")
operator fun `T⁻¹`.times(that: Quan<`L⁻²⋅T⋅J`>) = `L⁻²⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I0Theta0N0J1_per_L2_concrete")
operator fun `T⁻¹`.times(that: `L⁻²⋅T⋅J`) = `L⁻²⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I0Theta0N0J1_per_L2_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻²⋅T⋅J`>) = thiz.run { `L⁻²⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `T⁻¹`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `T⁻¹`.div(that: `M⁻¹⋅T⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `T⁻¹`.times(that: Quan<`L⁻¹⋅M`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `T⁻¹`.times(that: `L⁻¹⋅M`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `T⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `T⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `T⁻¹`.div(that: Quan<`L⁻²`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `T⁻¹`.div(that: `L⁻²`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹`.times(that: Quan<`M⋅T⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹`.times(that: `M⋅T⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `T⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `T⁻¹`.div(that: `L⁻¹⋅M⋅T⁻³`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `T⁻¹`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `T⁻¹`.times(that: `M⁻¹⋅T²⋅I`) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `T⁻¹`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `T⁻¹`.div(that: `L⋅M⁻¹⋅T²`) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `T⁻¹`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `T⁻¹`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `T⁻¹`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `T⁻¹`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `T⁻¹`.div(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `L⁻³⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `T⁻¹`.div(that: `L³⋅T⁻¹⋅N⁻¹`) = `L⁻³⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `L⁻³⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1T0I0Theta0N0J0_generic")
operator fun `T⁻¹`.times(that: Quan<`L²⋅M`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1T0I0Theta0N0J0_concrete")
operator fun `T⁻¹`.times(that: `L²⋅M`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹`>, that: Quan<`L²⋅M`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T⁻¹`.div(that: Quan<`T⁻²`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻¹`.div(that: `T⁻²`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`T⁻¹`>, that: Quan<`T⁻²`>) = thiz.run { `T`(this.siValue / that.siValue) }


typealias `I` = L0A0M0T0I1Theta0N0J0
inline class L0A0M0T0I1Theta0N0J0(internal val underlying: Double) : Quan<`I`> {
    override val siValue get() = underlying
    override val abrev get() = "A"

    override fun new(siValue: Double) = `I`(siValue)

    override operator fun unaryPlus() = `I`(+underlying)
    override operator fun unaryMinus() = `I`(-underlying)

    override operator fun plus(that: `I`) = `I`(this.underlying + that.underlying)
    override operator fun minus(that: `I`) = `I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `I`(this.underlying / that.toDouble())
    override operator fun rem(that: `I`) = `I`(this.underlying % that.underlying)

    override infix fun min(that: `I`) = if (this < that) this else that
    override infix fun max(that: `I`) = if (this > that) this else that

    override val abs get() = `I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `I` && this.siValue == other.siValue
}

inline val Number.`Ampere`: `ElectricCurrent` get() = `I`(toDouble() * 1.0)
inline val `I`.`Ampere` get() = siValue * 1.0
object `Ampere` : UomConverter<`I`>,
    Quan<`I`> by box(`I`(1.0)) {
    override val unitName = "Ampere"
    override fun invoke(x: Double) = x.`Ampere`
    override fun invoke(x: `I`) = x.`Ampere`
}


typealias `ElectricCurrent` = `I`

@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `I`.div(that: Quan<`Dimensionless`>) = `I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `I`.div(that: `Dimensionless`) = `I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`Dimensionless`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `I`.div(that: Quan<`I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `I`.div(that: `I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `I`.times(that: Quan<`Dimensionless`>) = `I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `I`.times(that: `Dimensionless`) = `I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`Dimensionless`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `I`.div(that: Quan<`L`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `I`.div(that: `L`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `I`.times(that: Quan<`T`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `I`.times(that: `T`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`T`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `I`.div(that: Quan<`T⁻¹`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `I`.div(that: `T⁻¹`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`T⁻¹`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A1M0T0I0Theta0N0J0_generic")
operator fun `I`.times(that: Quan<`∠`>) = `∠⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `I`.times(that: `∠`) = `∠⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A1M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`∠`>) = thiz.run { `∠⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `I`.div(that: Quan<`T⋅I`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `I`.div(that: `T⋅I`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`T⋅I`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `I`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `I`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `I`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `I`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `I`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `I`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `I`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `I`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `I`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `I`.times(that: `M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `I`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `I`.div(that: Quan<`L²`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `I`.div(that: `L²`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L²`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `I`.times(that: Quan<`L²`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `I`.times(that: `L²`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L²`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `I`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `I`.div(that: `L⋅T⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `I`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `I`.div(that: `L³⋅T⁻¹`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `I`.times(that: Quan<`L⁻¹`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `I`.times(that: `L⁻¹`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `I`.div(that: Quan<`M⋅T⁻²`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `I`.div(that: `M⋅T⁻²`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `I`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `I`.div(that: `L²⋅T⁻¹`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `I`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `I`.div(that: `L⁻²⋅T⋅I`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `I`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `I`.div(that: `L⁻³⋅T⋅I`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `I`.div(that: Quan<`L⁻²⋅I`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `I`.div(that: `L⁻²⋅I`) = `L²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `I`.times(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `I`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `I`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `I`.div(that: Quan<`L⁻¹⋅I`>) = `L`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `I`.div(that: `L⁻¹⋅I`) = `L`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `I`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `I`.div(that: `M⁻¹⋅T⋅I`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `I`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `I`.div(that: `L⁻¹⋅T⋅I`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `I`.div(that: Quan<`L⁻²`>) = `L²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `I`.div(that: `L⁻²`) = `L²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⁻²`>) = thiz.run { `L²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `I`.times(that: Quan<`L⁻²`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `I`.times(that: `L⁻²`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `I`.div(that: Quan<`M⋅T⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `I`.div(that: `M⋅T⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I1Theta0N0J0_generic")
operator fun `I`.div(that: Quan<`L²⋅I`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I1Theta0N0J0_concrete")
operator fun `I`.div(that: `L²⋅I`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L²⋅I`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `I`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `I`.div(that: `M⁻¹⋅T²⋅I`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `I`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `I`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `I`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `I`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `I`.div(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `I`.div(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I1Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun div(thiz: Quan<`I`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }


typealias `Θ` = L0A0M0T0I0Theta1N0J0
inline class L0A0M0T0I0Theta1N0J0(internal val underlying: Double) : Quan<`Θ`> {
    override val siValue get() = underlying
    override val abrev get() = "K"

    override fun new(siValue: Double) = `Θ`(siValue)

    override operator fun unaryPlus() = `Θ`(+underlying)
    override operator fun unaryMinus() = `Θ`(-underlying)

    override operator fun plus(that: `Θ`) = `Θ`(this.underlying + that.underlying)
    override operator fun minus(that: `Θ`) = `Θ`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `Θ`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `Θ`(this.underlying / that.toDouble())
    override operator fun rem(that: `Θ`) = `Θ`(this.underlying % that.underlying)

    override infix fun min(that: `Θ`) = if (this < that) this else that
    override infix fun max(that: `Θ`) = if (this > that) this else that

    override val abs get() = `Θ`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `Θ`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `Θ` && this.siValue == other.siValue
}

inline val Number.`Kelvin`: `Temperature` get() = `Θ`(toDouble() * 1.0)
inline val `Θ`.`Kelvin` get() = siValue * 1.0
object `Kelvin` : UomConverter<`Θ`>,
    Quan<`Θ`> by box(`Θ`(1.0)) {
    override val unitName = "Kelvin"
    override fun invoke(x: Double) = x.`Kelvin`
    override fun invoke(x: `Θ`) = x.`Kelvin`
}


typealias `Temperature` = `Θ`

@JvmName("L0A0M0T0I0Theta1N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `Θ`.div(that: Quan<`Dimensionless`>) = `Θ`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `Θ`.div(that: `Dimensionless`) = `Θ`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`Θ`>, that: Quan<`Dimensionless`>) = thiz.run { `Θ`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_L0A0M0T0I0Theta1N0J0_generic")
operator fun `Θ`.div(that: Quan<`Θ`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Divide_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `Θ`.div(that: `Θ`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_L0A0M0T0I0Theta1N0J0_nonextension")
fun div(thiz: Quan<`Θ`>, that: Quan<`Θ`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `Θ`.times(that: Quan<`Dimensionless`>) = `Θ`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `Θ`.times(that: `Dimensionless`) = `Θ`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Θ`>, that: Quan<`Dimensionless`>) = thiz.run { `Θ`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `Θ`.div(that: Quan<`L`>) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `Θ`.div(that: `L`) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`Θ`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `Θ`.div(that: Quan<`L²⋅M⋅T⁻³`>) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Divide_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `Θ`.div(that: `L²⋅M⋅T⁻³`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`Θ`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `Θ`.times(that: Quan<`L⁻¹`>) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `Θ`.times(that: `L⁻¹`) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`Θ`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L2A0M1I0N0J0_per_T2Theta1_generic")
operator fun `Θ`.times(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L2A0M1I0N0J0_per_T2Theta1_concrete")
operator fun `Θ`.times(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L2A0M1I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`Θ`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L2A0M1I0J0_per_T2Theta1N1_generic")
operator fun `Θ`.times(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L2A0M1I0J0_per_T2Theta1N1_concrete")
operator fun `Θ`.times(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L2A0M1I0J0_per_T2Theta1N1_nonextension")
fun times(thiz: Quan<`Θ`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `Θ`.times(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `Θ`.times(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`Θ`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L1A0M1I0N0J0_per_T3Theta1_generic")
operator fun `Θ`.times(that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L1A0M1I0N0J0_per_T3Theta1_concrete")
operator fun `Θ`.times(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L1A0M1I0N0J0_per_T3Theta1_nonextension")
fun times(thiz: Quan<`Θ`>, that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `Θ`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Divide_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `Θ`.div(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`Θ`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `Θ`.times(that: Quan<`Θ⁻¹`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `Θ`.times(that: `Θ⁻¹`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Multiply_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun times(thiz: Quan<`Θ`>, that: Quan<`Θ⁻¹`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `Θ`.div(that: Quan<`L⁻¹⋅Θ`>) = `L`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta1N0J0_Divide_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `Θ`.div(that: `L⁻¹⋅Θ`) = `L`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta1N0J0_Divide_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun div(thiz: Quan<`Θ`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `L`(this.siValue / that.siValue) }


typealias `Θ⁻¹` = L0A0M0T0I0N0J0_per_Theta1
inline class L0A0M0T0I0N0J0_per_Theta1(internal val underlying: Double) : Quan<`Θ⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "K⁻¹"

    override fun new(siValue: Double) = `Θ⁻¹`(siValue)

    override operator fun unaryPlus() = `Θ⁻¹`(+underlying)
    override operator fun unaryMinus() = `Θ⁻¹`(-underlying)

    override operator fun plus(that: `Θ⁻¹`) = `Θ⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `Θ⁻¹`) = `Θ⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `Θ⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `Θ⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `Θ⁻¹`) = `Θ⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `Θ⁻¹`) = if (this < that) this else that
    override infix fun max(that: `Θ⁻¹`) = if (this > that) this else that

    override val abs get() = `Θ⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `Θ⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `Θ⁻¹` && this.siValue == other.siValue
}


typealias `ThermalExpansionCoefficient` = `Θ⁻¹`

@JvmName("L0A0M0T0I0N0J0_per_Theta1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `Θ⁻¹`.div(that: Quan<`Dimensionless`>) = `Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0N0J0_per_Theta1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `Θ⁻¹`.div(that: `Dimensionless`) = `Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`Θ⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `Θ⁻¹`.div(that: Quan<`Θ⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0N0J0_per_Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `Θ⁻¹`.div(that: `Θ⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun div(thiz: Quan<`Θ⁻¹`>, that: Quan<`Θ⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `Θ⁻¹`.times(that: Quan<`Dimensionless`>) = `Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `Θ⁻¹`.times(that: `Dimensionless`) = `Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`Θ⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L0A0M0T0I0Theta1N0J0_generic")
operator fun `Θ⁻¹`.times(that: Quan<`Θ`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `Θ⁻¹`.times(that: `Θ`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L0A0M0T0I0Theta1N0J0_nonextension")
fun times(thiz: Quan<`Θ⁻¹`>, that: Quan<`Θ`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `Θ⁻¹`.times(that: Quan<`L²⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `Θ⁻¹`.times(that: `L²⋅M⋅T⁻²`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`Θ⁻¹`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `Θ⁻¹`.times(that: Quan<`L²⋅T⁻²`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `Θ⁻¹`.times(that: `L²⋅T⁻²`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`Θ⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `Θ⁻¹`.times(that: Quan<`L⋅M⋅T⁻³`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `Θ⁻¹`.times(that: `L⋅M⋅T⁻³`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`Θ⁻¹`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `Θ⁻¹`.times(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `Θ⁻¹`.times(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun times(thiz: Quan<`Θ⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `Θ⁻¹`.times(that: Quan<`L⁻¹⋅Θ`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `Θ⁻¹`.times(that: `L⁻¹⋅Θ`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0N0J0_per_Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun times(thiz: Quan<`Θ⁻¹`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }


typealias `N` = L0A0M0T0I0Theta0N1J0
inline class L0A0M0T0I0Theta0N1J0(internal val underlying: Double) : Quan<`N`> {
    override val siValue get() = underlying
    override val abrev get() = "mol"

    override fun new(siValue: Double) = `N`(siValue)

    override operator fun unaryPlus() = `N`(+underlying)
    override operator fun unaryMinus() = `N`(-underlying)

    override operator fun plus(that: `N`) = `N`(this.underlying + that.underlying)
    override operator fun minus(that: `N`) = `N`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `N`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `N`(this.underlying / that.toDouble())
    override operator fun rem(that: `N`) = `N`(this.underlying % that.underlying)

    override infix fun min(that: `N`) = if (this < that) this else that
    override infix fun max(that: `N`) = if (this > that) this else that

    override val abs get() = `N`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `N`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `N` && this.siValue == other.siValue
}

inline val Number.`Mole`: `AmountOfSubstance` get() = `N`(toDouble() * 1.0)
inline val `N`.`Mole` get() = siValue * 1.0
object `Mole` : UomConverter<`N`>,
    Quan<`N`> by box(`N`(1.0)) {
    override val unitName = "Mole"
    override fun invoke(x: Double) = x.`Mole`
    override fun invoke(x: `N`) = x.`Mole`
}


typealias `AmountOfSubstance` = `N`

@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `N`.div(that: Quan<`Dimensionless`>) = `N`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `N`.div(that: `Dimensionless`) = `N`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`N`>, that: Quan<`Dimensionless`>) = thiz.run { `N`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0T0I0Theta0N1J0_generic")
operator fun `N`.div(that: Quan<`N`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `N`.div(that: `N`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0T0I0Theta0N1J0_nonextension")
fun div(thiz: Quan<`N`>, that: Quan<`N`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `N`.times(that: Quan<`Dimensionless`>) = `N`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `N`.times(that: `Dimensionless`) = `N`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`N`>, that: Quan<`Dimensionless`>) = thiz.run { `N`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `N`.div(that: Quan<`M`>) = `M⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `N`.div(that: `M`) = `M⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`N`>, that: Quan<`M`>) = thiz.run { `M⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `N`.div(that: Quan<`T`>) = `T⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `N`.div(that: `T`) = `T⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`N`>, that: Quan<`T`>) = thiz.run { `T⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `N`.times(that: Quan<`T⁻¹`>) = `T⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `N`.times(that: `T⁻¹`) = `T⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`N`>, that: Quan<`T⁻¹`>) = thiz.run { `T⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `N`.div(that: Quan<`T⁻¹⋅N`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `N`.div(that: `T⁻¹⋅N`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun div(thiz: Quan<`N`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `N`.div(that: Quan<`L³`>) = `L⁻³⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `N`.div(that: `L³`) = `L⁻³⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`N`>, that: Quan<`L³`>) = thiz.run { `L⁻³⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `N`.div(that: Quan<`L⁻³⋅N`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Divide_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `N`.div(that: `L⁻³⋅N`) = `L³`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun div(thiz: Quan<`N`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `N`.times(that: Quan<`L³⋅N⁻¹`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `N`.times(that: `L³⋅N⁻¹`) = `L³`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`N`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L2A0M1I0J0_per_T2Theta1N1_generic")
operator fun `N`.times(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L2A0M1I0J0_per_T2Theta1N1_concrete")
operator fun `N`.times(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L2A0M1I0J0_per_T2Theta1N1_nonextension")
fun times(thiz: Quan<`N`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `N`.times(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `N`.times(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun times(thiz: Quan<`N`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `N`.div(that: Quan<`M⁻¹⋅N`>) = `M`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `N`.div(that: `M⁻¹⋅N`) = `M`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Divide_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun div(thiz: Quan<`N`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `N`.times(that: Quan<`M⋅N⁻¹`>) = `M`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `N`.times(that: `M⋅N⁻¹`) = `M`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`N`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `N`.times(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `N`.times(that: `L³⋅T⁻¹⋅N⁻¹`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N1J0_Multiply_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun times(thiz: Quan<`N`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }


typealias `J` = L0A0M0T0I0Theta0N0J1
inline class L0A0M0T0I0Theta0N0J1(internal val underlying: Double) : Quan<`J`> {
    override val siValue get() = underlying
    override val abrev get() = "cd"

    override fun new(siValue: Double) = `J`(siValue)

    override operator fun unaryPlus() = `J`(+underlying)
    override operator fun unaryMinus() = `J`(-underlying)

    override operator fun plus(that: `J`) = `J`(this.underlying + that.underlying)
    override operator fun minus(that: `J`) = `J`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `J`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `J`(this.underlying / that.toDouble())
    override operator fun rem(that: `J`) = `J`(this.underlying % that.underlying)

    override infix fun min(that: `J`) = if (this < that) this else that
    override infix fun max(that: `J`) = if (this > that) this else that

    override val abs get() = `J`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `J`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `J` && this.siValue == other.siValue
}

inline val Number.`Candela`: `LuminousIntensity` get() = `J`(toDouble() * 1.0)
inline val `J`.`Candela` get() = siValue * 1.0
object `Candela` : UomConverter<`J`>,
    Quan<`J`> by box(`J`(1.0)) {
    override val unitName = "Candela"
    override fun invoke(x: Double) = x.`Candela`
    override fun invoke(x: `J`) = x.`Candela`
}


typealias `LuminousIntensity` = `J`

@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `J`.div(that: Quan<`Dimensionless`>) = `J`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `J`.div(that: `Dimensionless`) = `J`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`Dimensionless`>) = thiz.run { `J`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J1_generic")
operator fun `J`.div(that: Quan<`J`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J1_concrete")
operator fun `J`.div(that: `J`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J1_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`J`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `J`.times(that: Quan<`Dimensionless`>) = `J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `J`.times(that: `Dimensionless`) = `J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`J`>, that: Quan<`Dimensionless`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `J`.times(that: Quan<`T`>) = `T⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `J`.times(that: `T`) = `T⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`J`>, that: Quan<`T`>) = thiz.run { `T⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `J`.div(that: Quan<`T⁻¹`>) = `T⋅J`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `J`.div(that: `T⁻¹`) = `T⋅J`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`T⁻¹`>) = thiz.run { `T⋅J`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Multiply_L0A2M0T0I0Theta0N0J0_generic")
operator fun `J`.times(that: Quan<`∠²`>) = `∠²⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Multiply_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `J`.times(that: `∠²`) = `∠²⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Multiply_L0A2M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`J`>, that: Quan<`∠²`>) = thiz.run { `∠²⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `J`.div(that: Quan<`L²⋅M⋅T⁻³`>) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `J`.div(that: `L²⋅M⋅T⁻³`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_A0M0T0I0Theta0N0J1_per_L2_generic")
operator fun `J`.div(that: Quan<`L⁻²⋅J`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_A0M0T0I0Theta0N0J1_per_L2_concrete")
operator fun `J`.div(that: `L⁻²⋅J`) = `L²`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_A0M0T0I0Theta0N0J1_per_L2_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`L⁻²⋅J`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `J`.div(that: Quan<`L²`>) = `L⁻²⋅J`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `J`.div(that: `L²`) = `L⁻²⋅J`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`L²`>) = thiz.run { `L⁻²⋅J`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `J`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻²⋅T⋅J`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `J`.div(that: `L²⋅T⁻¹`) = `L⁻²⋅T⋅J`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0T1I0Theta0N0J1_generic")
operator fun `J`.div(that: Quan<`T⋅J`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0T1I0Theta0N0J1_concrete")
operator fun `J`.div(that: `T⋅J`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_L0A0M0T1I0Theta0N0J1_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`T⋅J`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_A0M0T1I0Theta0N0J1_per_L2_generic")
operator fun `J`.div(that: Quan<`L⁻²⋅T⋅J`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_A0M0T1I0Theta0N0J1_per_L2_concrete")
operator fun `J`.div(that: `L⁻²⋅T⋅J`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_A0M0T1I0Theta0N0J1_per_L2_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`L⁻²⋅T⋅J`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `J`.times(that: Quan<`L⁻²`>) = `L⁻²⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `J`.times(that: `L⁻²`) = `L⁻²⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`J`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻²⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `J`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M0T0I0Theta0N0J1_Divide_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `J`.div(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M0T0I0Theta0N0J1_Divide_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun div(thiz: Quan<`J`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue / that.siValue) }


typealias `T⁻²` = L0A0M0I0Theta0N0J0_per_T2
inline class L0A0M0I0Theta0N0J0_per_T2(internal val underlying: Double) : Quan<`T⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "s⁻²"

    override fun new(siValue: Double) = `T⁻²`(siValue)

    override operator fun unaryPlus() = `T⁻²`(+underlying)
    override operator fun unaryMinus() = `T⁻²`(-underlying)

    override operator fun plus(that: `T⁻²`) = `T⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `T⁻²`) = `T⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `T⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `T⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `T⁻²`) = `T⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `T⁻²`) = if (this < that) this else that
    override infix fun max(that: `T⁻²`) = if (this > that) this else that

    override val abs get() = `T⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `T⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `T⁻²` && this.siValue == other.siValue
}


typealias `FrequencyDrift` = `T⁻²`

@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻²`.div(that: Quan<`Dimensionless`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻²`.div(that: `Dimensionless`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T⁻²`.div(that: Quan<`T⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻²`.div(that: `T⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`T⁻²`>, that: Quan<`T⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻²`.times(that: Quan<`Dimensionless`>) = `T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻²`.times(that: `Dimensionless`) = `T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻²`.times(that: Quan<`L`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻²`.times(that: `L`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `T⁻²`.times(that: Quan<`M`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `T⁻²`.times(that: `M`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`M`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `T⁻²`.times(that: Quan<`T`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `T⁻²`.times(that: `T`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`T`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻²`.div(that: Quan<`T⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻²`.div(that: `T⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A1M0T0I0Theta0N0J0_generic")
operator fun `T⁻²`.times(that: Quan<`∠`>) = `∠⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `T⁻²`.times(that: `∠`) = `∠⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A1M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`∠`>) = thiz.run { `∠⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `T⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `T⁻²`.times(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T⁻²`.div(that: Quan<`L²⋅T⁻²`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻²`.div(that: `L²⋅T⁻²`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`T⁻²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻²`.times(that: Quan<`L²`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻²`.times(that: `L²`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L²`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻²`.times(that: Quan<`L⋅T⁻¹`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻²`.times(that: `L⋅T⁻¹`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T⁻²`.div(that: Quan<`L⋅T⁻²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻²`.div(that: `L⋅T⁻²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`T⁻²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `T⁻²`.times(that: Quan<`L⋅T⁻²`>) = `L⋅T⁻⁴`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `T⁻²`.times(that: `L⋅T⁻²`) = `L⋅T⁻⁴`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⋅T⁻⁴`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T⁻²`.times(that: Quan<`L⋅M⋅T⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻²`.times(that: `L⋅M⋅T⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T⁻²`.times(that: Quan<`L²⋅M⋅T⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻²`.times(that: `L²⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `T⁻²`.div(that: Quan<`L⁻¹`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `T⁻²`.div(that: `L⁻¹`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻²`.times(that: Quan<`L²⋅T⁻¹`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻²`.times(that: `L²⋅T⁻¹`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `T⁻²`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `T⁻²`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `T⁻²`.times(that: Quan<`L⁻¹⋅M`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `T⁻²`.times(that: `L⁻¹⋅M`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `T⁻²`.div(that: Quan<`L⁻²`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `T⁻²`.div(that: `L⁻²`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`T⁻²`>, that: Quan<`L⁻²`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T⁻²`.times(that: Quan<`M⋅T⁻¹`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻²`.times(that: `M⋅T⁻¹`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M1T0I0Theta0N0J0_generic")
operator fun `T⁻²`.times(that: Quan<`L²⋅M`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M1T0I0Theta0N0J0_concrete")
operator fun `T⁻²`.times(that: `L²⋅M`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N0J0_per_T2_Multiply_L2A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻²`>, that: Quan<`L²⋅M`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }


typealias `∠` = L0A1M0T0I0Theta0N0J0
inline class L0A1M0T0I0Theta0N0J0(internal val underlying: Double) : Quan<`∠`> {
    override val siValue get() = underlying
    override val abrev get() = "rad"

    override fun new(siValue: Double) = `∠`(siValue)

    override operator fun unaryPlus() = `∠`(+underlying)
    override operator fun unaryMinus() = `∠`(-underlying)

    override operator fun plus(that: `∠`) = `∠`(this.underlying + that.underlying)
    override operator fun minus(that: `∠`) = `∠`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `∠`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `∠`(this.underlying / that.toDouble())
    override operator fun rem(that: `∠`) = `∠`(this.underlying % that.underlying)

    override infix fun min(that: `∠`) = if (this < that) this else that
    override infix fun max(that: `∠`) = if (this > that) this else that

    override val abs get() = `∠`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `∠`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `∠` && this.siValue == other.siValue
}

inline val Number.`Radian`: `Angle` get() = `∠`(toDouble() * 1.0)
inline val `∠`.`Radian` get() = siValue * 1.0
object `Radian` : UomConverter<`∠`>,
    Quan<`∠`> by box(`∠`(1.0)) {
    override val unitName = "Radian"
    override fun invoke(x: Double) = x.`Radian`
    override fun invoke(x: `∠`) = x.`Radian`
}


typealias `Angle` = `∠`

@JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠`.div(that: Quan<`Dimensionless`>) = `∠`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠`.div(that: `Dimensionless`) = `∠`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠`>, that: Quan<`Dimensionless`>) = thiz.run { `∠`(this.siValue / that.siValue) }
@JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A1M0T0I0Theta0N0J0_generic")
operator fun `∠`.div(that: Quan<`∠`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `∠`.div(that: `∠`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A1M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠`>, that: Quan<`∠`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠`.times(that: Quan<`Dimensionless`>) = `∠`(this.siValue * that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠`.times(that: `Dimensionless`) = `∠`(this.siValue * that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠`>, that: Quan<`Dimensionless`>) = thiz.run { `∠`(this.siValue * that.siValue) }
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A1M0T0I0Theta0N0J0_generic")
operator fun `∠`.times(that: Quan<`∠`>) = `∠²`(this.siValue * that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `∠`.times(that: `∠`) = `∠²`(this.siValue * that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A1M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠`>, that: Quan<`∠`>) = thiz.run { `∠²`(this.siValue * that.siValue) }
@JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `∠`.div(that: Quan<`T`>) = `∠⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `∠`.div(that: `T`) = `∠⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠`>, that: Quan<`T`>) = thiz.run { `∠⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `∠`.times(that: Quan<`I`>) = `∠⋅I`(this.siValue * that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `∠`.times(that: `I`) = `∠⋅I`(this.siValue * that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠`>, that: Quan<`I`>) = thiz.run { `∠⋅I`(this.siValue * that.siValue) }
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `∠`.times(that: Quan<`T⁻¹`>) = `∠⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `∠`.times(that: `T⁻¹`) = `∠⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`∠`>, that: Quan<`T⁻¹`>) = thiz.run { `∠⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `∠`.div(that: Quan<`∠⋅T⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `∠`.div(that: `∠⋅T⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Divide_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`∠`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A1T2_generic")
operator fun `∠`.times(that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A1T2_concrete")
operator fun `∠`.times(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A1T2_nonextension")
fun times(thiz: Quan<`∠`>, that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `∠`.times(that: Quan<`T⁻²`>) = `∠⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `∠`.times(that: `T⁻²`) = `∠⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A1M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`∠`>, that: Quan<`T⁻²`>) = thiz.run { `∠⋅T⁻²`(this.siValue * that.siValue) }


typealias `∠²` = L0A2M0T0I0Theta0N0J0
inline class L0A2M0T0I0Theta0N0J0(internal val underlying: Double) : Quan<`∠²`> {
    override val siValue get() = underlying
    override val abrev get() = "rad²"

    override fun new(siValue: Double) = `∠²`(siValue)

    override operator fun unaryPlus() = `∠²`(+underlying)
    override operator fun unaryMinus() = `∠²`(-underlying)

    override operator fun plus(that: `∠²`) = `∠²`(this.underlying + that.underlying)
    override operator fun minus(that: `∠²`) = `∠²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `∠²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `∠²`(this.underlying / that.toDouble())
    override operator fun rem(that: `∠²`) = `∠²`(this.underlying % that.underlying)

    override infix fun min(that: `∠²`) = if (this < that) this else that
    override infix fun max(that: `∠²`) = if (this > that) this else that

    override val abs get() = `∠²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `∠²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `∠²` && this.siValue == other.siValue
}

inline val Number.`Steradian`: `SolidAngle` get() = `∠²`(toDouble() * 1.0)
inline val `∠²`.`Steradian` get() = siValue * 1.0
object `Steradian` : UomConverter<`∠²`>,
    Quan<`∠²`> by box(`∠²`(1.0)) {
    override val unitName = "Steradian"
    override fun invoke(x: Double) = x.`Steradian`
    override fun invoke(x: `∠²`) = x.`Steradian`
}


typealias `SolidAngle` = `∠²`

@JvmName("L0A2M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠²`.div(that: Quan<`Dimensionless`>) = `∠²`(this.siValue / that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠²`.div(that: `Dimensionless`) = `∠²`(this.siValue / that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠²`>, that: Quan<`Dimensionless`>) = thiz.run { `∠²`(this.siValue / that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J0_Divide_L0A2M0T0I0Theta0N0J0_generic")
operator fun `∠²`.div(that: Quan<`∠²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J0_Divide_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `∠²`.div(that: `∠²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J0_Divide_L0A2M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠²`>, that: Quan<`∠²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠²`.times(that: Quan<`Dimensionless`>) = `∠²`(this.siValue * that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠²`.times(that: `Dimensionless`) = `∠²`(this.siValue * that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠²`>, that: Quan<`Dimensionless`>) = thiz.run { `∠²`(this.siValue * that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J1_generic")
operator fun `∠²`.times(that: Quan<`J`>) = `∠²⋅J`(this.siValue * that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J1_concrete")
operator fun `∠²`.times(that: `J`) = `∠²⋅J`(this.siValue * that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J1_nonextension")
fun times(thiz: Quan<`∠²`>, that: Quan<`J`>) = thiz.run { `∠²⋅J`(this.siValue * that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J0_Divide_L0A1M0T0I0Theta0N0J0_generic")
operator fun `∠²`.div(that: Quan<`∠`>) = `∠`(this.siValue / that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J0_Divide_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `∠²`.div(that: `∠`) = `∠`(this.siValue / that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J0_Divide_L0A1M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠²`>, that: Quan<`∠`>) = thiz.run { `∠`(this.siValue / that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A2T3_generic")
operator fun `∠²`.times(that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `∠²`.times(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L2M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`∠²`>, that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `∠²`.times(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `∠²`.times(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`∠²`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `∠²`.times(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `∠²`.times(that: `∠⁻²⋅M⋅T⁻³`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`∠²`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `∠²`.times(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `∠²`.times(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun times(thiz: Quan<`∠²`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L⋅M⋅T⁻²` = L1A0M1I0Theta0N0J0_per_T2
inline class L1A0M1I0Theta0N0J0_per_T2(internal val underlying: Double) : Quan<`L⋅M⋅T⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅kg⋅s⁻²"

    override fun new(siValue: Double) = `L⋅M⋅T⁻²`(siValue)

    override operator fun unaryPlus() = `L⋅M⋅T⁻²`(+underlying)
    override operator fun unaryMinus() = `L⋅M⋅T⁻²`(-underlying)

    override operator fun plus(that: `L⋅M⋅T⁻²`) = `L⋅M⋅T⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅M⋅T⁻²`) = `L⋅M⋅T⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅M⋅T⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅M⋅T⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅M⋅T⁻²`) = `L⋅M⋅T⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅M⋅T⁻²`) = if (this < that) this else that
    override infix fun max(that: `L⋅M⋅T⁻²`) = if (this > that) this else that

    override val abs get() = `L⋅M⋅T⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅M⋅T⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅M⋅T⁻²` && this.siValue == other.siValue
}

inline val Number.`Newton`: `L⋅M⋅T⁻²` get() = `L⋅M⋅T⁻²`(toDouble() * 1.0)
inline val `L⋅M⋅T⁻²`.`Newton` get() = siValue * 1.0
object `Newton` : UomConverter<`L⋅M⋅T⁻²`>,
    Quan<`L⋅M⋅T⁻²`> by box(`L⋅M⋅T⁻²`(1.0)) {
    override val unitName = "Newton"
    override fun invoke(x: Double) = x.`Newton`
    override fun invoke(x: `L⋅M⋅T⁻²`) = x.`Newton`
}


typealias `Force` = `L⋅M⋅T⁻²`

typealias `Weight` = `L⋅M⋅T⁻²`

@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `Dimensionless`) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.times(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.times(that: `Dimensionless`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.times(that: Quan<`L`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.times(that: `L`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`M`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `M`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`M`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`T`>) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `T`) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.times(that: Quan<`T`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.times(that: `T`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`T⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `T⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²`.times(that: Quan<`T⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²`.times(that: `T⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻²`) = `L²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`T⋅I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `T⋅I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`T⋅I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L²⋅T⁻²`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L²⋅T⁻²`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L²`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L²`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L²`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⋅T⁻¹`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⋅T⁻¹`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²`.times(that: Quan<`L⋅T⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²`.times(that: `L⋅T⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⋅T⁻²`>) = `M`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⋅T⁻²`) = `M`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻³`>) = `T`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻³`) = `T`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²`.times(that: Quan<`L⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²`.times(that: `L⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0N0J0_per_T2Theta1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0N0J0_per_T2Theta1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`M⋅T⁻²`>) = `L`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `M⋅T⁻²`) = `L`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L²⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⁻²⋅I`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⁻²⋅I`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⁻¹⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⁻¹⋅M`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⁻¹⋅T⋅I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻²`.times(that: Quan<`L⁻²`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻²`.times(that: `L⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`M⋅T⁻¹`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `M⋅T⁻¹`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅Θ`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⁻¹⋅Θ`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L⋅M⋅T⁻²`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L⋅M⋅T⁻²`.times(that: `L⋅M⁻¹⋅T²`) = `L²`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻²`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻²`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T2_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }


typealias `L⁻¹⋅M⋅T⁻²` = A0M1I0Theta0N0J0_per_L1T2
inline class A0M1I0Theta0N0J0_per_L1T2(internal val underlying: Double) : Quan<`L⁻¹⋅M⋅T⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹⋅kg⋅s⁻²"

    override fun new(siValue: Double) = `L⁻¹⋅M⋅T⁻²`(siValue)

    override operator fun unaryPlus() = `L⁻¹⋅M⋅T⁻²`(+underlying)
    override operator fun unaryMinus() = `L⁻¹⋅M⋅T⁻²`(-underlying)

    override operator fun plus(that: `L⁻¹⋅M⋅T⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹⋅M⋅T⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹⋅M⋅T⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹⋅M⋅T⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹⋅M⋅T⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹⋅M⋅T⁻²`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹⋅M⋅T⁻²`) = if (this > that) this else that

    override val abs get() = `L⁻¹⋅M⋅T⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹⋅M⋅T⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹⋅M⋅T⁻²` && this.siValue == other.siValue
}

inline val Number.`Pascal`: `L⁻¹⋅M⋅T⁻²` get() = `L⁻¹⋅M⋅T⁻²`(toDouble() * 1.0)
inline val `L⁻¹⋅M⋅T⁻²`.`Pascal` get() = siValue * 1.0
object `Pascal` : UomConverter<`L⁻¹⋅M⋅T⁻²`>,
    Quan<`L⁻¹⋅M⋅T⁻²`> by box(`L⁻¹⋅M⋅T⁻²`(1.0)) {
    override val unitName = "Pascal"
    override fun invoke(x: Double) = x.`Pascal`
    override fun invoke(x: `L⁻¹⋅M⋅T⁻²`) = x.`Pascal`
}


typealias `Pressure` = `L⁻¹⋅M⋅T⁻²`

typealias `Stress` = `L⁻¹⋅M⋅T⁻²`

typealias `EnergyDensity` = `L⁻¹⋅M⋅T⁻²`

@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`Dimensionless`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `Dimensionless`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`Dimensionless`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `Dimensionless`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`L`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `L`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`T`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `T`) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`T`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `T`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`T⁻¹`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `T⁻¹`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻²`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻²`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L²⋅T⁻²`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L²⋅T⁻²`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`L²`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `L²`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L²`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`L³`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `L³`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L³`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`L⋅T⁻¹`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `L⋅T⁻¹`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`L³⋅T⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `L³⋅T⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⋅T⁻²`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⋅T⁻²`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻¹`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻¹`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻²⋅M`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻²⋅M`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻³⋅M`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻³⋅M`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`L³⋅M⁻¹`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `L³⋅M⁻¹`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻³⋅N`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻³⋅N`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`L³⋅N⁻¹`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `L³⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `L⁻³⋅N`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L⁻³⋅N`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `L⁻³⋅N`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`M⋅T⁻²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `M⋅T⁻²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`L²⋅T⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `L²⋅T⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻²⋅T⋅I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻³⋅T⋅I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻²⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻²⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻¹⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻¹⋅M`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻²`>) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻²`) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻²`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `T`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻³`) = `T`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `M⁻¹⋅T²⋅I`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.times(that: `L⋅M⁻¹⋅T²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: Quan<`T⁻²`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻²`.div(that: `T⁻²`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T2_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻²`>, that: Quan<`T⁻²`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }


typealias `L⋅M⁻¹⋅T²` = L1A0T2I0Theta0N0J0_per_M1
inline class L1A0T2I0Theta0N0J0_per_M1(internal val underlying: Double) : Quan<`L⋅M⁻¹⋅T²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅kg⁻¹⋅s²"

    override fun new(siValue: Double) = `L⋅M⁻¹⋅T²`(siValue)

    override operator fun unaryPlus() = `L⋅M⁻¹⋅T²`(+underlying)
    override operator fun unaryMinus() = `L⋅M⁻¹⋅T²`(-underlying)

    override operator fun plus(that: `L⋅M⁻¹⋅T²`) = `L⋅M⁻¹⋅T²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅M⁻¹⋅T²`) = `L⋅M⁻¹⋅T²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅M⁻¹⋅T²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅M⁻¹⋅T²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅M⁻¹⋅T²`) = `L⋅M⁻¹⋅T²`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅M⁻¹⋅T²`) = if (this < that) this else that
    override infix fun max(that: `L⋅M⁻¹⋅T²`) = if (this > that) this else that

    override val abs get() = `L⋅M⁻¹⋅T²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅M⁻¹⋅T²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅M⁻¹⋅T²` && this.siValue == other.siValue
}


typealias `Compressibility` = `L⋅M⁻¹⋅T²`

@JvmName("L1A0T2I0Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⁻¹⋅T²`.div(that: Quan<`Dimensionless`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⁻¹⋅T²`.div(that: `Dimensionless`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L⋅M⁻¹⋅T²`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L⋅M⁻¹⋅T²`.div(that: `L⋅M⁻¹⋅T²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`Dimensionless`>) = `L⋅M⁻¹⋅T²`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `Dimensionless`) = `L⋅M⁻¹⋅T²`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L⋅M⋅T⁻²`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L⋅M⋅T⁻²`) = `L²`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L⁻¹⋅M⋅T⁻²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L²⋅M⋅T⁻²`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L²⋅M⋅T⁻²`) = `L³`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L²⋅M⋅T⁻³`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L²⋅M⋅T⁻³`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L²⋅T⁻²`>) = `L³⋅M⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L²⋅T⁻²`) = `L³⋅M⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L³⋅M⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L⋅M⋅T⁻³`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L⋅M⋅T⁻³`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`M⋅T⁻²`>) = `L`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `M⋅T⁻²`) = `L`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`M⋅T⁻³`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `M⋅T⁻³`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `T`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `T`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L⁻¹⋅I`>) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L⁻¹⋅I`) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L⋅M⁻¹⋅T²`.times(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L⋅M⁻¹⋅T²`.times(that: `L⁻¹⋅M⋅T⁻³`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0T2I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun times(thiz: Quan<`L⋅M⁻¹⋅T²`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }


typealias `L²⋅M⋅T⁻²` = L2A0M1I0Theta0N0J0_per_T2
inline class L2A0M1I0Theta0N0J0_per_T2(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻²"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻²`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻²`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻²`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻²`) = `L²⋅M⋅T⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻²`) = `L²⋅M⋅T⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻²`) = `L²⋅M⋅T⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻²`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻²`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻²` && this.siValue == other.siValue
}

inline val Number.`Joule`: `L²⋅M⋅T⁻²` get() = `L²⋅M⋅T⁻²`(toDouble() * 1.0)
inline val `L²⋅M⋅T⁻²`.`Joule` get() = siValue * 1.0
object `Joule` : UomConverter<`L²⋅M⋅T⁻²`>,
    Quan<`L²⋅M⋅T⁻²`> by box(`L²⋅M⋅T⁻²`(1.0)) {
    override val unitName = "Joule"
    override fun invoke(x: Double) = x.`Joule`
    override fun invoke(x: `L²⋅M⋅T⁻²`) = x.`Joule`
}


typealias `Energy` = `L²⋅M⋅T⁻²`

typealias `Work` = `L²⋅M⋅T⁻²`

typealias `Heat` = `L²⋅M⋅T⁻²`

typealias `MomentOfForce` = `L²⋅M⋅T⁻²`

@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L`>) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L`) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`M`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `M`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`M`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`T`>) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `T`) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.times(that: Quan<`T`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.times(that: `T`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`Θ`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `Θ`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta1N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`Θ`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N1J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`N`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `N`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N1J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`N`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`T⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `T⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²`.times(that: Quan<`T⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²`.times(that: `T⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A1M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`∠`>) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `∠`) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A1M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`∠`>) = thiz.run { `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻²`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻²`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻²`) = `L³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻³`>) = `T`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻³`) = `T`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`T⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `T⋅I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`T⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `I`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `I`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L²⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L²⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅T⁻²`>) = `M`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅T⁻²`) = `M`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L³`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L³`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L³`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L⋅T⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L³⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻¹`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L⋅M⋅T⁻¹`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2M1I0Theta0N0J0_per_A1T2_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = `∠`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2M1I0Theta0N0J0_per_A1T2_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = `∠`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2M1I0Theta0N0J0_per_A1T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = thiz.run { `∠`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²`.times(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²`.times(that: `L⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0N0J0_per_T2Theta1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = `Θ`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0N0J0_per_T2Theta1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `Θ`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `Θ`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `N`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `N`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `N`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`M⋅T⁻²`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `M⋅T⁻²`) = `L²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅T⁻¹`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅T⁻¹`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L⁻¹⋅I`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L⁻¹⋅I`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻²`.times(that: Quan<`L⁻²`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻²`.times(that: `L⁻²`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⁻²`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`M⋅T⁻¹`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `M⋅T⁻¹`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L²⋅M⋅T⁻²`.times(that: Quan<`Θ⁻¹`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L²⋅M⋅T⁻²`.times(that: `Θ⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻²`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻²`.times(that: `M⁻¹⋅T²⋅I`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻²`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻²`.times(that: `L⋅M⁻¹⋅T²`) = `L³`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`L²⋅M`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `L²⋅M`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L²⋅M`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻²`.div(that: Quan<`T⁻²`>) = `L²⋅M`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻²`.div(that: `T⁻²`) = `L²⋅M`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`T⁻²`>) = thiz.run { `L²⋅M`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `T⋅J`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻²`.times(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `T⋅J`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T2_Multiply_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `T⋅J`(this.siValue * that.siValue) }


typealias `L²⋅M⋅T⁻³` = L2A0M1I0Theta0N0J0_per_T3
inline class L2A0M1I0Theta0N0J0_per_T3(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻³"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻³`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻³`) = `L²⋅M⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻³`) = `L²⋅M⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻³`) = `L²⋅M⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻³` && this.siValue == other.siValue
}

inline val Number.`Watt`: `L²⋅M⋅T⁻³` get() = `L²⋅M⋅T⁻³`(toDouble() * 1.0)
inline val `L²⋅M⋅T⁻³`.`Watt` get() = siValue * 1.0
object `Watt` : UomConverter<`L²⋅M⋅T⁻³`>,
    Quan<`L²⋅M⋅T⁻³`> by box(`L²⋅M⋅T⁻³`(1.0)) {
    override val unitName = "Watt"
    override fun invoke(x: Double) = x.`Watt`
    override fun invoke(x: `L²⋅M⋅T⁻³`) = x.`Watt`
}


typealias `Power` = `L²⋅M⋅T⁻³`

typealias `RadiantFlux` = `L²⋅M⋅T⁻³`

@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅M⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅M⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L`>) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L`) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`M`>) = `L²⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `M`) = `L²⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`M`>) = thiz.run { `L²⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³`.times(that: Quan<`T`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³`.times(that: `T`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`T`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`T⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `T⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A2M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`∠²`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `∠²`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A2M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`∠²`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻²`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅M⋅T⁻²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅M⋅T⁻²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `I`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `I`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅T⁻²`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅T⁻²`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`T⁻¹⋅N`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `T⁻¹⋅N`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²`>) = `M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²`) = `M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²`>) = thiz.run { `M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L³`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L³`) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L³`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L⋅T⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L⋅T⁻¹`) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L³⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L⋅T⁻²`>) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L⋅T⁻²`) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`∠⋅T⁻¹`>) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `∠⋅T⁻¹`) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻¹`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻¹`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅M⋅T⁻¹`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅M⋅T⁻¹`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2M1I0Theta0N0J0_per_A1T2_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = `∠⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2M1I0Theta0N0J0_per_A1T2_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = `∠⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2M1I0Theta0N0J0_per_A1T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = thiz.run { `∠⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻³`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻³`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻³`.times(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻³`.times(that: `L⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `T⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `T⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `T⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`M⋅T⁻²`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `M⋅T⁻²`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`M⋅T⁻³`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `M⋅T⁻³`) = `L²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅T⁻¹`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅T⁻¹`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅T⁻³`>) = `M`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅T⁻³`) = `M`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻³`.times(that: Quan<`L⁻²`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻³`.times(that: `L⁻²`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⁻²`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`M⋅T⁻¹`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `M⋅T⁻¹`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻³`) = `L³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻³`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `Θ`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻³`.times(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `Θ`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `Θ`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻³`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻³`.times(that: `L⋅M⁻¹⋅T²`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`T⁻²`>) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `T⁻²`) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`T⁻²`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻³`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `J`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻³`.times(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `J`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L²⋅M⋅T⁻³`.div(that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = `∠²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L²⋅M⋅T⁻³`.div(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `∠²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T3_Divide_L2M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³`>, that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `∠²`(this.siValue / that.siValue) }


typealias `T⋅I` = L0A0M0T1I1Theta0N0J0
inline class L0A0M0T1I1Theta0N0J0(internal val underlying: Double) : Quan<`T⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "s⋅A"

    override fun new(siValue: Double) = `T⋅I`(siValue)

    override operator fun unaryPlus() = `T⋅I`(+underlying)
    override operator fun unaryMinus() = `T⋅I`(-underlying)

    override operator fun plus(that: `T⋅I`) = `T⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `T⋅I`) = `T⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `T⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `T⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `T⋅I`) = `T⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `T⋅I`) = if (this < that) this else that
    override infix fun max(that: `T⋅I`) = if (this > that) this else that

    override val abs get() = `T⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `T⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `T⋅I` && this.siValue == other.siValue
}

inline val Number.`Coulomb`: `ElectricCharge` get() = `T⋅I`(toDouble() * 1.0)
inline val `T⋅I`.`Coulomb` get() = siValue * 1.0
object `Coulomb` : UomConverter<`T⋅I`>,
    Quan<`T⋅I`> by box(`T⋅I`(1.0)) {
    override val unitName = "Coulomb"
    override fun invoke(x: Double) = x.`Coulomb`
    override fun invoke(x: `T⋅I`) = x.`Coulomb`
}


typealias `ElectricCharge` = `T⋅I`

@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⋅I`.div(that: Quan<`Dimensionless`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⋅I`.div(that: `Dimensionless`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `T⋅I`.div(that: Quan<`T⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `T⋅I`.div(that: `T⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`T⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⋅I`.times(that: Quan<`Dimensionless`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⋅I`.times(that: `Dimensionless`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `T⋅I`.div(that: Quan<`L`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `T⋅I`.div(that: `L`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `T⋅I`.div(that: Quan<`M`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `T⋅I`.div(that: `M`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`M`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `T⋅I`.div(that: Quan<`T`>) = `I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `T⋅I`.div(that: `T`) = `I`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`T`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `T⋅I`.div(that: Quan<`I`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `T⋅I`.div(that: `I`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`I`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⋅I`.times(that: Quan<`T⁻¹`>) = `I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⋅I`.times(that: `T⁻¹`) = `I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`T⁻¹`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `T⋅I`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `T⋅I`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `T⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `T⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `T⋅I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `T⋅I`.div(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `T⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `T⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `T⋅I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `T⋅I`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `T⋅I`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `T⋅I`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `T⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `T⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `T⋅I`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `T⋅I`.times(that: `M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `T⋅I`.div(that: Quan<`L²`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `T⋅I`.div(that: `L²`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L²`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `T⋅I`.div(that: Quan<`L³`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `T⋅I`.div(that: `L³`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L³`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `T⋅I`.times(that: Quan<`∠⋅T⁻¹`>) = `∠⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⋅I`.times(that: `∠⋅T⁻¹`) = `∠⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `∠⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `T⋅I`.times(that: Quan<`L⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `T⋅I`.times(that: `L⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⋅I`.times(that: Quan<`L²⋅T⁻¹`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⋅I`.times(that: `L²⋅T⁻¹`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `T⋅I`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `T⋅I`.div(that: `L⁻²⋅T⋅I`) = `L²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `T⋅I`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `T⋅I`.div(that: `L⁻³⋅T⋅I`) = `L³`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `T⋅I`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `T⋅I`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `T⋅I`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `T⋅I`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `T⋅I`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `M`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `T⋅I`.div(that: `M⁻¹⋅T⋅I`) = `M`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `T⋅I`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `T⋅I`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `T⋅I`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `T⋅I`.div(that: `L⁻¹⋅T⋅I`) = `L`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `T⋅I`.times(that: Quan<`L⁻²`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `T⋅I`.times(that: `L⁻²`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T⋅I`.div(that: Quan<`M⋅T⁻¹`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T⋅I`.div(that: `M⋅T⁻¹`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `T⋅I`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `T⋅I`.div(that: `M⁻¹⋅T²⋅I`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `T⋅I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `T⋅I`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`T⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `T⋅I`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I1Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `T⋅I`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I1Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`T⋅I`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }


typealias `L²⋅M⋅T⁻³⋅I⁻¹` = L2A0M1Theta0N0J0_per_T3I1
inline class L2A0M1Theta0N0J0_per_T3I1(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻³⋅I⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻³⋅A⁻¹"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻³⋅I⁻¹`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻³⋅I⁻¹`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻³⋅I⁻¹`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻³⋅I⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻³⋅I⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻³⋅I⁻¹` && this.siValue == other.siValue
}

inline val Number.`Volt`: `ElectricalPotential` get() = `L²⋅M⋅T⁻³⋅I⁻¹`(toDouble() * 1.0)
inline val `L²⋅M⋅T⁻³⋅I⁻¹`.`Volt` get() = siValue * 1.0
object `Volt` : UomConverter<`L²⋅M⋅T⁻³⋅I⁻¹`>,
    Quan<`L²⋅M⋅T⁻³⋅I⁻¹`> by box(`L²⋅M⋅T⁻³⋅I⁻¹`(1.0)) {
    override val unitName = "Volt"
    override fun invoke(x: Double) = x.`Volt`
    override fun invoke(x: `L²⋅M⋅T⁻³⋅I⁻¹`) = x.`Volt`
}


typealias `ElectricalPotential` = `L²⋅M⋅T⁻³⋅I⁻¹`

@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`T`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `T`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`T`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`I`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `I`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`I`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `I`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`I`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`T⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `T⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`T⋅I`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `T⋅I`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `I`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `I`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `I`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `I`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⋅T⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⋅T⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L²⋅T⁻¹`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L²⋅T⁻¹`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻²⋅T⋅I`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻²⋅T⋅I`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻³⋅T⋅I`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻³⋅T⋅I`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻²⋅I`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻²⋅I`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⁻¹⋅I`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⁻¹⋅I`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻¹⋅I`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻¹⋅I`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `M⁻¹⋅T⋅I`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.times(that: `M⁻¹⋅T²⋅I`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }


typealias `L⁻²⋅M⁻¹⋅T⁴⋅I²` = A0T4I2Theta0N0J0_per_L2M1
inline class A0T4I2Theta0N0J0_per_L2M1(internal val underlying: Double) : Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅kg⁻¹⋅s⁴⋅A²"

    override fun new(siValue: Double) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(-underlying)

    override operator fun plus(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅M⁻¹⋅T⁴⋅I²` && this.siValue == other.siValue
}

inline val Number.`Farad`: `ElectricalCapacitance` get() = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(toDouble() * 1.0)
inline val `L⁻²⋅M⁻¹⋅T⁴⋅I²`.`Farad` get() = siValue * 1.0
object `Farad` : UomConverter<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>,
    Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`> by box(`L⁻²⋅M⁻¹⋅T⁴⋅I²`(1.0)) {
    override val unitName = "Farad"
    override fun invoke(x: Double) = x.`Farad`
    override fun invoke(x: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = x.`Farad`
}


typealias `ElectricalCapacitance` = `L⁻²⋅M⁻¹⋅T⁴⋅I²`

@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`L`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: `L`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`T`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: `T`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`T`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`T⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: `T⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `T`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `T`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `T`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `T`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L⋅T⁻²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: `L⋅T⁻²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L⁻¹`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: `L⁻¹`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`T⁻²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T⁴⋅I²`.times(that: `T⁻²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L2M1_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`T⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }


typealias `L²⋅M⋅T⁻³⋅I⁻²` = L2A0M1Theta0N0J0_per_T3I2
inline class L2A0M1Theta0N0J0_per_T3I2(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻³⋅I⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻³⋅A⁻²"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻³⋅I⁻²`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻³⋅I⁻²`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻³⋅I⁻²`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻³⋅I⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻³⋅I⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻³⋅I⁻²`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻³⋅I⁻²`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻³⋅I⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻³⋅I⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻³⋅I⁻²` && this.siValue == other.siValue
}

inline val Number.`Ohm`: `L²⋅M⋅T⁻³⋅I⁻²` get() = `L²⋅M⋅T⁻³⋅I⁻²`(toDouble() * 1.0)
inline val `L²⋅M⋅T⁻³⋅I⁻²`.`Ohm` get() = siValue * 1.0
object `Ohm` : UomConverter<`L²⋅M⋅T⁻³⋅I⁻²`>,
    Quan<`L²⋅M⋅T⁻³⋅I⁻²`> by box(`L²⋅M⋅T⁻³⋅I⁻²`(1.0)) {
    override val unitName = "Ohm"
    override fun invoke(x: Double) = x.`Ohm`
    override fun invoke(x: `L²⋅M⋅T⁻³⋅I⁻²`) = x.`Ohm`
}


typealias `ElectricalResistance` = `L²⋅M⋅T⁻³⋅I⁻²`

typealias `Impedance` = `L²⋅M⋅T⁻³⋅I⁻²`

typealias `Reactance` = `L²⋅M⋅T⁻³⋅I⁻²`

@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `L`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`T`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `T`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`T`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`T⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: `T⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`T⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `T⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`T⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `T`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `T`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L⋅T⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: `L⋅T⁻¹`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L⁻¹`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: `L⁻¹`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻²⋅T⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻²⋅T⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻¹⋅I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻¹⋅I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻¹⋅T⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L²⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }


typealias `L⁻²⋅M⁻¹⋅T³⋅I²` = A0T3I2Theta0N0J0_per_L2M1
inline class A0T3I2Theta0N0J0_per_L2M1(internal val underlying: Double) : Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅kg⁻¹⋅s³⋅A²"

    override fun new(siValue: Double) = `L⁻²⋅M⁻¹⋅T³⋅I²`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅M⁻¹⋅T³⋅I²`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅M⁻¹⋅T³⋅I²`(-underlying)

    override operator fun plus(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅M⁻¹⋅T³⋅I²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅M⁻¹⋅T³⋅I²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅M⁻¹⋅T³⋅I²` && this.siValue == other.siValue
}

inline val Number.`Siemens`: `ElectricalConductance` get() = `L⁻²⋅M⁻¹⋅T³⋅I²`(toDouble() * 1.0)
inline val `L⁻²⋅M⁻¹⋅T³⋅I²`.`Siemens` get() = siValue * 1.0
object `Siemens` : UomConverter<`L⁻²⋅M⁻¹⋅T³⋅I²`>,
    Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`> by box(`L⁻²⋅M⁻¹⋅T³⋅I²`(1.0)) {
    override val unitName = "Siemens"
    override fun invoke(x: Double) = x.`Siemens`
    override fun invoke(x: `L⁻²⋅M⁻¹⋅T³⋅I²`) = x.`Siemens`
}


typealias `ElectricalConductance` = `L⁻²⋅M⁻¹⋅T³⋅I²`

@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `L`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`T`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `T`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`T`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`T`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `T`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`T`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`T⁻¹`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `T⁻¹`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`T⁻¹`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `T⁻¹`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `T`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `T`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `L⋅T⁻¹`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L⋅T⁻¹`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `L⋅T⁻¹`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `L⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻²⋅T⋅I`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻²⋅T⋅I`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `M⁻¹⋅T²⋅I`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `T`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `T`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅I²`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }


typealias `L²⋅M⋅T⁻²⋅I⁻¹` = L2A0M1Theta0N0J0_per_T2I1
inline class L2A0M1Theta0N0J0_per_T2I1(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻²⋅I⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻²⋅A⁻¹"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻²⋅I⁻¹`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻²⋅I⁻¹`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻²⋅I⁻¹`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻²⋅I⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻²⋅I⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻²⋅I⁻¹` && this.siValue == other.siValue
}

inline val Number.`Weber`: `MagneticFlux` get() = `L²⋅M⋅T⁻²⋅I⁻¹`(toDouble() * 1.0)
inline val `L²⋅M⋅T⁻²⋅I⁻¹`.`Weber` get() = siValue * 1.0
object `Weber` : UomConverter<`L²⋅M⋅T⁻²⋅I⁻¹`>,
    Quan<`L²⋅M⋅T⁻²⋅I⁻¹`> by box(`L²⋅M⋅T⁻²⋅I⁻¹`(1.0)) {
    override val unitName = "Weber"
    override fun invoke(x: Double) = x.`Weber`
    override fun invoke(x: `L²⋅M⋅T⁻²⋅I⁻¹`) = x.`Weber`
}


typealias `MagneticFlux` = `L²⋅M⋅T⁻²⋅I⁻¹`

@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`T`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `T`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`T`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`I`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `I`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`I`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `I`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`I`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`T⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `T⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`T⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `T⋅I`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`T⋅I`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `T⋅I`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `I`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `I`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻¹`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⁻¹`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅T⋅I`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅T⋅I`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻³⋅T⋅I`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻³⋅T⋅I`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅I`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅I`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅I`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅I`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `M⁻¹⋅T⋅I`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⁻¹⋅T⋅I`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `M⁻¹⋅T²⋅I`) = `L²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `I`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `I`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻¹`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }


typealias `M⋅T⁻²⋅I⁻¹` = L0A0M1Theta0N0J0_per_T2I1
inline class L0A0M1Theta0N0J0_per_T2I1(internal val underlying: Double) : Quan<`M⋅T⁻²⋅I⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "kg⋅s⁻²⋅A⁻¹"

    override fun new(siValue: Double) = `M⋅T⁻²⋅I⁻¹`(siValue)

    override operator fun unaryPlus() = `M⋅T⁻²⋅I⁻¹`(+underlying)
    override operator fun unaryMinus() = `M⋅T⁻²⋅I⁻¹`(-underlying)

    override operator fun plus(that: `M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻²⋅I⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻²⋅I⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M⋅T⁻²⋅I⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M⋅T⁻²⋅I⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻²⋅I⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `M⋅T⁻²⋅I⁻¹`) = if (this < that) this else that
    override infix fun max(that: `M⋅T⁻²⋅I⁻¹`) = if (this > that) this else that

    override val abs get() = `M⋅T⁻²⋅I⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M⋅T⁻²⋅I⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M⋅T⁻²⋅I⁻¹` && this.siValue == other.siValue
}

inline val Number.`Tesla`: `M⋅T⁻²⋅I⁻¹` get() = `M⋅T⁻²⋅I⁻¹`(toDouble() * 1.0)
inline val `M⋅T⁻²⋅I⁻¹`.`Tesla` get() = siValue * 1.0
object `Tesla` : UomConverter<`M⋅T⁻²⋅I⁻¹`>,
    Quan<`M⋅T⁻²⋅I⁻¹`> by box(`M⋅T⁻²⋅I⁻¹`(1.0)) {
    override val unitName = "Tesla"
    override fun invoke(x: Double) = x.`Tesla`
    override fun invoke(x: `M⋅T⁻²⋅I⁻¹`) = x.`Tesla`
}


typealias `MagneticFieldStrength` = `M⋅T⁻²⋅I⁻¹`

typealias `MagneticFluxDensity` = `M⋅T⁻²⋅I⁻¹`

@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`Dimensionless`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `Dimensionless`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `M⋅T⁻²⋅I⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`Dimensionless`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `Dimensionless`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`I`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `I`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`I`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`T⋅I`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `T⋅I`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L²`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L²`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L³`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L³`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L³`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⋅T⁻¹`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L⋅T⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L²⋅T⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L²⋅T⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L⁻²⋅T⋅I`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L⁻³⋅T⋅I`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻²⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L⁻²⋅I`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻¹⋅I`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L⁻¹⋅I`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅I`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅I`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `M⁻¹⋅T⋅I`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻²`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L⁻²`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0T0I1Theta0N0J0_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L²⋅I`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0T0I1Theta0N0J0_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L²⋅I`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅I`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `M⁻¹⋅T²⋅I`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }


typealias `M⁻¹⋅T²⋅I` = L0A0T2I1Theta0N0J0_per_M1
inline class L0A0T2I1Theta0N0J0_per_M1(internal val underlying: Double) : Quan<`M⁻¹⋅T²⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "kg⁻¹⋅s²⋅A"

    override fun new(siValue: Double) = `M⁻¹⋅T²⋅I`(siValue)

    override operator fun unaryPlus() = `M⁻¹⋅T²⋅I`(+underlying)
    override operator fun unaryMinus() = `M⁻¹⋅T²⋅I`(-underlying)

    override operator fun plus(that: `M⁻¹⋅T²⋅I`) = `M⁻¹⋅T²⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `M⁻¹⋅T²⋅I`) = `M⁻¹⋅T²⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M⁻¹⋅T²⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M⁻¹⋅T²⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `M⁻¹⋅T²⋅I`) = `M⁻¹⋅T²⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `M⁻¹⋅T²⋅I`) = if (this < that) this else that
    override infix fun max(that: `M⁻¹⋅T²⋅I`) = if (this > that) this else that

    override val abs get() = `M⁻¹⋅T²⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M⁻¹⋅T²⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M⁻¹⋅T²⋅I` && this.siValue == other.siValue
}


typealias `ElectronMobility` = `M⁻¹⋅T²⋅I`

@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅T²⋅I`.div(that: Quan<`Dimensionless`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅T²⋅I`.div(that: `Dimensionless`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `M⁻¹⋅T²⋅I`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `M⁻¹⋅T²⋅I`.div(that: `M⁻¹⋅T²⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`Dimensionless`>) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `Dimensionless`) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `M⁻¹⋅T²⋅I`.div(that: Quan<`T`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅T²⋅I`.div(that: `T`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`T`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`T⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `T⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`T⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L²⋅M⋅T⁻²`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L²⋅M⋅T⁻²`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L²`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `M⋅T⁻²⋅I⁻¹`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`M⋅T⁻²`>) = `I`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `M⋅T⁻²`) = `I`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L⁻²⋅T⋅I`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L⁻³⋅T⋅I`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L⁻³⋅T⋅I`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L⁻²⋅I`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L⁻²⋅I`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `M⁻¹⋅T²⋅I`.div(that: Quan<`L⁻¹⋅I`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `M⁻¹⋅T²⋅I`.div(that: `L⁻¹⋅I`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L⁻¹⋅I`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L⁻¹⋅I`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `M⁻¹⋅T²⋅I`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `M⁻¹⋅T²⋅I`.div(that: `M⁻¹⋅T⋅I`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`M⋅T⁻¹`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `M⋅T⁻¹`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `M⁻¹⋅T²⋅I`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `M⁻¹⋅T²⋅I`.div(that: `L⋅M⁻¹⋅T²`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⁻¹⋅T²⋅I`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⁻¹⋅T²⋅I`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L³`(this.siValue * that.siValue)
@JvmName("L0A0T2I1Theta0N0J0_per_M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T²⋅I`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L³`(this.siValue * that.siValue) }


typealias `L²⋅M⋅T⁻²⋅I⁻²` = L2A0M1Theta0N0J0_per_T2I2
inline class L2A0M1Theta0N0J0_per_T2I2(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻²⋅I⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻²⋅A⁻²"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻²⋅I⁻²`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻²⋅I⁻²`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻²⋅I⁻²`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻²⋅I⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻²⋅I⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻²⋅I⁻²`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻²⋅I⁻²`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻²⋅I⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻²⋅I⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻²⋅I⁻²` && this.siValue == other.siValue
}

inline val Number.`Henry`: `ElectricalInductance` get() = `L²⋅M⋅T⁻²⋅I⁻²`(toDouble() * 1.0)
inline val `L²⋅M⋅T⁻²⋅I⁻²`.`Henry` get() = siValue * 1.0
object `Henry` : UomConverter<`L²⋅M⋅T⁻²⋅I⁻²`>,
    Quan<`L²⋅M⋅T⁻²⋅I⁻²`> by box(`L²⋅M⋅T⁻²⋅I⁻²`(1.0)) {
    override val unitName = "Henry"
    override fun invoke(x: Double) = x.`Henry`
    override fun invoke(x: `L²⋅M⋅T⁻²⋅I⁻²`) = x.`Henry`
}


typealias `ElectricalInductance` = `L²⋅M⋅T⁻²⋅I⁻²`

@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`L`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: `L`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`T`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: `T`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`T`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`T⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `T⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `T`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `T`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `T`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `T`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⋅T⁻¹`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `L⋅T⁻¹`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `L⁻¹`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⁻²⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `L⁻²⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.div(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Divide_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⁻¹⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `L⁻¹⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L`(this.siValue * that.siValue)
// @JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅I⁻²`.times(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L`(this.siValue * that.siValue)
@JvmName("L2A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L`(this.siValue * that.siValue) }


typealias `L⁻²⋅M⁻¹⋅T²⋅I²` = A0T2I2Theta0N0J0_per_L2M1
inline class A0T2I2Theta0N0J0_per_L2M1(internal val underlying: Double) : Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅kg⁻¹⋅s²⋅A²"

    override fun new(siValue: Double) = `L⁻²⋅M⁻¹⋅T²⋅I²`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅M⁻¹⋅T²⋅I²`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅M⁻¹⋅T²⋅I²`(-underlying)

    override operator fun plus(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅M⁻¹⋅T²⋅I²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅M⁻¹⋅T²⋅I²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅M⁻¹⋅T²⋅I²` && this.siValue == other.siValue
}


typealias `MagneticReluctance` = `L⁻²⋅M⁻¹⋅T²⋅I²`

@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `L`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`T`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `T`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`T`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`T⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `T⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `I`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `I`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⋅T⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⋅T⁻²`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⋅T⁻²`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻¹`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻¹`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻²⋅T⋅I`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻²⋅T⋅I`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻²⋅I`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻²⋅I`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `M⁻¹⋅T⋅I`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `M⁻¹⋅T²⋅I`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`T⁻²`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `T⁻²`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`T⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L2M1_Divide_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }


typealias `∠²⋅J` = L0A2M0T0I0Theta0N0J1
inline class L0A2M0T0I0Theta0N0J1(internal val underlying: Double) : Quan<`∠²⋅J`> {
    override val siValue get() = underlying
    override val abrev get() = "rad²⋅cd"

    override fun new(siValue: Double) = `∠²⋅J`(siValue)

    override operator fun unaryPlus() = `∠²⋅J`(+underlying)
    override operator fun unaryMinus() = `∠²⋅J`(-underlying)

    override operator fun plus(that: `∠²⋅J`) = `∠²⋅J`(this.underlying + that.underlying)
    override operator fun minus(that: `∠²⋅J`) = `∠²⋅J`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `∠²⋅J`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `∠²⋅J`(this.underlying / that.toDouble())
    override operator fun rem(that: `∠²⋅J`) = `∠²⋅J`(this.underlying % that.underlying)

    override infix fun min(that: `∠²⋅J`) = if (this < that) this else that
    override infix fun max(that: `∠²⋅J`) = if (this > that) this else that

    override val abs get() = `∠²⋅J`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `∠²⋅J`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `∠²⋅J` && this.siValue == other.siValue
}

inline val Number.`Lumen`: `LuminousFlux` get() = `∠²⋅J`(toDouble() * 1.0)
inline val `∠²⋅J`.`Lumen` get() = siValue * 1.0
object `Lumen` : UomConverter<`∠²⋅J`>,
    Quan<`∠²⋅J`> by box(`∠²⋅J`(1.0)) {
    override val unitName = "Lumen"
    override fun invoke(x: Double) = x.`Lumen`
    override fun invoke(x: `∠²⋅J`) = x.`Lumen`
}


typealias `LuminousFlux` = `∠²⋅J`

@JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠²⋅J`.div(that: Quan<`Dimensionless`>) = `∠²⋅J`(this.siValue / that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠²⋅J`.div(that: `Dimensionless`) = `∠²⋅J`(this.siValue / that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠²⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `∠²⋅J`(this.siValue / that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A2M0T0I0Theta0N0J1_generic")
operator fun `∠²⋅J`.div(that: Quan<`∠²⋅J`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A2M0T0I0Theta0N0J1_concrete")
operator fun `∠²⋅J`.div(that: `∠²⋅J`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A2M0T0I0Theta0N0J1_nonextension")
fun div(thiz: Quan<`∠²⋅J`>, that: Quan<`∠²⋅J`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠²⋅J`.times(that: Quan<`Dimensionless`>) = `∠²⋅J`(this.siValue * that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠²⋅J`.times(that: `Dimensionless`) = `∠²⋅J`(this.siValue * that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠²⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `∠²⋅J`(this.siValue * that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J1_generic")
operator fun `∠²⋅J`.div(that: Quan<`J`>) = `∠²`(this.siValue / that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J1_concrete")
operator fun `∠²⋅J`.div(that: `J`) = `∠²`(this.siValue / that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J1_nonextension")
fun div(thiz: Quan<`∠²⋅J`>, that: Quan<`J`>) = thiz.run { `∠²`(this.siValue / that.siValue) }
@JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A2M0T0I0Theta0N0J0_generic")
operator fun `∠²⋅J`.div(that: Quan<`∠²`>) = `J`(this.siValue / that.siValue)
// @JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `∠²⋅J`.div(that: `∠²`) = `J`(this.siValue / that.siValue)
@JvmName("L0A2M0T0I0Theta0N0J1_Divide_L0A2M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠²⋅J`>, that: Quan<`∠²`>) = thiz.run { `J`(this.siValue / that.siValue) }


typealias `L⁻²⋅J` = A0M0T0I0Theta0N0J1_per_L2
inline class A0M0T0I0Theta0N0J1_per_L2(internal val underlying: Double) : Quan<`L⁻²⋅J`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅cd"

    override fun new(siValue: Double) = `L⁻²⋅J`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅J`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅J`(-underlying)

    override operator fun plus(that: `L⁻²⋅J`) = `L⁻²⋅J`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅J`) = `L⁻²⋅J`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅J`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅J`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅J`) = `L⁻²⋅J`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅J`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅J`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅J`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅J`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅J` && this.siValue == other.siValue
}

inline val Number.`Lux`: `L⁻²⋅J` get() = `L⁻²⋅J`(toDouble() * 1.0)
inline val `L⁻²⋅J`.`Lux` get() = siValue * 1.0
object `Lux` : UomConverter<`L⁻²⋅J`>,
    Quan<`L⁻²⋅J`> by box(`L⁻²⋅J`(1.0)) {
    override val unitName = "Lux"
    override fun invoke(x: Double) = x.`Lux`
    override fun invoke(x: `L⁻²⋅J`) = x.`Lux`
}


typealias `Illuminance` = `L⁻²⋅J`

typealias `Luminance` = `L⁻²⋅J`

@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅J`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅J`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅J`.div(that: `Dimensionless`) = `L⁻²⋅J`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅J`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J1_per_L2_generic")
operator fun `L⁻²⋅J`.div(that: Quan<`L⁻²⋅J`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J1_per_L2_concrete")
operator fun `L⁻²⋅J`.div(that: `L⁻²⋅J`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J1_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅J`>, that: Quan<`L⁻²⋅J`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅J`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅J`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅J`.times(that: `Dimensionless`) = `L⁻²⋅J`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅J`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻²⋅J`.times(that: Quan<`T`>) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻²⋅J`.times(that: `T`) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅J`>, that: Quan<`T`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M0T0I0Theta0N0J1_generic")
operator fun `L⁻²⋅J`.div(that: Quan<`J`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M0T0I0Theta0N0J1_concrete")
operator fun `L⁻²⋅J`.div(that: `J`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M0T0I0Theta0N0J1_nonextension")
fun div(thiz: Quan<`L⁻²⋅J`>, that: Quan<`J`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅J`.div(that: Quan<`T⁻¹`>) = `L⁻²⋅T⋅J`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅J`.div(that: `T⁻¹`) = `L⁻²⋅T⋅J`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻²⋅J`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅J`.times(that: Quan<`L²`>) = `J`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅J`.times(that: `L²`) = `J`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅J`>, that: Quan<`L²`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻²⋅J`.div(that: Quan<`M⋅T⁻³`>) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻²⋅J`.div(that: `M⋅T⁻³`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⁻²⋅J`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0M0T1I0Theta0N0J1_per_L2_generic")
operator fun `L⁻²⋅J`.div(that: Quan<`L⁻²⋅T⋅J`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0M0T1I0Theta0N0J1_per_L2_concrete")
operator fun `L⁻²⋅J`.div(that: `L⁻²⋅T⋅J`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0M0T1I0Theta0N0J1_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅J`>, that: Quan<`L⁻²⋅T⋅J`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅J`.div(that: Quan<`L⁻²`>) = `J`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅J`.div(that: `L⁻²`) = `J`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅J`>, that: Quan<`L⁻²`>) = thiz.run { `J`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `L⁻²⋅J`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `L⁻²⋅J`.div(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J1_per_L2_Divide_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅J`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `M⋅T⁻³`(this.siValue / that.siValue) }


typealias `L²⋅T⁻²` = L2A0M0I0Theta0N0J0_per_T2
inline class L2A0M0I0Theta0N0J0_per_T2(internal val underlying: Double) : Quan<`L²⋅T⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅s⁻²"

    override fun new(siValue: Double) = `L²⋅T⁻²`(siValue)

    override operator fun unaryPlus() = `L²⋅T⁻²`(+underlying)
    override operator fun unaryMinus() = `L²⋅T⁻²`(-underlying)

    override operator fun plus(that: `L²⋅T⁻²`) = `L²⋅T⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅T⁻²`) = `L²⋅T⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅T⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅T⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅T⁻²`) = `L²⋅T⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅T⁻²`) = if (this < that) this else that
    override infix fun max(that: `L²⋅T⁻²`) = if (this > that) this else that

    override val abs get() = `L²⋅T⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅T⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅T⁻²` && this.siValue == other.siValue
}

inline val Number.`Gray`: `L²⋅T⁻²` get() = `L²⋅T⁻²`(toDouble() * 1.0)
inline val `L²⋅T⁻²`.`Gray` get() = siValue * 1.0
object `Gray` : UomConverter<`L²⋅T⁻²`>,
    Quan<`L²⋅T⁻²`> by box(`L²⋅T⁻²`(1.0)) {
    override val unitName = "Gray"
    override fun invoke(x: Double) = x.`Gray`
    override fun invoke(x: `L²⋅T⁻²`) = x.`Gray`
}

inline val Number.`Sievert`: `L²⋅T⁻²` get() = `L²⋅T⁻²`(toDouble() * 1.0)
inline val `L²⋅T⁻²`.`Sievert` get() = siValue * 1.0
object `Sievert` : UomConverter<`L²⋅T⁻²`>,
    Quan<`L²⋅T⁻²`> by box(`L²⋅T⁻²`(1.0)) {
    override val unitName = "Sievert"
    override fun invoke(x: Double) = x.`Sievert`
    override fun invoke(x: `L²⋅T⁻²`) = x.`Sievert`
}


typealias `AbsorbedDose` = `L²⋅T⁻²`

typealias `EquivalentDose` = `L²⋅T⁻²`

typealias `SpecificEnergy` = `L²⋅T⁻²`

@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`Dimensionless`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²`.div(that: `Dimensionless`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L²⋅T⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻²`.div(that: `L²⋅T⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`Dimensionless`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²`.times(that: `Dimensionless`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²`.div(that: `L`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`M`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²`.times(that: `M`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`M`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`T`>) = `L²⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²`.div(that: `T`) = `L²⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L²⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`T`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²`.times(that: `T`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`Θ`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L²⋅T⁻²`.div(that: `Θ`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta1N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`Θ`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`T⁻¹`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻²`.div(that: `T⁻¹`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`T⁻¹`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻²`.times(that: `T⁻¹`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L²⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻²`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L²⋅T⁻²`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L²`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²`.div(that: `L²`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L²`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L⋅T⁻¹`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻²`.div(that: `L⋅T⁻¹`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L⋅T⁻²`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻²`.div(that: `L⋅T⁻²`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`L⁻¹`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅T⁻²`.times(that: `L⁻¹`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`L⁻²⋅M`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅T⁻²`.times(that: `L⁻²⋅M`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`L⁻³⋅M`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L²⋅T⁻²`.times(that: `L⁻³⋅M`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L³⋅M⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L²⋅T⁻²`.div(that: `L³⋅M⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `Θ`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `L²⋅T⁻²`.div(that: `L²⋅T⁻²⋅Θ⁻¹`) = `Θ`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `Θ`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `M⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `L²⋅T⁻²`.div(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `M⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `M⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L²⋅T⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻²`.div(that: `L²⋅T⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L²⋅T⁻²`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L²⋅T⁻²`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅T⁻²`.div(that: `M⁻¹⋅T⋅I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`L²⋅T⁻³`>) = `T`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L²⋅T⁻²`.div(that: `L²⋅T⁻³`) = `T`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`L⁻¹⋅M`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅T⁻²`.times(that: `L⁻¹⋅M`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`M⁻¹⋅N`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `L²⋅T⁻²`.div(that: `M⁻¹⋅N`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`M⋅N⁻¹`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `L²⋅T⁻²`.times(that: `M⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`L⁻²`>) = `T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅T⁻²`.times(that: `L⁻²`) = `T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⁻²`>) = thiz.run { `T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`M⋅T⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻²`.times(that: `M⋅T⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`Θ⁻¹`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L²⋅T⁻²`.times(that: `Θ⁻¹`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L²⋅T⁻²`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `L³⋅M⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L²⋅T⁻²`.times(that: `L⋅M⁻¹⋅T²`) = `L³⋅M⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L³⋅M⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻²`.div(that: Quan<`T⁻²`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻²`.div(that: `T⁻²`) = `L²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²`>, that: Quan<`T⁻²`>) = thiz.run { `L²`(this.siValue / that.siValue) }


typealias `T⁻¹⋅N` = L0A0M0I0Theta0N1J0_per_T1
inline class L0A0M0I0Theta0N1J0_per_T1(internal val underlying: Double) : Quan<`T⁻¹⋅N`> {
    override val siValue get() = underlying
    override val abrev get() = "s⁻¹⋅mol"

    override fun new(siValue: Double) = `T⁻¹⋅N`(siValue)

    override operator fun unaryPlus() = `T⁻¹⋅N`(+underlying)
    override operator fun unaryMinus() = `T⁻¹⋅N`(-underlying)

    override operator fun plus(that: `T⁻¹⋅N`) = `T⁻¹⋅N`(this.underlying + that.underlying)
    override operator fun minus(that: `T⁻¹⋅N`) = `T⁻¹⋅N`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `T⁻¹⋅N`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `T⁻¹⋅N`(this.underlying / that.toDouble())
    override operator fun rem(that: `T⁻¹⋅N`) = `T⁻¹⋅N`(this.underlying % that.underlying)

    override infix fun min(that: `T⁻¹⋅N`) = if (this < that) this else that
    override infix fun max(that: `T⁻¹⋅N`) = if (this > that) this else that

    override val abs get() = `T⁻¹⋅N`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `T⁻¹⋅N`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `T⁻¹⋅N` && this.siValue == other.siValue
}

inline val Number.`Katal`: `CatalyticActivity` get() = `T⁻¹⋅N`(toDouble() * 1.0)
inline val `T⁻¹⋅N`.`Katal` get() = siValue * 1.0
object `Katal` : UomConverter<`T⁻¹⋅N`>,
    Quan<`T⁻¹⋅N`> by box(`T⁻¹⋅N`(1.0)) {
    override val unitName = "Katal"
    override fun invoke(x: Double) = x.`Katal`
    override fun invoke(x: `T⁻¹⋅N`) = x.`Katal`
}


typealias `CatalyticActivity` = `T⁻¹⋅N`

@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻¹⋅N`.div(that: Quan<`Dimensionless`>) = `T⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻¹⋅N`.div(that: `Dimensionless`) = `T⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`Dimensionless`>) = thiz.run { `T⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `T⁻¹⋅N`.div(that: Quan<`T⁻¹⋅N`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `T⁻¹⋅N`.div(that: `T⁻¹⋅N`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun div(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⁻¹⋅N`.times(that: Quan<`Dimensionless`>) = `T⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⁻¹⋅N`.times(that: `Dimensionless`) = `T⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`Dimensionless`>) = thiz.run { `T⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `T⁻¹⋅N`.times(that: Quan<`T`>) = `N`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `T⁻¹⋅N`.times(that: `T`) = `N`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`T`>) = thiz.run { `N`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0T0I0Theta0N1J0_generic")
operator fun `T⁻¹⋅N`.div(that: Quan<`N`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `T⁻¹⋅N`.div(that: `N`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0T0I0Theta0N1J0_nonextension")
fun div(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`N`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹⋅N`.div(that: Quan<`T⁻¹`>) = `N`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹⋅N`.div(that: `T⁻¹`) = `N`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`T⁻¹`>) = thiz.run { `N`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹⋅N`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻³⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹⋅N`.div(that: `L³⋅T⁻¹`) = `L⁻³⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻³⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `T⁻¹⋅N`.div(that: Quan<`L⁻³⋅N`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `T⁻¹⋅N`.div(that: `L⁻³⋅N`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun div(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `T⁻¹⋅N`.times(that: Quan<`L³⋅N⁻¹`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `T⁻¹⋅N`.times(that: `L³⋅N⁻¹`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `T⁻¹⋅N`.times(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `T⁻¹⋅N`.times(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun times(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `T⁻¹⋅N`.div(that: Quan<`M⁻¹⋅N`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `T⁻¹⋅N`.div(that: `M⁻¹⋅N`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun div(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `T⁻¹⋅N`.times(that: Quan<`M⋅N⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `T⁻¹⋅N`.times(that: `M⋅N⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Multiply_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `T⁻¹⋅N`.div(that: Quan<`M⋅T⁻¹`>) = `M⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `T⁻¹⋅N`.div(that: `M⋅T⁻¹`) = `M⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M0I0Theta0N1J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`T⁻¹⋅N`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `M⁻¹⋅N`(this.siValue / that.siValue) }


typealias `L⁻²` = A0M0T0I0Theta0N0J0_per_L2
inline class A0M0T0I0Theta0N0J0_per_L2(internal val underlying: Double) : Quan<`L⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²"

    override fun new(siValue: Double) = `L⁻²`(siValue)

    override operator fun unaryPlus() = `L⁻²`(+underlying)
    override operator fun unaryMinus() = `L⁻²`(-underlying)

    override operator fun plus(that: `L⁻²`) = `L⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²`) = `L⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²`) = `L⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²`) = if (this < that) this else that
    override infix fun max(that: `L⁻²`) = if (this > that) this else that

    override val abs get() = `L⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²` && this.siValue == other.siValue
}


typealias `FuelEfficiency` = `L⁻²`

@JvmName("A0M0T0I0Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²`.div(that: Quan<`Dimensionless`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²`.div(that: `Dimensionless`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻²`.div(that: Quan<`L⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻²`.div(that: `L⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²`>, that: Quan<`L⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²`.times(that: Quan<`Dimensionless`>) = `L⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²`.times(that: `Dimensionless`) = `L⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²`.times(that: Quan<`L`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²`.times(that: `L`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⁻²`.times(that: Quan<`M`>) = `L⁻²⋅M`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⁻²`.times(that: `M`) = `L⁻²⋅M`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`M`>) = thiz.run { `L⁻²⋅M`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⁻²`.times(that: Quan<`I`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⁻²`.times(that: `I`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`I`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J1_generic")
operator fun `L⁻²`.times(that: Quan<`J`>) = `L⁻²⋅J`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J1_concrete")
operator fun `L⁻²`.times(that: `J`) = `L⁻²⋅J`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`J`>) = thiz.run { `L⁻²⋅J`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²`.times(that: Quan<`L⋅M⋅T⁻²`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²`.times(that: `L⋅M⋅T⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²`.times(that: Quan<`L²⋅M⋅T⁻²`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²`.times(that: `L²⋅M⋅T⁻²`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻²`.times(that: Quan<`L²⋅M⋅T⁻³`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻²`.times(that: `L²⋅M⋅T⁻³`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L⁻²`.times(that: Quan<`T⋅I`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L⁻²`.times(that: `T⋅I`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`T⋅I`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²`.times(that: Quan<`L²⋅T⁻²`>) = `T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²`.times(that: `L²⋅T⁻²`) = `T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²`.times(that: Quan<`L²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²`.times(that: `L²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²`.times(that: Quan<`L³`>) = `L`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²`.times(that: `L³`) = `L`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L³`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²`.times(that: Quan<`L³⋅T⁻¹`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²`.times(that: `L³⋅T⁻¹`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²`.times(that: Quan<`L⋅M⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²`.times(that: `L⋅M⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²`.times(that: Quan<`L²⋅M⋅T⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²`.times(that: `L²⋅M⋅T⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻²`.times(that: Quan<`L⋅M⋅T⁻³`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻²`.times(that: `L⋅M⋅T⁻³`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²`.div(that: Quan<`L⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²`.div(that: `L⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²`.times(that: Quan<`L²⋅T⁻¹`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²`.times(that: `L²⋅T⁻¹`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T1I0Theta0N0J1_generic")
operator fun `L⁻²`.times(that: Quan<`T⋅J`>) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T1I0Theta0N0J1_concrete")
operator fun `L⁻²`.times(that: `T⋅J`) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T1I0Theta0N0J1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`T⋅J`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²`.times(that: Quan<`L⁻¹⋅M`>) = `L⁻³⋅M`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²`.times(that: `L⁻¹⋅M`) = `L⁻³⋅M`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⁻³⋅M`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⁻²`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻²`.times(that: `L⁻¹⋅T⋅I`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0T0I1Theta0N0J0_generic")
operator fun `L⁻²`.times(that: Quan<`L²⋅I`>) = `I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0T0I1Theta0N0J0_concrete")
operator fun `L⁻²`.times(that: `L²⋅I`) = `I`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²⋅I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1T0I0Theta0N0J0_generic")
operator fun `L⁻²`.times(that: Quan<`L²⋅M`>) = `M`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1T0I0Theta0N0J0_concrete")
operator fun `L⁻²`.times(that: `L²⋅M`) = `M`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²⋅M`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⁻²`.times(that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⁻²`.times(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L2M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⁻²`.times(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⁻²`.times(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N0J0_per_L2_Multiply_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun times(thiz: Quan<`L⁻²`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L³` = L3A0M0T0I0Theta0N0J0
inline class L3A0M0T0I0Theta0N0J0(internal val underlying: Double) : Quan<`L³`> {
    override val siValue get() = underlying
    override val abrev get() = "m³"

    override fun new(siValue: Double) = `L³`(siValue)

    override operator fun unaryPlus() = `L³`(+underlying)
    override operator fun unaryMinus() = `L³`(-underlying)

    override operator fun plus(that: `L³`) = `L³`(this.underlying + that.underlying)
    override operator fun minus(that: `L³`) = `L³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L³`(this.underlying / that.toDouble())
    override operator fun rem(that: `L³`) = `L³`(this.underlying % that.underlying)

    override infix fun min(that: `L³`) = if (this < that) this else that
    override infix fun max(that: `L³`) = if (this > that) this else that

    override val abs get() = `L³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L³` && this.siValue == other.siValue
}


typealias `Volume` = `L³`

@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³`.div(that: Quan<`Dimensionless`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³`.div(that: `Dimensionless`) = `L³`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`Dimensionless`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L³`.div(that: Quan<`L³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L³`.div(that: `L³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`L³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³`.times(that: Quan<`Dimensionless`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³`.times(that: `Dimensionless`) = `L³`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`Dimensionless`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L³`.div(that: Quan<`L`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L³`.div(that: `L`) = `L²`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`L`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L³`.div(that: Quan<`M`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L³`.div(that: `M`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`M`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L³`.div(that: Quan<`T`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L³`.div(that: `T`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`T`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N1J0_generic")
operator fun `L³`.div(that: Quan<`N`>) = `L³⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `L³`.div(that: `N`) = `L³⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N1J0_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`N`>) = thiz.run { `L³⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³`.times(that: Quan<`T⁻¹`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³`.times(that: `T⁻¹`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`T⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L³`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L³`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L³`.div(that: Quan<`L²⋅M⋅T⁻²`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L³`.div(that: `L²⋅M⋅T⁻²`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L³`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L³`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L³`.div(that: Quan<`L²`>) = `L`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L³`.div(that: `L²`) = `L`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`L²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³`.div(that: Quan<`L³⋅T⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³`.div(that: `L³⋅T⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L³`.times(that: Quan<`L⁻¹`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L³`.times(that: `L⁻¹`) = `L²`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻¹`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L³`.times(that: Quan<`L⁻³⋅M`>) = `M`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L³`.times(that: `L⁻³⋅M`) = `M`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L³`.div(that: Quan<`L³⋅M⁻¹`>) = `M`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L³`.div(that: `L³⋅M⁻¹`) = `M`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L³`.times(that: Quan<`L⁻³⋅N`>) = `N`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L³`.times(that: `L⁻³⋅N`) = `N`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `N`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L³`.div(that: Quan<`L³⋅N⁻¹`>) = `N`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L³`.div(that: `L³⋅N⁻¹`) = `N`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `N`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L³`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L³`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L³`.times(that: Quan<`L⁻³⋅T⋅I`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L³`.times(that: `L⁻³⋅T⋅I`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L³`.times(that: Quan<`L⁻¹⋅I`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L³`.times(that: `L⁻¹⋅I`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L³`.times(that: Quan<`L⁻¹⋅M`>) = `L²⋅M`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L³`.times(that: `L⁻¹⋅M`) = `L²⋅M`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L²⋅M`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L³`.times(that: Quan<`L⁻²`>) = `L`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L³`.times(that: `L⁻²`) = `L`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻²`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L³`.times(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L³`.times(that: `L⁻¹⋅M⋅T⁻³`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L³`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L³`.div(that: `M⁻¹⋅T²⋅I`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L³`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L³`.div(that: `L⋅M⁻¹⋅T²`) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L³`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L³`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L³`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `L³`.times(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `L³`.times(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0N0J0_Multiply_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun times(thiz: Quan<`L³`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L⋅T⁻¹` = L1A0M0I0Theta0N0J0_per_T1
inline class L1A0M0I0Theta0N0J0_per_T1(internal val underlying: Double) : Quan<`L⋅T⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅s⁻¹"

    override fun new(siValue: Double) = `L⋅T⁻¹`(siValue)

    override operator fun unaryPlus() = `L⋅T⁻¹`(+underlying)
    override operator fun unaryMinus() = `L⋅T⁻¹`(-underlying)

    override operator fun plus(that: `L⋅T⁻¹`) = `L⋅T⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅T⁻¹`) = `L⋅T⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅T⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅T⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅T⁻¹`) = `L⋅T⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅T⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L⋅T⁻¹`) = if (this > that) this else that

    override val abs get() = `L⋅T⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅T⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅T⁻¹` && this.siValue == other.siValue
}


typealias `Speed` = `L⋅T⁻¹`

typealias `Velocity` = `L⋅T⁻¹`

@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`Dimensionless`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻¹`.div(that: `Dimensionless`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L⋅T⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻¹`.div(that: `L⋅T⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`Dimensionless`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻¹`.times(that: `Dimensionless`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⋅T⁻¹`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⋅T⁻¹`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻¹`.div(that: `L`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻¹`.times(that: `L`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`M`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻¹`.times(that: `M`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`M`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`T`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅T⁻¹`.div(that: `T`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`T`>) = `L`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅T⁻¹`.times(that: `T`) = `L`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`T⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻¹`.div(that: `T⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`T⁻¹`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻¹`.times(that: `T⁻¹`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⋅M⋅T⁻²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻¹⋅M⋅T⁻²`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⋅T⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅T⁻¹`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⋅T⁻¹`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L²`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻¹`.times(that: `L²`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L²`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻¹`.div(that: `L³⋅T⁻¹`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L⋅T⁻²`>) = `T`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻¹`.div(that: `L⋅T⁻²`) = `T`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⋅T⁻²`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⋅T⁻²`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⋅M⋅T⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L⁻¹`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅T⁻¹`.div(that: `L⁻¹`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻¹`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻¹`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻²⋅M`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻²⋅M`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`M⋅T⁻²`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻¹`.times(that: `M⋅T⁻²`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`M⋅T⁻³`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅T⁻¹`.div(that: `M⋅T⁻³`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻¹`.div(that: `L²⋅T⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻²⋅T⋅I`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻³⋅T⋅I`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻³⋅T⋅I`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⋅T⁻¹`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⋅T⁻¹`.div(that: `M⁻¹⋅T⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⋅T⁻¹`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻¹⋅M`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻¹⋅M`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `I`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `I`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L⁻²`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅T⁻¹`.div(that: `L⁻²`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`M⋅T⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻¹`.times(that: `M⋅T⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⋅T⁻¹`.div(that: `M⁻¹⋅T²⋅I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L⋅T⁻¹`.div(that: `L⋅M⁻¹⋅T²`) = `M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⋅T⁻¹`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅T⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅T⁻¹`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻¹`.times(that: Quan<`T⁻²`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻¹`.times(that: `T⁻²`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`T⁻²`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L⋅T⁻¹`.div(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun div(thiz: Quan<`L⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }


typealias `L³⋅T⁻¹` = L3A0M0I0Theta0N0J0_per_T1
inline class L3A0M0I0Theta0N0J0_per_T1(internal val underlying: Double) : Quan<`L³⋅T⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m³⋅s⁻¹"

    override fun new(siValue: Double) = `L³⋅T⁻¹`(siValue)

    override operator fun unaryPlus() = `L³⋅T⁻¹`(+underlying)
    override operator fun unaryMinus() = `L³⋅T⁻¹`(-underlying)

    override operator fun plus(that: `L³⋅T⁻¹`) = `L³⋅T⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L³⋅T⁻¹`) = `L³⋅T⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L³⋅T⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L³⋅T⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L³⋅T⁻¹`) = `L³⋅T⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L³⋅T⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L³⋅T⁻¹`) = if (this > that) this else that

    override val abs get() = `L³⋅T⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L³⋅T⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L³⋅T⁻¹` && this.siValue == other.siValue
}


typealias `VolumetricFlow` = `L³⋅T⁻¹`

@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`Dimensionless`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅T⁻¹`.div(that: `Dimensionless`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L³⋅T⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L³⋅T⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`Dimensionless`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅T⁻¹`.times(that: `Dimensionless`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`T`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L³⋅T⁻¹`.times(that: `T`) = `L³`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N1J0_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`N`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `L³⋅T⁻¹`.div(that: `N`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N1J0_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`N`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`T⁻¹`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `T⁻¹`) = `L³`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L²⋅M⋅T⁻³`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`T⁻¹⋅N`>) = `L³⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `T⁻¹⋅N`) = `L³⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `L³⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L³`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L³`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L³`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L⋅T⁻¹`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L⋅T⁻¹`) = `L²`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻¹`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻¹`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻²⋅M`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻²⋅M`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻³⋅M`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻³⋅M`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L³⋅M⁻¹`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L³⋅M⁻¹`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻³⋅N`>) = `T⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻³⋅N`) = `T⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `T⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L³⋅N⁻¹`>) = `T⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L³⋅N⁻¹`) = `T⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `T⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L²⋅T⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L²⋅T⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻³⋅T⋅I`>) = `I`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻³⋅T⋅I`) = `I`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `M⁻¹⋅T⋅I`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻¹⋅M`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻¹⋅M`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L³⋅T⁻¹`.times(that: Quan<`L⁻²`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L³⋅T⁻¹`.times(that: `L⁻²`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`M⋅T⁻¹`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `M⋅T⁻¹`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L⋅M⁻¹⋅T²`) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `L³⋅T⁻¹`.div(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `N`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `L³⋅T⁻¹`.div(that: `L³⋅T⁻¹⋅N⁻¹`) = `N`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `N`(this.siValue / that.siValue) }


typealias `L⋅T⁻²` = L1A0M0I0Theta0N0J0_per_T2
inline class L1A0M0I0Theta0N0J0_per_T2(internal val underlying: Double) : Quan<`L⋅T⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅s⁻²"

    override fun new(siValue: Double) = `L⋅T⁻²`(siValue)

    override operator fun unaryPlus() = `L⋅T⁻²`(+underlying)
    override operator fun unaryMinus() = `L⋅T⁻²`(-underlying)

    override operator fun plus(that: `L⋅T⁻²`) = `L⋅T⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅T⁻²`) = `L⋅T⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅T⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅T⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅T⁻²`) = `L⋅T⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅T⁻²`) = if (this < that) this else that
    override infix fun max(that: `L⋅T⁻²`) = if (this > that) this else that

    override val abs get() = `L⋅T⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅T⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅T⁻²` && this.siValue == other.siValue
}


typealias `Acceleration` = `L⋅T⁻²`

@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`Dimensionless`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻²`.div(that: `Dimensionless`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`L⋅T⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻²`.div(that: `L⋅T⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`Dimensionless`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻²`.times(that: `Dimensionless`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`L`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻²`.div(that: `L`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`L`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻²`.times(that: `L`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`M`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻²`.times(that: `M`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`M`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`T`>) = `L⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅T⁻²`.div(that: `T`) = `L⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`T`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅T⁻²`.times(that: `T`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`T⁻¹`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻²`.div(that: `T⁻¹`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`T⁻¹`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻²`.times(that: `T⁻¹`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⋅T⁻²`.times(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`L²⋅T⁻²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻²`.div(that: `L²⋅T⁻²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`L⋅T⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻²`.div(that: `L⋅T⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`L⋅T⁻¹`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻²`.times(that: `L⋅T⁻¹`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`L⋅T⁻³`>) = `T`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅T⁻²`.div(that: `L⋅T⁻³`) = `T`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`L⋅M⋅T⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻²`.times(that: `L⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`L⁻¹`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅T⁻²`.div(that: `L⁻¹`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`L⁻¹`>) = `T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅T⁻²`.times(that: `L⁻¹`) = `T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`L⁻²⋅M`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅T⁻²`.times(that: `L⁻²⋅M`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `L⋅T⁻²`.div(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⋅T⁻²`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⋅T⁻²`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⋅T⁻²`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⋅T⁻²`.div(that: `M⁻¹⋅T⋅I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`L⁻¹⋅M`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅T⁻²`.times(that: `L⁻¹⋅M`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`M⋅T⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻²`.times(that: `M⋅T⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`L⁻¹⋅Θ`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `L⋅T⁻²`.div(that: `L⁻¹⋅Θ`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻²`.div(that: Quan<`T⁻²`>) = `L`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻²`.div(that: `T⁻²`) = `L`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅T⁻²`>, that: Quan<`T⁻²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻²`.times(that: Quan<`T⁻²`>) = `L⋅T⁻⁴`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻²`.times(that: `T⁻²`) = `L⋅T⁻⁴`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅T⁻²`>, that: Quan<`T⁻²`>) = thiz.run { `L⋅T⁻⁴`(this.siValue * that.siValue) }


typealias `L⋅T⁻³` = L1A0M0I0Theta0N0J0_per_T3
inline class L1A0M0I0Theta0N0J0_per_T3(internal val underlying: Double) : Quan<`L⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅s⁻³"

    override fun new(siValue: Double) = `L⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `L⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `L⋅T⁻³`(-underlying)

    override operator fun plus(that: `L⋅T⁻³`) = `L⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅T⁻³`) = `L⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅T⁻³`) = `L⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `L⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `L⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅T⁻³` && this.siValue == other.siValue
}


typealias `Jerk` = `L⋅T⁻³`

typealias `Jolt` = `L⋅T⁻³`

@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `L⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻³`.div(that: `Dimensionless`) = `L⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`L⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅T⁻³`.div(that: `L⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻³`.times(that: `Dimensionless`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻³`.times(that: Quan<`L`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻³`.times(that: `L`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻³`.times(that: Quan<`M`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻³`.times(that: `M`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻³`>, that: Quan<`M`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`T`>) = `L⋅T⁻⁴`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅T⁻³`.div(that: `T`) = `L⋅T⁻⁴`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`T`>) = thiz.run { `L⋅T⁻⁴`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅T⁻³`.times(that: Quan<`T`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅T⁻³`.times(that: `T`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻³`>, that: Quan<`T`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`T⁻¹`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻³`.div(that: `T⁻¹`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻³`.times(that: Quan<`T⁻¹`>) = `L⋅T⁻⁴`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻³`.times(that: `T⁻¹`) = `L⋅T⁻⁴`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅T⁻³`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅T⁻⁴`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`L⋅T⁻¹`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻³`.div(that: `L⋅T⁻¹`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`L⋅T⁻²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻³`.div(that: `L⋅T⁻²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T4_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`L⋅T⁻⁴`>) = `T`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T4_concrete")
operator fun `L⋅T⁻³`.div(that: `L⋅T⁻⁴`) = `T`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T4_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`L⋅T⁻⁴`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`L⁻¹`>) = `L²⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅T⁻³`.div(that: `L⁻¹`) = `L²⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅T⁻³`.times(that: Quan<`L⁻²⋅M`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅T⁻³`.times(that: `L⁻²⋅M`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅T⁻³`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`L²⋅T⁻³`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅T⁻³`.div(that: `L²⋅T⁻³`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅T⁻³`.times(that: Quan<`L⁻¹⋅M`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅T⁻³`.times(that: `L⁻¹⋅M`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅T⁻³`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻³`.div(that: Quan<`T⁻²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻³`.div(that: `T⁻²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅T⁻³`>, that: Quan<`T⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }


typealias `L⋅T⁻⁴` = L1A0M0I0Theta0N0J0_per_T4
inline class L1A0M0I0Theta0N0J0_per_T4(internal val underlying: Double) : Quan<`L⋅T⁻⁴`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅s⁻⁴"

    override fun new(siValue: Double) = `L⋅T⁻⁴`(siValue)

    override operator fun unaryPlus() = `L⋅T⁻⁴`(+underlying)
    override operator fun unaryMinus() = `L⋅T⁻⁴`(-underlying)

    override operator fun plus(that: `L⋅T⁻⁴`) = `L⋅T⁻⁴`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅T⁻⁴`) = `L⋅T⁻⁴`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅T⁻⁴`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅T⁻⁴`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅T⁻⁴`) = `L⋅T⁻⁴`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅T⁻⁴`) = if (this < that) this else that
    override infix fun max(that: `L⋅T⁻⁴`) = if (this > that) this else that

    override val abs get() = `L⋅T⁻⁴`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅T⁻⁴`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅T⁻⁴` && this.siValue == other.siValue
}


typealias `Snap` = `L⋅T⁻⁴`

typealias `Jounce` = `L⋅T⁻⁴`

@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻⁴`.div(that: Quan<`Dimensionless`>) = `L⋅T⁻⁴`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻⁴`.div(that: `Dimensionless`) = `L⋅T⁻⁴`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅T⁻⁴`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅T⁻⁴`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L1A0M0I0Theta0N0J0_per_T4_generic")
operator fun `L⋅T⁻⁴`.div(that: Quan<`L⋅T⁻⁴`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L1A0M0I0Theta0N0J0_per_T4_concrete")
operator fun `L⋅T⁻⁴`.div(that: `L⋅T⁻⁴`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L1A0M0I0Theta0N0J0_per_T4_nonextension")
fun div(thiz: Quan<`L⋅T⁻⁴`>, that: Quan<`L⋅T⁻⁴`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅T⁻⁴`.times(that: Quan<`Dimensionless`>) = `L⋅T⁻⁴`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T4_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅T⁻⁴`.times(that: `Dimensionless`) = `L⋅T⁻⁴`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻⁴`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅T⁻⁴`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅T⁻⁴`.times(that: Quan<`T`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T4_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅T⁻⁴`.times(that: `T`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅T⁻⁴`>, that: Quan<`T`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅T⁻⁴`.div(that: Quan<`T⁻¹`>) = `L⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅T⁻⁴`.div(that: `T⁻¹`) = `L⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅T⁻⁴`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻⁴`.div(that: Quan<`L⋅T⁻²`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻⁴`.div(that: `L⋅T⁻²`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅T⁻⁴`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⋅T⁻⁴`.div(that: Quan<`L⋅T⁻³`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅T⁻⁴`.div(that: `L⋅T⁻³`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅T⁻⁴`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅T⁻⁴`.div(that: Quan<`T⁻²`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅T⁻⁴`.div(that: `T⁻²`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M0I0Theta0N0J0_per_T4_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅T⁻⁴`>, that: Quan<`T⁻²`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }


typealias `∠⋅T⁻¹` = L0A1M0I0Theta0N0J0_per_T1
inline class L0A1M0I0Theta0N0J0_per_T1(internal val underlying: Double) : Quan<`∠⋅T⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "rad⋅s⁻¹"

    override fun new(siValue: Double) = `∠⋅T⁻¹`(siValue)

    override operator fun unaryPlus() = `∠⋅T⁻¹`(+underlying)
    override operator fun unaryMinus() = `∠⋅T⁻¹`(-underlying)

    override operator fun plus(that: `∠⋅T⁻¹`) = `∠⋅T⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `∠⋅T⁻¹`) = `∠⋅T⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `∠⋅T⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `∠⋅T⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `∠⋅T⁻¹`) = `∠⋅T⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `∠⋅T⁻¹`) = if (this < that) this else that
    override infix fun max(that: `∠⋅T⁻¹`) = if (this > that) this else that

    override val abs get() = `∠⋅T⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `∠⋅T⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `∠⋅T⁻¹` && this.siValue == other.siValue
}


typealias `AngularVelocity` = `∠⋅T⁻¹`

@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠⋅T⁻¹`.div(that: Quan<`Dimensionless`>) = `∠⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⋅T⁻¹`.div(that: `Dimensionless`) = `∠⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `∠⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `∠⋅T⁻¹`.div(that: Quan<`∠⋅T⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `∠⋅T⁻¹`.div(that: `∠⋅T⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠⋅T⁻¹`.times(that: Quan<`Dimensionless`>) = `∠⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⋅T⁻¹`.times(that: `Dimensionless`) = `∠⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `∠⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `∠⋅T⁻¹`.div(that: Quan<`T`>) = `∠⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `∠⋅T⁻¹`.div(that: `T`) = `∠⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `∠⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `∠⋅T⁻¹`.times(that: Quan<`T`>) = `∠`(this.siValue * that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `∠⋅T⁻¹`.times(that: `T`) = `∠`(this.siValue * that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `∠`(this.siValue * that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `∠⋅T⁻¹`.div(that: Quan<`T⁻¹`>) = `∠`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `∠⋅T⁻¹`.div(that: `T⁻¹`) = `∠`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `∠`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `∠⋅T⁻¹`.times(that: Quan<`T⁻¹`>) = `∠⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `∠⋅T⁻¹`.times(that: `T⁻¹`) = `∠⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `∠⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A1M0T0I0Theta0N0J0_generic")
operator fun `∠⋅T⁻¹`.div(that: Quan<`∠`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `∠⋅T⁻¹`.div(that: `∠`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A1M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`∠`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `∠⋅T⁻¹`.times(that: Quan<`T⋅I`>) = `∠⋅I`(this.siValue * that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `∠⋅T⁻¹`.times(that: `T⋅I`) = `∠⋅I`(this.siValue * that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `∠⋅I`(this.siValue * that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A1M0I0Theta0N0J0_per_T2_generic")
operator fun `∠⋅T⁻¹`.div(that: Quan<`∠⋅T⁻²`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A1M0I0Theta0N0J0_per_T2_concrete")
operator fun `∠⋅T⁻¹`.div(that: `∠⋅T⁻²`) = `T`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Divide_L0A1M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`∠⋅T⁻²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L2M1I0Theta0N0J0_per_A1T2_generic")
operator fun `∠⋅T⁻¹`.times(that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L2M1I0Theta0N0J0_per_A1T2_concrete")
operator fun `∠⋅T⁻¹`.times(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T1_Multiply_L2M1I0Theta0N0J0_per_A1T2_nonextension")
fun times(thiz: Quan<`∠⋅T⁻¹`>, that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `∠⋅T⁻²` = L0A1M0I0Theta0N0J0_per_T2
inline class L0A1M0I0Theta0N0J0_per_T2(internal val underlying: Double) : Quan<`∠⋅T⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "rad⋅s⁻²"

    override fun new(siValue: Double) = `∠⋅T⁻²`(siValue)

    override operator fun unaryPlus() = `∠⋅T⁻²`(+underlying)
    override operator fun unaryMinus() = `∠⋅T⁻²`(-underlying)

    override operator fun plus(that: `∠⋅T⁻²`) = `∠⋅T⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `∠⋅T⁻²`) = `∠⋅T⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `∠⋅T⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `∠⋅T⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `∠⋅T⁻²`) = `∠⋅T⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `∠⋅T⁻²`) = if (this < that) this else that
    override infix fun max(that: `∠⋅T⁻²`) = if (this > that) this else that

    override val abs get() = `∠⋅T⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `∠⋅T⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `∠⋅T⁻²` && this.siValue == other.siValue
}


typealias `AngularAcceleration` = `∠⋅T⁻²`

@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠⋅T⁻²`.div(that: Quan<`Dimensionless`>) = `∠⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⋅T⁻²`.div(that: `Dimensionless`) = `∠⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `∠⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A1M0I0Theta0N0J0_per_T2_generic")
operator fun `∠⋅T⁻²`.div(that: Quan<`∠⋅T⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A1M0I0Theta0N0J0_per_T2_concrete")
operator fun `∠⋅T⁻²`.div(that: `∠⋅T⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A1M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`∠⋅T⁻²`>, that: Quan<`∠⋅T⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠⋅T⁻²`.times(that: Quan<`Dimensionless`>) = `∠⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⋅T⁻²`.times(that: `Dimensionless`) = `∠⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `∠⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `∠⋅T⁻²`.times(that: Quan<`T`>) = `∠⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `∠⋅T⁻²`.times(that: `T`) = `∠⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `∠⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `∠⋅T⁻²`.div(that: Quan<`T⁻¹`>) = `∠⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `∠⋅T⁻²`.div(that: `T⁻¹`) = `∠⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`∠⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `∠⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A1M0T0I0Theta0N0J0_generic")
operator fun `∠⋅T⁻²`.div(that: Quan<`∠`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `∠⋅T⁻²`.div(that: `∠`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A1M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅T⁻²`>, that: Quan<`∠`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `∠⋅T⁻²`.div(that: Quan<`∠⋅T⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `∠⋅T⁻²`.div(that: `∠⋅T⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`∠⋅T⁻²`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `∠⋅T⁻²`.div(that: Quan<`T⁻²`>) = `∠`(this.siValue / that.siValue)
// @JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `∠⋅T⁻²`.div(that: `T⁻²`) = `∠`(this.siValue / that.siValue)
@JvmName("L0A1M0I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`∠⋅T⁻²`>, that: Quan<`T⁻²`>) = thiz.run { `∠`(this.siValue / that.siValue) }


typealias `L⋅M⋅T⁻¹` = L1A0M1I0Theta0N0J0_per_T1
inline class L1A0M1I0Theta0N0J0_per_T1(internal val underlying: Double) : Quan<`L⋅M⋅T⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅kg⋅s⁻¹"

    override fun new(siValue: Double) = `L⋅M⋅T⁻¹`(siValue)

    override operator fun unaryPlus() = `L⋅M⋅T⁻¹`(+underlying)
    override operator fun unaryMinus() = `L⋅M⋅T⁻¹`(-underlying)

    override operator fun plus(that: `L⋅M⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅M⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅M⋅T⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅M⋅T⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅M⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅M⋅T⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L⋅M⋅T⁻¹`) = if (this > that) this else that

    override val abs get() = `L⋅M⋅T⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅M⋅T⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅M⋅T⁻¹` && this.siValue == other.siValue
}


typealias `Momentum` = `L⋅M⋅T⁻¹`

typealias `Impulse` = `L⋅M⋅T⁻¹`

@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `Dimensionless`) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⋅M⋅T⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻¹`.times(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻¹`.times(that: `Dimensionless`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻¹`.times(that: Quan<`L`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻¹`.times(that: `L`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`M`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `M`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`M`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`T`>) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `T`) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻¹`.times(that: Quan<`T⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻¹`.times(that: `T⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻²`>) = `T`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⋅M⋅T⁻²`) = `T`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`T⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `T⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L²`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L²`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L²`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⋅T⁻¹`>) = `M`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⋅T⁻¹`) = `M`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻¹`.times(that: Quan<`L⋅T⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻¹`.times(that: `L⋅T⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L³⋅T⁻¹`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻¹`.times(that: Quan<`L⋅T⁻²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻¹`.times(that: `L⋅T⁻²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L²⋅M⋅T⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻¹`.times(that: Quan<`L⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻¹`.times(that: `L⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⁻²⋅M`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⁻²⋅M`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L²⋅T⁻¹`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⁻²⋅T⋅I`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⁻¹⋅M`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⁻¹⋅T⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻¹`.times(that: Quan<`L⁻²`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻¹`.times(that: `L⁻²`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`M⋅T⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `M⋅T⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻¹`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻¹`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻¹`.times(that: Quan<`T⁻²`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻¹`.times(that: `T⁻²`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻¹`>, that: Quan<`T⁻²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L²⋅M⋅T⁻¹` = L2A0M1I0Theta0N0J0_per_T1
inline class L2A0M1I0Theta0N0J0_per_T1(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻¹"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻¹`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻¹`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻¹`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻¹`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻¹` && this.siValue == other.siValue
}


typealias `AngularMomentum` = `L²⋅M⋅T⁻¹`

typealias `Action` = `L²⋅M⋅T⁻¹`

@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L²⋅M⋅T⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L`>) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L`) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`M`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `M`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`M`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`T`>) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `T`) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.times(that: Quan<`T`>) = `L²⋅M`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.times(that: `T`) = `L²⋅M`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L²⋅M`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`T⁻¹`>) = `L²⋅M`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `T⁻¹`) = `L²⋅M`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻¹`.times(that: Quan<`T⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻¹`.times(that: `T⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²`>) = `T`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L²⋅M⋅T⁻²`) = `T`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`T⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `T⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L²`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L²`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L²`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L³`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L³`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L³`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L³⋅T⁻¹`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L⋅M⋅T⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻¹`.times(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻¹`.times(that: `L⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L²⋅T⁻¹`>) = `M`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L²⋅T⁻¹`) = `M`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L³`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻¹`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻¹`.times(that: `M⁻¹⋅T⋅I`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L⁻¹⋅M`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L⁻¹⋅T⋅I`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅M⋅T⁻¹`.times(that: Quan<`L⁻²`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M⋅T⁻¹`.times(that: `L⁻²`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`M⋅T⁻¹`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `M⋅T⁻¹`) = `L²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻¹`.div(that: Quan<`L²⋅M`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻¹`.div(that: `L²⋅M`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`L²⋅M`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻¹`.times(that: Quan<`T⁻²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻¹`.times(that: `T⁻²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻¹`>, that: Quan<`T⁻²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L²⋅∠⁻¹⋅M⋅T⁻²` = L2M1I0Theta0N0J0_per_A1T2
inline class L2M1I0Theta0N0J0_per_A1T2(internal val underlying: Double) : Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅rad⁻¹⋅kg⋅s⁻²"

    override fun new(siValue: Double) = `L²⋅∠⁻¹⋅M⋅T⁻²`(siValue)

    override operator fun unaryPlus() = `L²⋅∠⁻¹⋅M⋅T⁻²`(+underlying)
    override operator fun unaryMinus() = `L²⋅∠⁻¹⋅M⋅T⁻²`(-underlying)

    override operator fun plus(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = if (this < that) this else that
    override infix fun max(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = if (this > that) this else that

    override val abs get() = `L²⋅∠⁻¹⋅M⋅T⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅∠⁻¹⋅M⋅T⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅∠⁻¹⋅M⋅T⁻²` && this.siValue == other.siValue
}


typealias `Torque` = `L²⋅∠⁻¹⋅M⋅T⁻²`

@JvmName("L2M1I0Theta0N0J0_per_A1T2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.div(that: Quan<`Dimensionless`>) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A1T2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.div(that: `Dimensionless`) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A1T2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A1T2_Divide_L2M1I0Theta0N0J0_per_A1T2_generic")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.div(that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A1T2_Divide_L2M1I0Theta0N0J0_per_A1T2_concrete")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.div(that: `L²⋅∠⁻¹⋅M⋅T⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A1T2_Divide_L2M1I0Theta0N0J0_per_A1T2_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>, that: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A1T2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.times(that: Quan<`Dimensionless`>) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A1T2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.times(that: `Dimensionless`) = `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A1T2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅∠⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A1T2_Multiply_L0A1M0T0I0Theta0N0J0_generic")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.times(that: Quan<`∠`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A1T2_Multiply_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.times(that: `∠`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A1T2_Multiply_L0A1M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>, that: Quan<`∠`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A1T2_Multiply_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.times(that: Quan<`∠⋅T⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A1T2_Multiply_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅∠⁻¹⋅M⋅T⁻²`.times(that: `∠⋅T⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A1T2_Multiply_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅∠⁻¹⋅M⋅T⁻²`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L⋅M⋅T⁻³` = L1A0M1I0Theta0N0J0_per_T3
inline class L1A0M1I0Theta0N0J0_per_T3(internal val underlying: Double) : Quan<`L⋅M⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅kg⋅s⁻³"

    override fun new(siValue: Double) = `L⋅M⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `L⋅M⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `L⋅M⋅T⁻³`(-underlying)

    override operator fun plus(that: `L⋅M⋅T⁻³`) = `L⋅M⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅M⋅T⁻³`) = `L⋅M⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅M⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅M⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅M⋅T⁻³`) = `L⋅M⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅M⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `L⋅M⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `L⋅M⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅M⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅M⋅T⁻³` && this.siValue == other.siValue
}


typealias `Yank` = `L⋅M⋅T⁻³`

typealias `SpectralPower` = `L⋅M⋅T⁻³`

@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `Dimensionless`) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.times(that: `Dimensionless`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L`>) = `M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L`) = `M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³`.times(that: Quan<`L`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.times(that: `L`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`M`>) = `L⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `M`) = `L⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`M`>) = thiz.run { `L⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³`.times(that: Quan<`T`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.times(that: `T`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`T`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`Θ`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `Θ`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta1N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`Θ`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`T⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `T⁻¹`) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A2M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`∠²`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `∠²`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A2M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`∠²`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻²`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L²⋅M⋅T⁻³`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L²⋅M⋅T⁻³`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L²⋅T⁻²`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L²⋅T⁻²`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L²`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L²`) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L²`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⋅T⁻¹`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⋅T⁻¹`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⋅T⁻²`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⋅T⁻²`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⋅T⁻³`>) = `M`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⋅T⁻³`) = `M`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻¹`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻¹`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻³`.times(that: Quan<`L⁻¹`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻³`.times(that: `L⁻¹`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`M⋅T⁻²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `M⋅T⁻²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`M⋅T⁻³`>) = `L`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `M⋅T⁻³`) = `L`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0N0J0_per_T3Theta1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = `Θ`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0N0J0_per_T3Theta1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `Θ`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0N0J0_per_T3Theta1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = thiz.run { `Θ`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L²⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `I`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `I`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⁻¹⋅I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L²⋅T⁻³`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L²⋅T⁻³`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M`>) = `L²⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⁻¹⋅M`) = `L²⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L²⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻³`.times(that: Quan<`L⁻²`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻³`.times(that: `L⁻²`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`M⋅T⁻¹`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `M⋅T⁻¹`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻³`) = `L²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `L⋅M⋅T⁻³`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `L⋅M⋅T⁻³`.times(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L⋅M⋅T⁻³`.times(that: Quan<`Θ⁻¹`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L⋅M⋅T⁻³`.times(that: `Θ⁻¹`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L⋅M⋅T⁻³`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L⋅M⋅T⁻³`.times(that: `L⋅M⁻¹⋅T²`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`T⁻²`>) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `T⁻²`) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`T⁻²`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⋅M⋅T⁻³`.div(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `∠²`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⋅M⋅T⁻³`.div(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `∠²`(this.siValue / that.siValue)
@JvmName("L1A0M1I0Theta0N0J0_per_T3_Divide_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `∠²`(this.siValue / that.siValue) }


typealias `L⁻²⋅M` = A0M1T0I0Theta0N0J0_per_L2
inline class A0M1T0I0Theta0N0J0_per_L2(internal val underlying: Double) : Quan<`L⁻²⋅M`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅kg"

    override fun new(siValue: Double) = `L⁻²⋅M`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅M`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅M`(-underlying)

    override operator fun plus(that: `L⁻²⋅M`) = `L⁻²⋅M`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅M`) = `L⁻²⋅M`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅M`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅M`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅M`) = `L⁻²⋅M`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅M`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅M`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅M`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅M`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅M` && this.siValue == other.siValue
}


typealias `AreaDensity` = `L⁻²⋅M`

@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M`.div(that: `Dimensionless`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅M`.div(that: Quan<`L⁻²⋅M`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅M`.div(that: `L⁻²⋅M`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M`.times(that: `Dimensionless`) = `L⁻²⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M`.div(that: Quan<`L`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M`.div(that: `L`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M`.times(that: `L`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M`.div(that: Quan<`M`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M`.div(that: `M`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M`>, that: Quan<`M`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L²⋅T⁻²`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²⋅M`.times(that: `L²⋅T⁻²`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L²`>) = `M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M`.times(that: `L²`) = `M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L²`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M`.times(that: `L⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L³⋅T⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M`.times(that: `L³⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L⋅T⁻²`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²⋅M`.times(that: `L⋅T⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L⋅T⁻³`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻²⋅M`.times(that: `L⋅T⁻³`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅M`.div(that: Quan<`L⁻¹`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅M`.div(that: `L⁻¹`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L⁻¹`>) = `L⁻³⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅M`.times(that: `L⁻¹`) = `L⁻³⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻³⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L⁻²⋅M`.div(that: Quan<`L⁻³⋅M`>) = `L`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L⁻²⋅M`.div(that: `L⁻³⋅M`) = `L`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L³⋅M⁻¹`>) = `L`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻²⋅M`.times(that: `L³⋅M⁻¹`) = `L`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L²⋅T⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅M`.times(that: `L²⋅T⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻²⋅M`.times(that: `M⁻¹⋅T⋅I`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⁻²⋅M`.times(that: Quan<`L²⋅T⁻³`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻²⋅M`.times(that: `L²⋅T⁻³`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅M`.div(that: Quan<`L⁻¹⋅M`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅M`.div(that: `L⁻¹⋅M`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅M`.div(that: Quan<`L⁻²`>) = `M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅M`.div(that: `L⁻²`) = `M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅M`>, that: Quan<`L⁻²`>) = thiz.run { `M`(this.siValue / that.siValue) }


typealias `L⁻³⋅M` = A0M1T0I0Theta0N0J0_per_L3
inline class A0M1T0I0Theta0N0J0_per_L3(internal val underlying: Double) : Quan<`L⁻³⋅M`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻³⋅kg"

    override fun new(siValue: Double) = `L⁻³⋅M`(siValue)

    override operator fun unaryPlus() = `L⁻³⋅M`(+underlying)
    override operator fun unaryMinus() = `L⁻³⋅M`(-underlying)

    override operator fun plus(that: `L⁻³⋅M`) = `L⁻³⋅M`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻³⋅M`) = `L⁻³⋅M`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻³⋅M`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻³⋅M`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻³⋅M`) = `L⁻³⋅M`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻³⋅M`) = if (this < that) this else that
    override infix fun max(that: `L⁻³⋅M`) = if (this > that) this else that

    override val abs get() = `L⁻³⋅M`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻³⋅M`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻³⋅M` && this.siValue == other.siValue
}


typealias `Density` = `L⁻³⋅M`

typealias `MassDensity` = `L⁻³⋅M`

@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M`.div(that: Quan<`Dimensionless`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M`.div(that: `Dimensionless`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻³⋅M`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L⁻³⋅M`.div(that: Quan<`L⁻³⋅M`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L⁻³⋅M`.div(that: `L⁻³⋅M`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`Dimensionless`>) = `L⁻³⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M`.times(that: `Dimensionless`) = `L⁻³⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`L`>) = `L⁻²⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M`.times(that: `L`) = `L⁻²⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L`>) = thiz.run { `L⁻²⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`L²⋅T⁻²`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻³⋅M`.times(that: `L²⋅T⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`L²`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M`.times(that: `L²`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L²`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`L³`>) = `M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M`.times(that: `L³`) = `M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L³`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`L³⋅T⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅M`.times(that: `L³⋅T⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻³⋅M`.div(that: Quan<`L⁻¹`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻³⋅M`.div(that: `L⁻¹`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻³⋅M`.div(that: Quan<`L⁻²⋅M`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻³⋅M`.div(that: `L⁻²⋅M`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`L³⋅M⁻¹`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻³⋅M`.times(that: `L³⋅M⁻¹`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L⁻³⋅M`.div(that: Quan<`L⁻³⋅N`>) = `M⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L⁻³⋅M`.div(that: `L⁻³⋅N`) = `M⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `M⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`L³⋅N⁻¹`>) = `M⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L⁻³⋅M`.times(that: `L³⋅N⁻¹`) = `M⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `M⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`L²⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅M`.times(that: `L²⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻³⋅M`.times(that: `M⁻¹⋅T⋅I`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`L²⋅T⁻³`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻³⋅M`.times(that: `L²⋅T⁻³`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻³⋅M`.div(that: Quan<`L⁻¹⋅M`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻³⋅M`.div(that: `L⁻¹⋅M`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `L⁻³⋅M`.times(that: Quan<`M⁻¹⋅N`>) = `L⁻³⋅N`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `L⁻³⋅M`.times(that: `M⁻¹⋅N`) = `L⁻³⋅N`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Multiply_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `L⁻³⋅N`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `L⁻³⋅M`.div(that: Quan<`M⋅N⁻¹`>) = `L⁻³⋅N`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `L⁻³⋅M`.div(that: `M⋅N⁻¹`) = `L⁻³⋅N`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `L⁻³⋅N`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻³⋅M`.div(that: Quan<`L⁻²`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻³⋅M`.div(that: `L⁻²`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻³⋅M`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }


typealias `L³⋅M⁻¹` = L3A0T0I0Theta0N0J0_per_M1
inline class L3A0T0I0Theta0N0J0_per_M1(internal val underlying: Double) : Quan<`L³⋅M⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m³⋅kg⁻¹"

    override fun new(siValue: Double) = `L³⋅M⁻¹`(siValue)

    override operator fun unaryPlus() = `L³⋅M⁻¹`(+underlying)
    override operator fun unaryMinus() = `L³⋅M⁻¹`(-underlying)

    override operator fun plus(that: `L³⋅M⁻¹`) = `L³⋅M⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L³⋅M⁻¹`) = `L³⋅M⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L³⋅M⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L³⋅M⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L³⋅M⁻¹`) = `L³⋅M⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L³⋅M⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L³⋅M⁻¹`) = if (this > that) this else that

    override val abs get() = `L³⋅M⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L³⋅M⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L³⋅M⁻¹` && this.siValue == other.siValue
}


typealias `SpecificVolume` = `L³⋅M⁻¹`

@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⁻¹`.div(that: Quan<`Dimensionless`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⁻¹`.div(that: `Dimensionless`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L³⋅M⁻¹`.div(that: Quan<`L³⋅M⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L³⋅M⁻¹`.div(that: `L³⋅M⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`Dimensionless`>) = `L³⋅M⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⁻¹`.times(that: `Dimensionless`) = `L³⋅M⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅M⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`M`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⁻¹`.times(that: `M`) = `L³`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`M`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L³⋅M⁻¹`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L³⋅M⁻¹`.div(that: Quan<`L²⋅T⁻²`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L³⋅M⁻¹`.div(that: `L²⋅T⁻²`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`L⁻²⋅M`>) = `L`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L³⋅M⁻¹`.times(that: `L⁻²⋅M`) = `L`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`L⁻³⋅M`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L³⋅M⁻¹`.times(that: `L⁻³⋅M`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`L⁻³⋅N`>) = `M⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L³⋅M⁻¹`.times(that: `L⁻³⋅N`) = `M⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `M⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L³⋅M⁻¹`.div(that: Quan<`L³⋅N⁻¹`>) = `M⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L³⋅M⁻¹`.div(that: `L³⋅N⁻¹`) = `M⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `M⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L³⋅M⁻¹`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`L⁻³⋅T⋅I`>) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L³⋅M⁻¹`.times(that: `L⁻³⋅T⋅I`) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`L⁻¹⋅M`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L³⋅M⁻¹`.times(that: `L⁻¹⋅M`) = `L²`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `L³⋅M⁻¹`.div(that: Quan<`M⁻¹⋅N`>) = `L³⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `L³⋅M⁻¹`.div(that: `M⁻¹⋅N`) = `L³⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun div(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `L³⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`M⋅N⁻¹`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `L³⋅M⁻¹`.times(that: `M⋅N⁻¹`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`M⋅T⁻¹`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅M⁻¹`.times(that: `M⋅T⁻¹`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L³⋅M⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L³⋅M⁻¹`.times(that: `L⁻¹⋅M⋅T⁻³`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun times(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L³⋅M⁻¹`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L³⋅M⁻¹`.div(that: `L⋅M⁻¹⋅T²`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L3A0T0I0Theta0N0J0_per_M1_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³⋅M⁻¹`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }


typealias `L⁻³⋅N` = A0M0T0I0Theta0N1J0_per_L3
inline class A0M0T0I0Theta0N1J0_per_L3(internal val underlying: Double) : Quan<`L⁻³⋅N`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻³⋅mol"

    override fun new(siValue: Double) = `L⁻³⋅N`(siValue)

    override operator fun unaryPlus() = `L⁻³⋅N`(+underlying)
    override operator fun unaryMinus() = `L⁻³⋅N`(-underlying)

    override operator fun plus(that: `L⁻³⋅N`) = `L⁻³⋅N`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻³⋅N`) = `L⁻³⋅N`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻³⋅N`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻³⋅N`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻³⋅N`) = `L⁻³⋅N`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻³⋅N`) = if (this < that) this else that
    override infix fun max(that: `L⁻³⋅N`) = if (this > that) this else that

    override val abs get() = `L⁻³⋅N`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻³⋅N`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻³⋅N` && this.siValue == other.siValue
}


typealias `Molarity` = `L⁻³⋅N`

typealias `AmountOfSubstanceConcentration` = `L⁻³⋅N`

@JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅N`.div(that: Quan<`Dimensionless`>) = `L⁻³⋅N`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅N`.div(that: `Dimensionless`) = `L⁻³⋅N`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻³⋅N`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅N`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L⁻³⋅N`.div(that: Quan<`L⁻³⋅N`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L⁻³⋅N`.div(that: `L⁻³⋅N`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻³⋅N`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅N`.times(that: Quan<`Dimensionless`>) = `L⁻³⋅N`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅N`.times(that: `Dimensionless`) = `L⁻³⋅N`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅N`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅N`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅N`.times(that: Quan<`L³`>) = `N`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅N`.times(that: `L³`) = `N`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅N`>, that: Quan<`L³`>) = thiz.run { `N`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅N`.times(that: Quan<`L³⋅T⁻¹`>) = `T⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅N`.times(that: `L³⋅T⁻¹`) = `T⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅N`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `T⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L⁻³⋅N`.div(that: Quan<`L⁻³⋅M`>) = `M⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L⁻³⋅N`.div(that: `L⁻³⋅M`) = `M⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻³⋅N`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `M⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L⁻³⋅N`.times(that: Quan<`L³⋅M⁻¹`>) = `M⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻³⋅N`.times(that: `L³⋅M⁻¹`) = `M⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻³⋅N`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `M⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L⁻³⋅N`.times(that: Quan<`L³⋅N⁻¹`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L⁻³⋅N`.times(that: `L³⋅N⁻¹`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`L⁻³⋅N`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `L⁻³⋅N`.times(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `L⁻³⋅N`.times(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun times(thiz: Quan<`L⁻³⋅N`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L0A0T3I2Theta0J0_per_M1N1_generic")
operator fun `L⁻³⋅N`.times(that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L0A0T3I2Theta0J0_per_M1N1_concrete")
operator fun `L⁻³⋅N`.times(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L0A0T3I2Theta0J0_per_M1N1_nonextension")
fun times(thiz: Quan<`L⁻³⋅N`>, that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `L⁻³⋅N`.div(that: Quan<`M⁻¹⋅N`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `L⁻³⋅N`.div(that: `M⁻¹⋅N`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Divide_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅N`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `L⁻³⋅N`.times(that: Quan<`M⋅N⁻¹`>) = `L⁻³⋅M`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `L⁻³⋅N`.times(that: `M⋅N⁻¹`) = `L⁻³⋅M`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`L⁻³⋅N`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `L⁻³⋅M`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `L⁻³⋅N`.times(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `L⁻³⋅N`.times(that: `L³⋅T⁻¹⋅N⁻¹`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta0N1J0_per_L3_Multiply_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun times(thiz: Quan<`L⁻³⋅N`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }


typealias `L³⋅N⁻¹` = L3A0M0T0I0Theta0J0_per_N1
inline class L3A0M0T0I0Theta0J0_per_N1(internal val underlying: Double) : Quan<`L³⋅N⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m³⋅mol⁻¹"

    override fun new(siValue: Double) = `L³⋅N⁻¹`(siValue)

    override operator fun unaryPlus() = `L³⋅N⁻¹`(+underlying)
    override operator fun unaryMinus() = `L³⋅N⁻¹`(-underlying)

    override operator fun plus(that: `L³⋅N⁻¹`) = `L³⋅N⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L³⋅N⁻¹`) = `L³⋅N⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L³⋅N⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L³⋅N⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L³⋅N⁻¹`) = `L³⋅N⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L³⋅N⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L³⋅N⁻¹`) = if (this > that) this else that

    override val abs get() = `L³⋅N⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L³⋅N⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L³⋅N⁻¹` && this.siValue == other.siValue
}


typealias `MolarVolume` = `L³⋅N⁻¹`

@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`Dimensionless`>) = `L³⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅N⁻¹`.div(that: `Dimensionless`) = `L³⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`L³⋅N⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L³⋅N⁻¹`.div(that: `L³⋅N⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅N⁻¹`.times(that: Quan<`Dimensionless`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅N⁻¹`.times(that: `Dimensionless`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`T`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L³⋅N⁻¹`.div(that: `T`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`T`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N1J0_generic")
operator fun `L³⋅N⁻¹`.times(that: Quan<`N`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `L³⋅N⁻¹`.times(that: `N`) = `L³`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N1J0_nonextension")
fun times(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`N`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅N⁻¹`.times(that: Quan<`T⁻¹`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅N⁻¹`.times(that: `T⁻¹`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L³⋅N⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L³⋅N⁻¹`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `L³⋅N⁻¹`.times(that: Quan<`T⁻¹⋅N`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `L³⋅N⁻¹`.times(that: `T⁻¹⋅N`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun times(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L³⋅N⁻¹`.times(that: Quan<`L⁻³⋅M`>) = `M⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L³⋅N⁻¹`.times(that: `L⁻³⋅M`) = `M⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `M⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`L³⋅M⁻¹`>) = `M⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L³⋅N⁻¹`.div(that: `L³⋅M⁻¹`) = `M⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `M⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L³⋅N⁻¹`.times(that: Quan<`L⁻³⋅N`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L³⋅N⁻¹`.times(that: `L⁻³⋅N`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `L³⋅N⁻¹`.div(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L³⋅N⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L³⋅N⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0T3I2Theta0J0_per_M1N1_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0T3I2Theta0J0_per_M1N1_concrete")
operator fun `L³⋅N⁻¹`.div(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0T3I2Theta0J0_per_M1N1_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L³⋅N⁻¹`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `L³⋅N⁻¹`.times(that: Quan<`M⁻¹⋅N`>) = `L³⋅M⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `L³⋅N⁻¹`.times(that: `M⁻¹⋅N`) = `L³⋅M⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun times(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `L³⋅M⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`M⋅N⁻¹`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `L³⋅N⁻¹`.div(that: `M⋅N⁻¹`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L³⋅N⁻¹`.div(that: `L⋅M⁻¹⋅T²`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `L³⋅N⁻¹`.div(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `L³⋅N⁻¹`.div(that: `L³⋅T⁻¹⋅N⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L3A0M0T0I0Theta0J0_per_N1_Divide_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun div(thiz: Quan<`L³⋅N⁻¹`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }


typealias `L²⋅M⋅T⁻²⋅Θ⁻¹` = L2A0M1I0N0J0_per_T2Theta1
inline class L2A0M1I0N0J0_per_T2Theta1(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻²⋅K⁻¹"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻²⋅Θ⁻¹`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻²⋅Θ⁻¹`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻²⋅Θ⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻²⋅Θ⁻¹` && this.siValue == other.siValue
}


typealias `HeatCapacity` = `L²⋅M⋅T⁻²⋅Θ⁻¹`

typealias `Entropy` = `L²⋅M⋅T⁻²⋅Θ⁻¹`

@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M1I0N0J0_per_T2Theta1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M1I0N0J0_per_T2Theta1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M1I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`M`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: `M`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`M`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`Θ`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.times(that: `Θ`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta1N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`Θ`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0Theta0N1J0_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`N`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: `N`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0Theta0N1J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`N`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²`>) = `Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: `L²⋅M⋅T⁻²`) = `Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M1I0J0_per_T2Theta1N1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = `N`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M1I0J0_per_T2Theta1N1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `N`(this.siValue / that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M1I0J0_per_T2Theta1N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = thiz.run { `N`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `M`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: `L²⋅T⁻²⋅Θ⁻¹`) = `M`(this.siValue / that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `T`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `T`(this.siValue * that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`Θ⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.div(that: `Θ⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`L⁻¹⋅Θ`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹`.times(that: `L⁻¹⋅Θ`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0N0J0_per_T2Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }


typealias `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹` = L2A0M1I0J0_per_T2Theta1N1
inline class L2A0M1I0J0_per_T2Theta1N1(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻²⋅K⁻¹⋅mol⁻¹"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹` && this.siValue == other.siValue
}


typealias `MolarHeatCapacity` = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`

typealias `MolarEntropy` = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`

@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L2A0M1I0J0_per_T2Theta1N1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L2A0M1I0J0_per_T2Theta1N1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L2A0M1I0J0_per_T2Theta1N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.times(that: Quan<`Θ`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.times(that: `Θ`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0M0T0I0Theta1N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`Θ`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0M0T0I0Theta0N1J0_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.times(that: Quan<`N`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.times(that: `N`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0M0T0I0Theta0N1J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`N`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `M⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: `L²⋅T⁻²⋅Θ⁻¹`) = `M⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `M⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.times(that: Quan<`M⁻¹⋅N`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.times(that: `M⁻¹⋅N`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: Quan<`M⋅N⁻¹`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: `M⋅N⁻¹`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: Quan<`Θ⁻¹`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`.div(that: `Θ⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0J0_per_T2Theta1N1_Divide_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue) }


typealias `L²⋅T⁻²⋅Θ⁻¹` = L2A0M0I0N0J0_per_T2Theta1
inline class L2A0M0I0N0J0_per_T2Theta1(internal val underlying: Double) : Quan<`L²⋅T⁻²⋅Θ⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅s⁻²⋅K⁻¹"

    override fun new(siValue: Double) = `L²⋅T⁻²⋅Θ⁻¹`(siValue)

    override operator fun unaryPlus() = `L²⋅T⁻²⋅Θ⁻¹`(+underlying)
    override operator fun unaryMinus() = `L²⋅T⁻²⋅Θ⁻¹`(-underlying)

    override operator fun plus(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L²⋅T⁻²⋅Θ⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L²⋅T⁻²⋅Θ⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅T⁻²⋅Θ⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅T⁻²⋅Θ⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L²⋅T⁻²⋅Θ⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅T⁻²⋅Θ⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L²⋅T⁻²⋅Θ⁻¹`) = if (this > that) this else that

    override val abs get() = `L²⋅T⁻²⋅Θ⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅T⁻²⋅Θ⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅T⁻²⋅Θ⁻¹` && this.siValue == other.siValue
}


typealias `SpecificHeatCapacity` = `L²⋅T⁻²⋅Θ⁻¹`

typealias `SpecificEntropy` = `L²⋅T⁻²⋅Θ⁻¹`

@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`Dimensionless`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: `Dimensionless`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: `L²⋅T⁻²⋅Θ⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`Dimensionless`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: `Dimensionless`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`M`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: `M`) = `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`M`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`Θ`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: `Θ`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M0T0I0Theta1N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`Θ`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`L²⋅T⁻²`>) = `Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: `L²⋅T⁻²`) = `Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L2A0M1I0J0_per_T2Theta1N1_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = `M⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L2A0M1I0J0_per_T2Theta1N1_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `M⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L2A0M1I0J0_per_T2Theta1N1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = thiz.run { `M⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`M⁻¹⋅N`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: `M⁻¹⋅N`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`M⋅N⁻¹`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: `M⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: Quan<`Θ⁻¹`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.div(that: `Θ⁻¹`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: Quan<`L⁻¹⋅Θ`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `L²⋅T⁻²⋅Θ⁻¹`.times(that: `L⁻¹⋅Θ`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0N0J0_per_T2Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻²⋅Θ⁻¹`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }


typealias `L²⋅M⋅T⁻²⋅N⁻¹` = L2A0M1I0Theta0J0_per_T2N1
inline class L2A0M1I0Theta0J0_per_T2N1(internal val underlying: Double) : Quan<`L²⋅M⋅T⁻²⋅N⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg⋅s⁻²⋅mol⁻¹"

    override fun new(siValue: Double) = `L²⋅M⋅T⁻²⋅N⁻¹`(siValue)

    override operator fun unaryPlus() = `L²⋅M⋅T⁻²⋅N⁻¹`(+underlying)
    override operator fun unaryMinus() = `L²⋅M⋅T⁻²⋅N⁻¹`(-underlying)

    override operator fun plus(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = if (this > that) this else that

    override val abs get() = `L²⋅M⋅T⁻²⋅N⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M⋅T⁻²⋅N⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M⋅T⁻²⋅N⁻¹` && this.siValue == other.siValue
}


typealias `MolarEnergy` = `L²⋅M⋅T⁻²⋅N⁻¹`

@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: Quan<`Dimensionless`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: `Dimensionless`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`Θ`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `Θ`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L0A0M0T0I0Theta1N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`Θ`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0T0I0Theta0N1J0_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: Quan<`N`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: `N`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0T0I0Theta0N1J0_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`N`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L³⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `L⁻¹⋅M⋅T⁻²`) = `L³⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L³⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`L²⋅T⁻²`>) = `M⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `L²⋅T⁻²`) = `M⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `M⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: Quan<`T⁻¹⋅N`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: `T⁻¹⋅N`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: Quan<`L⁻³⋅N`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: `L⁻³⋅N`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`L³⋅N⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `L³⋅N⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L2A0M1I0J0_per_T2Theta1N1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = `Θ`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L2A0M1I0J0_per_T2Theta1N1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `Θ`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L2A0M1I0J0_per_T2Theta1N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = thiz.run { `Θ`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: Quan<`M⁻¹⋅N`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: `M⁻¹⋅N`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`M⋅N⁻¹`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `M⋅N⁻¹`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: Quan<`Θ⁻¹`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: `Θ⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.times(that: `L⋅M⁻¹⋅T²`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `L²⋅M⋅T⁻²⋅N⁻¹`.div(that: `L³⋅T⁻¹⋅N⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1I0Theta0J0_per_T2N1_Divide_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun div(thiz: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }


typealias `M⋅T⁻²` = L0A0M1I0Theta0N0J0_per_T2
inline class L0A0M1I0Theta0N0J0_per_T2(internal val underlying: Double) : Quan<`M⋅T⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "kg⋅s⁻²"

    override fun new(siValue: Double) = `M⋅T⁻²`(siValue)

    override operator fun unaryPlus() = `M⋅T⁻²`(+underlying)
    override operator fun unaryMinus() = `M⋅T⁻²`(-underlying)

    override operator fun plus(that: `M⋅T⁻²`) = `M⋅T⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `M⋅T⁻²`) = `M⋅T⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M⋅T⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M⋅T⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `M⋅T⁻²`) = `M⋅T⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `M⋅T⁻²`) = if (this < that) this else that
    override infix fun max(that: `M⋅T⁻²`) = if (this > that) this else that

    override val abs get() = `M⋅T⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M⋅T⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M⋅T⁻²` && this.siValue == other.siValue
}


typealias `SurfaceTension` = `M⋅T⁻²`

typealias `Stiffness` = `M⋅T⁻²`

typealias `RadiantExposure` = `M⋅T⁻²`

@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`Dimensionless`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²`.div(that: `Dimensionless`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`M⋅T⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻²`.div(that: `M⋅T⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`Dimensionless`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²`.times(that: `Dimensionless`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²`.div(that: `L`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`L`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²`.times(that: `L`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`M`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²`.div(that: `M`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`M`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`T`>) = `M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²`.div(that: `T`) = `M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`T`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²`.times(that: `T`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`T`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `M⋅T⁻²`.div(that: `I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`T⁻¹`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻²`.div(that: `T⁻¹`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`T⁻¹`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻²`.times(that: `T⁻¹`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`T⁻¹`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻²`.div(that: `L⋅M⋅T⁻²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻²`) = `L`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `M⋅T⁻²`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻²`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻²`.div(that: `M⋅T⁻²⋅I⁻¹`) = `I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L²⋅T⁻²`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻²`.div(that: `L²⋅T⁻²`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`L²`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻²`.times(that: `L²`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻²`.div(that: `L⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`L⋅T⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻²`.times(that: `L⋅T⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⋅T⁻²`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻²`.div(that: `L⋅T⁻²`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻¹`) = `L⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`L⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻²`.times(that: `L⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻²⋅M`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻²⋅M`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`M⋅T⁻³`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `M⋅T⁻²`.div(that: `M⋅T⁻³`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`L²⋅T⁻¹`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻²`.times(that: `L²⋅T⁻¹`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻²⋅T⋅I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻²⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻²⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `M⋅T⁻²`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻¹⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻¹⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻¹⋅M`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻¹⋅M`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻¹⋅T⋅I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⁻²`>) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻²`.div(that: `L⁻²`) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`M⋅T⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻²`.div(that: `M⋅T⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `I`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `M⋅T⁻²`.times(that: `M⁻¹⋅T²⋅I`) = `I`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `L`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `M⋅T⁻²`.times(that: `L⋅M⁻¹⋅T²`) = `L`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻²`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻²`.div(that: Quan<`T⁻²`>) = `M`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻²`.div(that: `T⁻²`) = `M`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻²`>, that: Quan<`T⁻²`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `M⋅T⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `M⋅T⁻²`.times(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T2_Multiply_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue * that.siValue) }


typealias `M⋅T⁻³` = L0A0M1I0Theta0N0J0_per_T3
inline class L0A0M1I0Theta0N0J0_per_T3(internal val underlying: Double) : Quan<`M⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "kg⋅s⁻³"

    override fun new(siValue: Double) = `M⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `M⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `M⋅T⁻³`(-underlying)

    override operator fun plus(that: `M⋅T⁻³`) = `M⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `M⋅T⁻³`) = `M⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `M⋅T⁻³`) = `M⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `M⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `M⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `M⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M⋅T⁻³` && this.siValue == other.siValue
}


typealias `HeatFluxDensity` = `M⋅T⁻³`

typealias `Irradiance` = `M⋅T⁻³`

typealias `EnergyFluxDensity` = `M⋅T⁻³`

@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻³`.div(that: `Dimensionless`) = `M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`M⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `M⋅T⁻³`.div(that: `M⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻³`.times(that: `Dimensionless`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻³`.div(that: `L`) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻³`.times(that: Quan<`L`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻³`.times(that: `L`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `M⋅T⁻³`.times(that: Quan<`T`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `M⋅T⁻³`.times(that: `T`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻³`>, that: Quan<`T`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`T⁻¹`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻³`.div(that: `T⁻¹`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`T⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A2M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`∠²`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻³`.div(that: `∠²`) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A2M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`∠²`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L²⋅M⋅T⁻³`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `M⋅T⁻³`.div(that: `L²⋅M⋅T⁻³`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `M⋅T⁻³`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻³`.times(that: Quan<`L²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻³`.times(that: `L²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻³`.div(that: `L⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⋅T⁻²`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻³`.div(that: `L⋅T⁻²`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⋅T⁻³`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `M⋅T⁻³`.div(that: `L⋅T⁻³`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻³`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `M⋅T⁻³`.div(that: `L⋅M⋅T⁻³`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻¹`) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻³`.times(that: Quan<`L⁻¹`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻³`.times(that: `L⁻¹`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻²⋅M`>) = `L²⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻²⋅M`) = `L²⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L²⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`M⋅T⁻²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻³`.div(that: `M⋅T⁻²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0N0J0_per_T3Theta1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0N0J0_per_T3Theta1_concrete")
operator fun `M⋅T⁻³`.div(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1I0N0J0_per_T3Theta1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻²⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻²⋅I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `M⋅T⁻³`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻¹⋅I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻¹⋅I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L²⋅T⁻³`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `M⋅T⁻³`.div(that: `L²⋅T⁻³`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M`>) = `L⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻¹⋅M`) = `L⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻²`>) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻²`) = `L²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`M⋅T⁻¹`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻³`.div(that: `M⋅T⁻¹`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻³`) = `L`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`L⁻¹⋅Θ`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `M⋅T⁻³`.div(that: `L⁻¹⋅Θ`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `M⋅T⁻³`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `M⋅T⁻³`.times(that: `L⋅M⁻¹⋅T²`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`T⁻²`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻³`.div(that: `T⁻²`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`T⁻²`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `M⋅T⁻³`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `L⁻²⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `M⋅T⁻³`.times(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `L⁻²⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Multiply_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻³`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `L⁻²⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `M⋅T⁻³`.div(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `∠²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `M⋅T⁻³`.div(that: `∠⁻²⋅M⋅T⁻³`) = `∠²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T3_Divide_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`M⋅T⁻³`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `∠²`(this.siValue / that.siValue) }


typealias `L⋅M⋅T⁻³⋅Θ⁻¹` = L1A0M1I0N0J0_per_T3Theta1
inline class L1A0M1I0N0J0_per_T3Theta1(internal val underlying: Double) : Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅kg⋅s⁻³⋅K⁻¹"

    override fun new(siValue: Double) = `L⋅M⋅T⁻³⋅Θ⁻¹`(siValue)

    override operator fun unaryPlus() = `L⋅M⋅T⁻³⋅Θ⁻¹`(+underlying)
    override operator fun unaryMinus() = `L⋅M⋅T⁻³⋅Θ⁻¹`(-underlying)

    override operator fun plus(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = if (this > that) this else that

    override val abs get() = `L⋅M⋅T⁻³⋅Θ⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅M⋅T⁻³⋅Θ⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅M⋅T⁻³⋅Θ⁻¹` && this.siValue == other.siValue
}


typealias `ThermalConductivity` = `L⋅M⋅T⁻³⋅Θ⁻¹`

@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: `Dimensionless`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L1A0M1I0N0J0_per_T3Theta1_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L1A0M1I0N0J0_per_T3Theta1_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L1A0M1I0N0J0_per_T3Theta1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.times(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.times(that: `Dimensionless`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.times(that: Quan<`Θ`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.times(that: `Θ`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_L0A0M0T0I0Theta1N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`Θ`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: Quan<`L⋅M⋅T⁻³`>) = `Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: `L⋅M⋅T⁻³`) = `Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: Quan<`Θ⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.div(that: `Θ⁻¹`) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Divide_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.times(that: Quan<`L⁻¹⋅Θ`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻³⋅Θ⁻¹`.times(that: `L⁻¹⋅Θ`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1I0N0J0_per_T3Theta1_Multiply_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L²⋅T⁻¹` = L2A0M0I0Theta0N0J0_per_T1
inline class L2A0M0I0Theta0N0J0_per_T1(internal val underlying: Double) : Quan<`L²⋅T⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅s⁻¹"

    override fun new(siValue: Double) = `L²⋅T⁻¹`(siValue)

    override operator fun unaryPlus() = `L²⋅T⁻¹`(+underlying)
    override operator fun unaryMinus() = `L²⋅T⁻¹`(-underlying)

    override operator fun plus(that: `L²⋅T⁻¹`) = `L²⋅T⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅T⁻¹`) = `L²⋅T⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅T⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅T⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅T⁻¹`) = `L²⋅T⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅T⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L²⋅T⁻¹`) = if (this > that) this else that

    override val abs get() = `L²⋅T⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅T⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅T⁻¹` && this.siValue == other.siValue
}


typealias `KinematicViscosity` = `L²⋅T⁻¹`

typealias `ThermalDiffusivity` = `L²⋅T⁻¹`

typealias `DiffusionCoefficient` = `L²⋅T⁻¹`

typealias `SpecificAngularMomentum` = `L²⋅T⁻¹`

@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`Dimensionless`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻¹`.div(that: `Dimensionless`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L²⋅T⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L²⋅T⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`Dimensionless`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻¹`.times(that: `Dimensionless`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`M`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻¹`.times(that: `M`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`M`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`T`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻¹`.div(that: `T`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`T`>) = `L²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻¹`.times(that: `T`) = `L²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`T⁻¹`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `T⁻¹`) = `L²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`T⁻¹`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻¹`.times(that: `T⁻¹`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻¹⋅M⋅T⁻²`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`T⋅I`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L²⋅T⁻¹`.times(that: `T⋅I`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅T⁻¹`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L²⋅T⁻²`>) = `T`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L²⋅T⁻²`) = `T`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L⋅T⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L⋅T⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L³⋅T⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻³`>) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L⋅M⋅T⁻³`) = `L⋅M⁻¹⋅T²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L⋅M⁻¹⋅T²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L⁻¹`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L⁻¹`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻¹`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻¹`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻²⋅M`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻²⋅M`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻³⋅M`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻³⋅M`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L³⋅M⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L³⋅M⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`M⋅T⁻²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻¹`.times(that: `M⋅T⁻²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻²⋅T⋅I`>) = `I`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻²⋅T⋅I`) = `I`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻³⋅T⋅I`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻³⋅T⋅I`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I0Theta0N0J1_per_L2_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻²⋅T⋅J`>) = `J`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I0Theta0N0J1_per_L2_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻²⋅T⋅J`) = `J`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T1I0Theta0N0J1_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻²⋅T⋅J`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `M⁻¹⋅T⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻¹⋅M`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻¹⋅M`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`L⁻²`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅T⁻¹`.times(that: `L⁻²`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`M⋅T⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻¹`.times(that: `M⋅T⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `M⁻¹⋅T²⋅I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L⋅M⁻¹⋅T²`>) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L⋅M⁻¹⋅T²`) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻¹`.times(that: Quan<`T⁻²`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻¹`.times(that: `T⁻²`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`T⁻²`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L²⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L²⋅T⁻¹`.div(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T1_Divide_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }


typealias `L⁻¹⋅M⋅T⁻¹` = A0M1I0Theta0N0J0_per_L1T1
inline class A0M1I0Theta0N0J0_per_L1T1(internal val underlying: Double) : Quan<`L⁻¹⋅M⋅T⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹⋅kg⋅s⁻¹"

    override fun new(siValue: Double) = `L⁻¹⋅M⋅T⁻¹`(siValue)

    override operator fun unaryPlus() = `L⁻¹⋅M⋅T⁻¹`(+underlying)
    override operator fun unaryMinus() = `L⁻¹⋅M⋅T⁻¹`(-underlying)

    override operator fun plus(that: `L⁻¹⋅M⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹⋅M⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹⋅M⋅T⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹⋅M⋅T⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹⋅M⋅T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹⋅M⋅T⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹⋅M⋅T⁻¹`) = if (this > that) this else that

    override val abs get() = `L⁻¹⋅M⋅T⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹⋅M⋅T⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹⋅M⋅T⁻¹` && this.siValue == other.siValue
}


typealias `DynamicViscosity` = `L⁻¹⋅M⋅T⁻¹`

@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`Dimensionless`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `Dimensionless`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`Dimensionless`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `Dimensionless`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`T`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `T`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`T`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `T`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`T⁻¹`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `T⁻¹`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`T⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `T⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `T`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻¹⋅M⋅T⁻²`) = `T`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L²⋅T⁻²`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L²⋅T⁻²`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L²`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L²`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L²`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L³`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L³`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L³`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⋅T⁻¹`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L⋅T⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L⋅T⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L³⋅T⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L³⋅T⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L⋅T⁻²`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L⋅T⁻²`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻¹`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⋅M⋅T⁻¹`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻¹`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻²⋅M`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻²⋅M`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻³⋅M`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻³⋅M`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L³⋅M⁻¹`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L³⋅M⁻¹`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L²⋅T⁻¹`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L²⋅T⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L²⋅T⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻²⋅T⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻³⋅T⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `M⁻¹⋅T⋅I`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻¹⋅M`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻¹⋅T⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⁻²`>) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⁻²`) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`M⋅T⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `M⋅T⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `M⁻¹⋅T²⋅I`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `T`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L⋅M⁻¹⋅T²`) = `T`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `L³⋅T⁻¹⋅N⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: Quan<`T⁻²`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻¹`.times(that: `T⁻²`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻¹`>, that: Quan<`T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L⁻²⋅T⋅I` = A0M0T1I1Theta0N0J0_per_L2
inline class A0M0T1I1Theta0N0J0_per_L2(internal val underlying: Double) : Quan<`L⁻²⋅T⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅s⋅A"

    override fun new(siValue: Double) = `L⁻²⋅T⋅I`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅T⋅I`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅T⋅I`(-underlying)

    override operator fun plus(that: `L⁻²⋅T⋅I`) = `L⁻²⋅T⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅T⋅I`) = `L⁻²⋅T⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅T⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅T⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅T⋅I`) = `L⁻²⋅T⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅T⋅I`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅T⋅I`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅T⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅T⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅T⋅I` && this.siValue == other.siValue
}


typealias `ElectricDisplacementField` = `L⁻²⋅T⋅I`

typealias `PolarizationDensity` = `L⁻²⋅T⋅I`

@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `Dimensionless`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻²⋅T⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻²⋅T⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `Dimensionless`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`T`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `T`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`T`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`T⁻¹`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `T⁻¹`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`T⋅I`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `T⋅I`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`T⋅I`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L²`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L²`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L²`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L⋅T⁻¹`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L⋅T⁻¹`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L⁻¹`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L⁻¹`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻²⋅M`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻²⋅M`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L²⋅T⁻¹`>) = `I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L²⋅T⁻¹`) = `I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻³⋅T⋅I`) = `L`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻²⋅I`>) = `T`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻²⋅I`) = `T`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `M⁻¹⋅T⋅I`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `M⁻¹⋅T⋅I`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻¹⋅T⋅I`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⁻²`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⁻²`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⁻²`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `M⁻¹⋅T²⋅I`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅T⋅I`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅T⋅I`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅T⋅I`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅T⋅I`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅I`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }


typealias `L⁻³⋅T⋅I` = A0M0T1I1Theta0N0J0_per_L3
inline class A0M0T1I1Theta0N0J0_per_L3(internal val underlying: Double) : Quan<`L⁻³⋅T⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻³⋅s⋅A"

    override fun new(siValue: Double) = `L⁻³⋅T⋅I`(siValue)

    override operator fun unaryPlus() = `L⁻³⋅T⋅I`(+underlying)
    override operator fun unaryMinus() = `L⁻³⋅T⋅I`(-underlying)

    override operator fun plus(that: `L⁻³⋅T⋅I`) = `L⁻³⋅T⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻³⋅T⋅I`) = `L⁻³⋅T⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻³⋅T⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻³⋅T⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻³⋅T⋅I`) = `L⁻³⋅T⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻³⋅T⋅I`) = if (this < that) this else that
    override infix fun max(that: `L⁻³⋅T⋅I`) = if (this > that) this else that

    override val abs get() = `L⁻³⋅T⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻³⋅T⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻³⋅T⋅I` && this.siValue == other.siValue
}


typealias `ElectricChargeDensity` = `L⁻³⋅T⋅I`

@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`Dimensionless`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `Dimensionless`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`L⁻³⋅T⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `L⁻³⋅T⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`Dimensionless`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `Dimensionless`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L²`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L²`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L²`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L³`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L³`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L³`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L⋅T⁻¹`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L⋅T⁻¹`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L³⋅T⁻¹`>) = `I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L³⋅T⁻¹`) = `I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`L⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `L⁻¹`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`L⁻³⋅M`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `L⁻³⋅M`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L³⋅M⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L³⋅M⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L²⋅T⁻¹`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L²⋅T⁻¹`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `L⁻²⋅T⋅I`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `M⁻¹⋅T⋅I`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `L⁻¹⋅T⋅I`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻³⋅T⋅I`.div(that: Quan<`L⁻²`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻³⋅T⋅I`.div(that: `L⁻²`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `M⁻¹⋅T²⋅I`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻³⋅T⋅I`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻³⋅T⋅I`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L3_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅T⋅I`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }


typealias `L⁻²⋅I` = A0M0T0I1Theta0N0J0_per_L2
inline class A0M0T0I1Theta0N0J0_per_L2(internal val underlying: Double) : Quan<`L⁻²⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅A"

    override fun new(siValue: Double) = `L⁻²⋅I`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅I`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅I`(-underlying)

    override operator fun plus(that: `L⁻²⋅I`) = `L⁻²⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅I`) = `L⁻²⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅I`) = `L⁻²⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅I`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅I`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅I` && this.siValue == other.siValue
}


typealias `ElectricCurrentDensity` = `L⁻²⋅I`

@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅I`.div(that: `Dimensionless`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⁻²⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅I`.div(that: `L⁻²⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅I`.times(that: `Dimensionless`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`L`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅I`.times(that: `L`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`T`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻²⋅I`.times(that: `T`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`T`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`I`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⁻²⋅I`.div(that: `I`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`I`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`T⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅I`.div(that: `T⁻¹`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅I`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻²⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`L²`>) = `I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅I`.times(that: `L²`) = `I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L²`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅I`.div(that: `L⋅T⁻¹`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⁻¹`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅I`.div(that: `L⁻¹`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⁻²⋅T⋅I`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅I`.div(that: `L⁻²⋅T⋅I`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L⁻²⋅I`.div(that: `L⁻³⋅T⋅I`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻²⋅I`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅I`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻²⋅I`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⁻¹⋅I`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻²⋅I`.div(that: `L⁻¹⋅I`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻²⋅I`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⁻²`>) = `I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅I`.div(that: `L⁻²`) = `I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⁻²`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻²⋅I`.times(that: `M⁻¹⋅T²⋅I`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻²⋅I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅I`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅I`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻²⋅I`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻²⋅I`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L2_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻²⋅I`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }


typealias `L⁻³⋅M⁻¹⋅T³⋅I²` = A0T3I2Theta0N0J0_per_L3M1
inline class A0T3I2Theta0N0J0_per_L3M1(internal val underlying: Double) : Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻³⋅kg⁻¹⋅s³⋅A²"

    override fun new(siValue: Double) = `L⁻³⋅M⁻¹⋅T³⋅I²`(siValue)

    override operator fun unaryPlus() = `L⁻³⋅M⁻¹⋅T³⋅I²`(+underlying)
    override operator fun unaryMinus() = `L⁻³⋅M⁻¹⋅T³⋅I²`(-underlying)

    override operator fun plus(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = if (this < that) this else that
    override infix fun max(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = if (this > that) this else that

    override val abs get() = `L⁻³⋅M⁻¹⋅T³⋅I²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻³⋅M⁻¹⋅T³⋅I²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻³⋅M⁻¹⋅T³⋅I²` && this.siValue == other.siValue
}


typealias `ElectricalConductivity` = `L⁻³⋅M⁻¹⋅T³⋅I²`

@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`Dimensionless`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `Dimensionless`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`Dimensionless`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `Dimensionless`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`T`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `T`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`T`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`T⁻¹`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `T⁻¹`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L⋅T⁻¹`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L⋅T⁻¹`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻³⋅N`>) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻³⋅N`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L³⋅N⁻¹`>) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L³⋅N⁻¹`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L²⋅T⁻¹`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L²⋅T⁻¹`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻³⋅T⋅I`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻³⋅T⋅I`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0T3I2Theta0J0_per_M1N1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = `L⁻³⋅N`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0T3I2Theta0J0_per_M1N1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = `L⁻³⋅N`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0T3I2Theta0J0_per_M1N1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = thiz.run { `L⁻³⋅N`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.div(that: `M⁻¹⋅T²⋅I`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T³⋅I²`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("A0T3I2Theta0N0J0_per_L3M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }


typealias `L³⋅M⋅T⁻³⋅I⁻²` = L3A0M1Theta0N0J0_per_T3I2
inline class L3A0M1Theta0N0J0_per_T3I2(internal val underlying: Double) : Quan<`L³⋅M⋅T⁻³⋅I⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m³⋅kg⋅s⁻³⋅A⁻²"

    override fun new(siValue: Double) = `L³⋅M⋅T⁻³⋅I⁻²`(siValue)

    override operator fun unaryPlus() = `L³⋅M⋅T⁻³⋅I⁻²`(+underlying)
    override operator fun unaryMinus() = `L³⋅M⋅T⁻³⋅I⁻²`(-underlying)

    override operator fun plus(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L³⋅M⋅T⁻³⋅I⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L³⋅M⋅T⁻³⋅I⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L³⋅M⋅T⁻³⋅I⁻²`) = if (this < that) this else that
    override infix fun max(that: `L³⋅M⋅T⁻³⋅I⁻²`) = if (this > that) this else that

    override val abs get() = `L³⋅M⋅T⁻³⋅I⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L³⋅M⋅T⁻³⋅I⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L³⋅M⋅T⁻³⋅I⁻²` && this.siValue == other.siValue
}


typealias `Resistivity` = `L³⋅M⋅T⁻³⋅I⁻²`

@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`Dimensionless`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: `Dimensionless`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`Dimensionless`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `Dimensionless`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: `L`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`T⋅I`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `T⋅I`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`T⋅I`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L⋅T⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: `L⋅T⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L²⋅T⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: `L²⋅T⁻¹`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻²⋅T⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻³⋅T⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻³⋅T⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻²⋅I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻²⋅I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_L0A0T3I2Theta0J0_per_M1N1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_L0A0T3I2Theta0J0_per_M1N1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_L0A0T3I2Theta0J0_per_M1N1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `T`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `T`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.div(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Divide_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻¹⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻¹⋅I`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻¹⋅T⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L³⋅M⋅T⁻³⋅I⁻²`.times(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T3I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }


typealias `M⁻¹⋅T³⋅I²⋅N⁻¹` = L0A0T3I2Theta0J0_per_M1N1
inline class L0A0T3I2Theta0J0_per_M1N1(internal val underlying: Double) : Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "kg⁻¹⋅s³⋅A²⋅mol⁻¹"

    override fun new(siValue: Double) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(siValue)

    override operator fun unaryPlus() = `M⁻¹⋅T³⋅I²⋅N⁻¹`(+underlying)
    override operator fun unaryMinus() = `M⁻¹⋅T³⋅I²⋅N⁻¹`(-underlying)

    override operator fun plus(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = if (this < that) this else that
    override infix fun max(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = if (this > that) this else that

    override val abs get() = `M⁻¹⋅T³⋅I²⋅N⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M⁻¹⋅T³⋅I²⋅N⁻¹` && this.siValue == other.siValue
}


typealias `MolarConductivity` = `M⁻¹⋅T³⋅I²⋅N⁻¹`

@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: Quan<`Dimensionless`>) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: `Dimensionless`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L0A0T3I2Theta0J0_per_M1N1_generic")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L0A0T3I2Theta0J0_per_M1N1_concrete")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: `M⁻¹⋅T³⋅I²⋅N⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L0A0T3I2Theta0J0_per_M1N1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>, that: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.times(that: Quan<`Dimensionless`>) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T3I2Theta0J0_per_M1N1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.times(that: `Dimensionless`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.times(that: Quan<`L⁻³⋅N`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0T3I2Theta0J0_per_M1N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.times(that: `L⁻³⋅N`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: Quan<`L³⋅N⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: `L³⋅N⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L³⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L³⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L³⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T3I2Theta0J0_per_M1N1_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `M⁻¹⋅T³⋅I²⋅N⁻¹`.div(that: `L³⋅T⁻¹⋅N⁻¹`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("L0A0T3I2Theta0J0_per_M1N1_Divide_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T³⋅I²⋅N⁻¹`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }


typealias `L⁻³⋅M⁻¹⋅T⁴⋅I²` = A0T4I2Theta0N0J0_per_L3M1
inline class A0T4I2Theta0N0J0_per_L3M1(internal val underlying: Double) : Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻³⋅kg⁻¹⋅s⁴⋅A²"

    override fun new(siValue: Double) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(siValue)

    override operator fun unaryPlus() = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(+underlying)
    override operator fun unaryMinus() = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(-underlying)

    override operator fun plus(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = if (this < that) this else that
    override infix fun max(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = if (this > that) this else that

    override val abs get() = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻³⋅M⁻¹⋅T⁴⋅I²` && this.siValue == other.siValue
}


typealias `Permittivity` = `L⁻³⋅M⁻¹⋅T⁴⋅I²`

@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`Dimensionless`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: `Dimensionless`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`Dimensionless`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `Dimensionless`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `L`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`T`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: `T`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`T`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`T⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `T⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L²⋅T⁻²`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `L²⋅T⁻²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L⋅T⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `L⋅T⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L⋅T⁻²`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `L⋅T⁻²`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`L⁻¹`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: `L⁻¹`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `T`(this.siValue / that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `T`(this.siValue / that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `T`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `T`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `L⁻³⋅M⁻¹⋅T⁴⋅I²`.times(that: `L³⋅T⁻¹⋅N⁻¹`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("A0T4I2Theta0N0J0_per_L3M1_Multiply_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun times(thiz: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue) }


typealias `L⋅M⋅T⁻²⋅I⁻²` = L1A0M1Theta0N0J0_per_T2I2
inline class L1A0M1Theta0N0J0_per_T2I2(internal val underlying: Double) : Quan<`L⋅M⋅T⁻²⋅I⁻²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅kg⋅s⁻²⋅A⁻²"

    override fun new(siValue: Double) = `L⋅M⋅T⁻²⋅I⁻²`(siValue)

    override operator fun unaryPlus() = `L⋅M⋅T⁻²⋅I⁻²`(+underlying)
    override operator fun unaryMinus() = `L⋅M⋅T⁻²⋅I⁻²`(-underlying)

    override operator fun plus(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⋅M⋅T⁻²⋅I⁻²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⋅M⋅T⁻²⋅I⁻²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅M⋅T⁻²⋅I⁻²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅M⋅T⁻²⋅I⁻²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L⋅M⋅T⁻²⋅I⁻²`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅M⋅T⁻²⋅I⁻²`) = if (this < that) this else that
    override infix fun max(that: `L⋅M⋅T⁻²⋅I⁻²`) = if (this > that) this else that

    override val abs get() = `L⋅M⋅T⁻²⋅I⁻²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅M⋅T⁻²⋅I⁻²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅M⋅T⁻²⋅I⁻²` && this.siValue == other.siValue
}


typealias `MagneticPermeability` = `L⋅M⋅T⁻²⋅I⁻²`

@JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.div(that: `Dimensionless`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.div(that: `L⋅M⋅T⁻²⋅I⁻²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: `Dimensionless`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: `L`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: `I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⋅T⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: `L⋅T⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.div(that: Quan<`L⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.div(that: `L⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L²⋅T⁻¹`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: `L²⋅T⁻¹`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⁻¹⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: `L⁻¹⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L2A0M0T0I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L²⋅I`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L2A0M0T0I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: `L²⋅I`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_L2A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L²⋅I`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻²`.times(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I2_Multiply_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻²`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }


typealias `L⁻¹⋅M⁻¹⋅T²⋅I²` = A0T2I2Theta0N0J0_per_L1M1
inline class A0T2I2Theta0N0J0_per_L1M1(internal val underlying: Double) : Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹⋅kg⁻¹⋅s²⋅A²"

    override fun new(siValue: Double) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(siValue)

    override operator fun unaryPlus() = `L⁻¹⋅M⁻¹⋅T²⋅I²`(+underlying)
    override operator fun unaryMinus() = `L⁻¹⋅M⁻¹⋅T²⋅I²`(-underlying)

    override operator fun plus(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = if (this > that) this else that

    override val abs get() = `L⁻¹⋅M⁻¹⋅T²⋅I²`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹⋅M⁻¹⋅T²⋅I²` && this.siValue == other.siValue
}


typealias `MagneticSusceptibility` = `L⁻¹⋅M⁻¹⋅T²⋅I²`

@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`Dimensionless`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `Dimensionless`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`Dimensionless`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: `Dimensionless`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L²⋅T⁻²`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L²⋅T⁻²`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⋅T⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⋅T⁻²`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⋅T⁻²`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L⁻¹`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: `L⁻¹`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L²⋅T⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: `L⋅M⋅T⁻²⋅I⁻²`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻¹⋅I`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻¹⋅I`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `M⁻¹⋅T⋅I`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻¹⋅T⋅I`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `M⁻¹⋅T²⋅I`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L`(this.siValue / that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L`(this.siValue / that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `I`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `I`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅M⁻¹⋅T²⋅I²`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("A0T2I2Theta0N0J0_per_L1M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }


typealias `L⋅M⋅T⁻³⋅I⁻¹` = L1A0M1Theta0N0J0_per_T3I1
inline class L1A0M1Theta0N0J0_per_T3I1(internal val underlying: Double) : Quan<`L⋅M⋅T⁻³⋅I⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅kg⋅s⁻³⋅A⁻¹"

    override fun new(siValue: Double) = `L⋅M⋅T⁻³⋅I⁻¹`(siValue)

    override operator fun unaryPlus() = `L⋅M⋅T⁻³⋅I⁻¹`(+underlying)
    override operator fun unaryMinus() = `L⋅M⋅T⁻³⋅I⁻¹`(-underlying)

    override operator fun plus(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅M⋅T⁻³⋅I⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅M⋅T⁻³⋅I⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅M⋅T⁻³⋅I⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L⋅M⋅T⁻³⋅I⁻¹`) = if (this > that) this else that

    override val abs get() = `L⋅M⋅T⁻³⋅I⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅M⋅T⁻³⋅I⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅M⋅T⁻³⋅I⁻¹` && this.siValue == other.siValue
}


typealias `ElectricFieldStrength` = `L⋅M⋅T⁻³⋅I⁻¹`

@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `Dimensionless`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `Dimensionless`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `L`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`T`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `T`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`T`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`I`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `I`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`I`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`T⁻¹`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `T⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`T⋅I`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `T⋅I`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⋅T⁻¹`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⋅T⁻¹`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻²⋅T⋅I`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⁻²⋅I`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⁻²⋅I`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻²⋅I`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻²⋅I`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⁻¹⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⁻¹⋅I`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻¹⋅I`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻¹⋅I`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `M⁻¹⋅T⋅I`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.times(that: `M⁻¹⋅T²⋅I`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻³⋅I⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T3I1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }


typealias `L⁻¹⋅I` = A0M0T0I1Theta0N0J0_per_L1
inline class A0M0T0I1Theta0N0J0_per_L1(internal val underlying: Double) : Quan<`L⁻¹⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹⋅A"

    override fun new(siValue: Double) = `L⁻¹⋅I`(siValue)

    override operator fun unaryPlus() = `L⁻¹⋅I`(+underlying)
    override operator fun unaryMinus() = `L⁻¹⋅I`(-underlying)

    override operator fun plus(that: `L⁻¹⋅I`) = `L⁻¹⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹⋅I`) = `L⁻¹⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹⋅I`) = `L⁻¹⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹⋅I`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹⋅I`) = if (this > that) this else that

    override val abs get() = `L⁻¹⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹⋅I` && this.siValue == other.siValue
}


typealias `Magnetization` = `L⁻¹⋅I`

@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`Dimensionless`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅I`.div(that: `Dimensionless`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻¹⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻¹⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`Dimensionless`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅I`.times(that: `Dimensionless`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅I`.div(that: `L`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L`>) = `I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅I`.times(that: `L`) = `I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`T`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅I`.times(that: `T`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`T`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`I`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⁻¹⋅I`.div(that: `I`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`I`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`T⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅I`.div(that: `T⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻¹⋅M⋅T⁻²`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻¹⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅I`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅I`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻¹⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L³`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅I`.times(that: `L³`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L³`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⋅T⁻¹`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻¹`>) = `I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻¹`) = `I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻¹`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L⁻¹`>) = `L⁻²⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅I`.times(that: `L⁻¹`) = `L⁻²⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L²⋅T⁻¹`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻²⋅T⋅I`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻³⋅T⋅I`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻²⋅I`>) = `L`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻²⋅I`) = `L`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⁻¹⋅I`.times(that: `L⋅M⋅T⁻²⋅I⁻²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅I`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅I`.div(that: `M⁻¹⋅T⋅I`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻¹⋅I`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻¹⋅T⋅I`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅I`.div(that: `M⁻¹⋅T²⋅I`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅I`.times(that: `M⁻¹⋅T²⋅I`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅I`.times(that: `L⋅M⁻¹⋅T²`) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅I`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅I`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅I`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L⁻¹⋅I`.div(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L⁻¹⋅I`.div(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I1Theta0N0J0_per_L1_Divide_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅I`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }


typealias `T⋅J` = L0A0M0T1I0Theta0N0J1
inline class L0A0M0T1I0Theta0N0J1(internal val underlying: Double) : Quan<`T⋅J`> {
    override val siValue get() = underlying
    override val abrev get() = "s⋅cd"

    override fun new(siValue: Double) = `T⋅J`(siValue)

    override operator fun unaryPlus() = `T⋅J`(+underlying)
    override operator fun unaryMinus() = `T⋅J`(-underlying)

    override operator fun plus(that: `T⋅J`) = `T⋅J`(this.underlying + that.underlying)
    override operator fun minus(that: `T⋅J`) = `T⋅J`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `T⋅J`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `T⋅J`(this.underlying / that.toDouble())
    override operator fun rem(that: `T⋅J`) = `T⋅J`(this.underlying % that.underlying)

    override infix fun min(that: `T⋅J`) = if (this < that) this else that
    override infix fun max(that: `T⋅J`) = if (this > that) this else that

    override val abs get() = `T⋅J`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `T⋅J`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `T⋅J` && this.siValue == other.siValue
}


typealias `LuminousEnergy` = `T⋅J`

@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⋅J`.div(that: Quan<`Dimensionless`>) = `T⋅J`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⋅J`.div(that: `Dimensionless`) = `T⋅J`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `T⋅J`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T1I0Theta0N0J1_generic")
operator fun `T⋅J`.div(that: Quan<`T⋅J`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T1I0Theta0N0J1_concrete")
operator fun `T⋅J`.div(that: `T⋅J`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T1I0Theta0N0J1_nonextension")
fun div(thiz: Quan<`T⋅J`>, that: Quan<`T⋅J`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `T⋅J`.times(that: Quan<`Dimensionless`>) = `T⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `T⋅J`.times(that: `Dimensionless`) = `T⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`T⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `T⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `T⋅J`.div(that: Quan<`T`>) = `J`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `T⋅J`.div(that: `T`) = `J`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅J`>, that: Quan<`T`>) = thiz.run { `J`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J1_generic")
operator fun `T⋅J`.div(that: Quan<`J`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J1_concrete")
operator fun `T⋅J`.div(that: `J`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L0A0M0T0I0Theta0N0J1_nonextension")
fun div(thiz: Quan<`T⋅J`>, that: Quan<`J`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `T⋅J`.times(that: Quan<`T⁻¹`>) = `J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `T⋅J`.times(that: `T⁻¹`) = `J`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`T⋅J`>, that: Quan<`T⁻¹`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `T⋅J`.div(that: Quan<`L²⋅M⋅T⁻²`>) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Divide_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `T⋅J`.div(that: `L²⋅M⋅T⁻²`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`T⋅J`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `T⋅J`.div(that: Quan<`L²`>) = `L⁻²⋅T⋅J`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `T⋅J`.div(that: `L²`) = `L⁻²⋅T⋅J`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`T⋅J`>, that: Quan<`L²`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_A0M0T1I0Theta0N0J1_per_L2_generic")
operator fun `T⋅J`.div(that: Quan<`L⁻²⋅T⋅J`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Divide_A0M0T1I0Theta0N0J1_per_L2_concrete")
operator fun `T⋅J`.div(that: `L⁻²⋅T⋅J`) = `L²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_A0M0T1I0Theta0N0J1_per_L2_nonextension")
fun div(thiz: Quan<`T⋅J`>, that: Quan<`L⁻²⋅T⋅J`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `T⋅J`.times(that: Quan<`L⁻²`>) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `T⋅J`.times(that: `L⁻²`) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`T⋅J`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue * that.siValue) }
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `T⋅J`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M0T1I0Theta0N0J1_Divide_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `T⋅J`.div(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M0T1I0Theta0N0J1_Divide_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun div(thiz: Quan<`T⋅J`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue / that.siValue) }


typealias `L⁻²⋅T⋅J` = A0M0T1I0Theta0N0J1_per_L2
inline class A0M0T1I0Theta0N0J1_per_L2(internal val underlying: Double) : Quan<`L⁻²⋅T⋅J`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅s⋅cd"

    override fun new(siValue: Double) = `L⁻²⋅T⋅J`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅T⋅J`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅T⋅J`(-underlying)

    override operator fun plus(that: `L⁻²⋅T⋅J`) = `L⁻²⋅T⋅J`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅T⋅J`) = `L⁻²⋅T⋅J`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅T⋅J`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅T⋅J`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅T⋅J`) = `L⁻²⋅T⋅J`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅T⋅J`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅T⋅J`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅T⋅J`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅T⋅J`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅T⋅J` && this.siValue == other.siValue
}


typealias `LuminousExposure` = `L⁻²⋅T⋅J`

@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅J`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅T⋅J`(this.siValue / that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅J`.div(that: `Dimensionless`) = `L⁻²⋅T⋅J`(this.siValue / that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue / that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0M0T1I0Theta0N0J1_per_L2_generic")
operator fun `L⁻²⋅T⋅J`.div(that: Quan<`L⁻²⋅T⋅J`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0M0T1I0Theta0N0J1_per_L2_concrete")
operator fun `L⁻²⋅T⋅J`.div(that: `L⁻²⋅T⋅J`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0M0T1I0Theta0N0J1_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`L⁻²⋅T⋅J`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅J`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅J`.times(that: `Dimensionless`) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue * that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅J`.div(that: Quan<`T`>) = `L⁻²⋅J`(this.siValue / that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅J`.div(that: `T`) = `L⁻²⋅J`(this.siValue / that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`T`>) = thiz.run { `L⁻²⋅J`(this.siValue / that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅T⋅J`.times(that: Quan<`T⁻¹`>) = `L⁻²⋅J`(this.siValue * that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅T⋅J`.times(that: `T⁻¹`) = `L⁻²⋅J`(this.siValue * that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻²⋅J`(this.siValue * that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J1_per_L2_generic")
operator fun `L⁻²⋅T⋅J`.div(that: Quan<`L⁻²⋅J`>) = `T`(this.siValue / that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J1_per_L2_concrete")
operator fun `L⁻²⋅T⋅J`.div(that: `L⁻²⋅J`) = `T`(this.siValue / that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J1_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`L⁻²⋅J`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅T⋅J`.times(that: Quan<`L²`>) = `T⋅J`(this.siValue * that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅T⋅J`.times(that: `L²`) = `T⋅J`(this.siValue * that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`L²`>) = thiz.run { `T⋅J`(this.siValue * that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²⋅T⋅J`.div(that: Quan<`M⋅T⁻²`>) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²⋅T⋅J`.div(that: `M⋅T⁻²`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻²⋅T⋅J`.times(that: Quan<`L²⋅T⁻¹`>) = `J`(this.siValue * that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻²⋅T⋅J`.times(that: `L²⋅T⁻¹`) = `J`(this.siValue * that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M0T1I0Theta0N0J1_generic")
operator fun `L⁻²⋅T⋅J`.div(that: Quan<`T⋅J`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M0T1I0Theta0N0J1_concrete")
operator fun `L⁻²⋅T⋅J`.div(that: `T⋅J`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_L0A0M0T1I0Theta0N0J1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`T⋅J`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻²⋅T⋅J`.div(that: Quan<`L⁻²`>) = `T⋅J`(this.siValue / that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻²⋅T⋅J`.div(that: `L⁻²`) = `T⋅J`(this.siValue / that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`L⁻²`>) = thiz.run { `T⋅J`(this.siValue / that.siValue) }
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `L⁻²⋅T⋅J`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `L⁻²⋅T⋅J`.div(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0M0T1I0Theta0N0J1_per_L2_Divide_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅T⋅J`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }


typealias `M⁻¹⋅T⋅I` = L0A0T1I1Theta0N0J0_per_M1
inline class L0A0T1I1Theta0N0J0_per_M1(internal val underlying: Double) : Quan<`M⁻¹⋅T⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "kg⁻¹⋅s⋅A"

    override fun new(siValue: Double) = `M⁻¹⋅T⋅I`(siValue)

    override operator fun unaryPlus() = `M⁻¹⋅T⋅I`(+underlying)
    override operator fun unaryMinus() = `M⁻¹⋅T⋅I`(-underlying)

    override operator fun plus(that: `M⁻¹⋅T⋅I`) = `M⁻¹⋅T⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `M⁻¹⋅T⋅I`) = `M⁻¹⋅T⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M⁻¹⋅T⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M⁻¹⋅T⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `M⁻¹⋅T⋅I`) = `M⁻¹⋅T⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `M⁻¹⋅T⋅I`) = if (this < that) this else that
    override infix fun max(that: `M⁻¹⋅T⋅I`) = if (this > that) this else that

    override val abs get() = `M⁻¹⋅T⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M⁻¹⋅T⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M⁻¹⋅T⋅I` && this.siValue == other.siValue
}


typealias `Exposure` = `M⁻¹⋅T⋅I`

@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅T⋅I`.div(that: Quan<`Dimensionless`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅T⋅I`.div(that: `Dimensionless`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `M⁻¹⋅T⋅I`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `M⁻¹⋅T⋅I`.div(that: `M⁻¹⋅T⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`Dimensionless`>) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `Dimensionless`) = `M⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`M`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `M`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`M`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`T`>) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `T`) = `M⁻¹⋅T²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`T`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⁻¹⋅T⋅I`.div(that: Quan<`T⁻¹`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⁻¹⋅T⋅I`.div(that: `T⁻¹`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`T⁻¹`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `M⋅T⁻²⋅I⁻¹`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻¹`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L²⋅M⋅T⁻¹`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L⁻²⋅M`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L⁻²⋅M`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L⁻³⋅M`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L⁻³⋅M`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `M⁻¹⋅T⋅I`.div(that: Quan<`L³⋅M⁻¹`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `M⁻¹⋅T⋅I`.div(that: `L³⋅M⁻¹`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L⁻²⋅T⋅I`) = `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻²⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `M⁻¹⋅T⋅I`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `M⁻¹⋅T⋅I`.div(that: `L⁻³⋅T⋅I`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L⁻¹⋅M`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L⁻¹⋅M`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L⁻¹⋅T⋅I`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`M⋅T⁻¹`>) = `I`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `M⋅T⁻¹`) = `I`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `M⁻¹⋅T⋅I`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `M⁻¹⋅T⋅I`.div(that: `M⁻¹⋅T²⋅I`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⁻¹⋅T⋅I`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⁻¹⋅T⋅I`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T1I1Theta0N0J0_per_M1_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅T⋅I`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }


typealias `L²⋅T⁻³` = L2A0M0I0Theta0N0J0_per_T3
inline class L2A0M0I0Theta0N0J0_per_T3(internal val underlying: Double) : Quan<`L²⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅s⁻³"

    override fun new(siValue: Double) = `L²⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `L²⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `L²⋅T⁻³`(-underlying)

    override operator fun plus(that: `L²⋅T⁻³`) = `L²⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅T⁻³`) = `L²⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅T⁻³`) = `L²⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `L²⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `L²⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅T⁻³` && this.siValue == other.siValue
}


typealias `AbsorbedDoseRate` = `L²⋅T⁻³`

@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `L²⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻³`.div(that: `Dimensionless`) = `L²⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`L²⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L²⋅T⁻³`.div(that: `L²⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻³`.times(that: `Dimensionless`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`L`>) = `L⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻³`.div(that: `L`) = `L⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅T⁻³`.times(that: Quan<`M`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻³`.times(that: `M`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`M`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅T⁻³`.times(that: Quan<`T`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅T⁻³`.times(that: `T`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`T`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`T⁻¹`>) = `L²⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻³`.div(that: `T⁻¹`) = `L²⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`L²⋅T⁻²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻³`.div(that: `L²⋅T⁻²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`L⋅T⁻¹`>) = `L⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻³`.div(that: `L⋅T⁻¹`) = `L⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`L⋅T⁻²`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻³`.div(that: `L⋅T⁻²`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`L⋅T⁻³`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L²⋅T⁻³`.div(that: `L⋅T⁻³`) = `L`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅T⁻³`.times(that: Quan<`L⁻¹`>) = `L⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅T⁻³`.times(that: `L⁻¹`) = `L⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅T⁻³`.times(that: Quan<`L⁻²⋅M`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅T⁻³`.times(that: `L⁻²⋅M`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L²⋅T⁻³`.times(that: Quan<`L⁻³⋅M`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L²⋅T⁻³`.times(that: `L⁻³⋅M`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`L³⋅M⁻¹`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L²⋅T⁻³`.div(that: `L³⋅M⁻¹`) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`L²⋅T⁻¹`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅T⁻³`.div(that: `L²⋅T⁻¹`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅T⁻³`.times(that: Quan<`L⁻¹⋅M`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅T⁻³`.times(that: `L⁻¹⋅M`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Multiply_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L²⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻³`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅T⁻³`.div(that: Quan<`T⁻²`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅T⁻³`.div(that: `T⁻²`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0I0Theta0N0J0_per_T3_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅T⁻³`>, that: Quan<`T⁻²`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }


typealias `L⁻¹⋅M` = A0M1T0I0Theta0N0J0_per_L1
inline class A0M1T0I0Theta0N0J0_per_L1(internal val underlying: Double) : Quan<`L⁻¹⋅M`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹⋅kg"

    override fun new(siValue: Double) = `L⁻¹⋅M`(siValue)

    override operator fun unaryPlus() = `L⁻¹⋅M`(+underlying)
    override operator fun unaryMinus() = `L⁻¹⋅M`(-underlying)

    override operator fun plus(that: `L⁻¹⋅M`) = `L⁻¹⋅M`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹⋅M`) = `L⁻¹⋅M`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹⋅M`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹⋅M`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹⋅M`) = `L⁻¹⋅M`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹⋅M`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹⋅M`) = if (this > that) this else that

    override val abs get() = `L⁻¹⋅M`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹⋅M`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹⋅M` && this.siValue == other.siValue
}


typealias `LinearMassDensity` = `L⁻¹⋅M`

@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`Dimensionless`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M`.div(that: `Dimensionless`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`L⁻¹⋅M`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M`.div(that: `L⁻¹⋅M`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`Dimensionless`>) = `L⁻¹⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M`.times(that: `Dimensionless`) = `L⁻¹⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`L`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M`.div(that: `L`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L`>) = `M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M`.times(that: `L`) = `M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`M`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M`.div(that: `M`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`M`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`T`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M`.div(that: `T`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`T`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`T⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M`.times(that: `T⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L²⋅T⁻²`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M`.times(that: `L²⋅T⁻²`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`L²`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M`.div(that: `L²`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L²`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L³`>) = `L²⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M`.times(that: `L³`) = `L²⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L³`>) = thiz.run { `L²⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L⋅T⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M`.times(that: `L⋅T⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L³⋅T⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M`.times(that: `L³⋅T⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L⋅T⁻²`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M`.times(that: `L⋅T⁻²`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L⋅T⁻³`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹⋅M`.times(that: `L⋅T⁻³`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`L⁻¹`>) = `M`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M`.div(that: `L⁻¹`) = `M`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⁻¹`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L⁻¹`>) = `L⁻²⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M`.times(that: `L⁻¹`) = `L⁻²⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻²⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`L⁻²⋅M`>) = `L`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M`.div(that: `L⁻²⋅M`) = `L`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`L⁻³⋅M`>) = `L²`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L⁻¹⋅M`.div(that: `L⁻³⋅M`) = `L²`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L³⋅M⁻¹`>) = `L²`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M`.times(that: `L³⋅M⁻¹`) = `L²`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L²`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L²⋅T⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M`.times(that: `L²⋅T⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⁻¹⋅M`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⁻¹⋅M`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M`.times(that: `M⁻¹⋅T⋅I`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L²⋅T⁻³`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹⋅M`.times(that: `L²⋅T⁻³`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`L⁻²`>) = `L⁻³⋅M`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M`.times(that: `L⁻²`) = `L⁻³⋅M`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻³⋅M`(this.siValue * that.siValue) }
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M`.times(that: Quan<`T⁻²`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M`.times(that: `T⁻²`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1T0I0Theta0N0J0_per_L1_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M`>, that: Quan<`T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }


typealias `L⁻¹⋅T⋅I` = A0M0T1I1Theta0N0J0_per_L1
inline class A0M0T1I1Theta0N0J0_per_L1(internal val underlying: Double) : Quan<`L⁻¹⋅T⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹⋅s⋅A"

    override fun new(siValue: Double) = `L⁻¹⋅T⋅I`(siValue)

    override operator fun unaryPlus() = `L⁻¹⋅T⋅I`(+underlying)
    override operator fun unaryMinus() = `L⁻¹⋅T⋅I`(-underlying)

    override operator fun plus(that: `L⁻¹⋅T⋅I`) = `L⁻¹⋅T⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹⋅T⋅I`) = `L⁻¹⋅T⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹⋅T⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹⋅T⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹⋅T⋅I`) = `L⁻¹⋅T⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹⋅T⋅I`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹⋅T⋅I`) = if (this > that) this else that

    override val abs get() = `L⁻¹⋅T⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹⋅T⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹⋅T⋅I` && this.siValue == other.siValue
}


typealias `LinearChargeDensity` = `L⁻¹⋅T⋅I`

@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`Dimensionless`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `Dimensionless`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻¹⋅T⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`Dimensionless`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `Dimensionless`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`T`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `T`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`T`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`T⁻¹`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `T⁻¹`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`T⋅I`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `T⋅I`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`T⋅I`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T4I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T4I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻²⋅M⁻¹⋅T⁴⋅I²`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T4I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻²⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻³⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L²`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L²`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L²`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L⋅T⁻¹`>) = `I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L⋅T⁻¹`) = `I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L³⋅T⁻¹`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L³⋅T⁻¹`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻¹`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻¹`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻¹`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L⁻¹`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻²⋅T⋅I`) = `L`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻³⋅T⋅I`) = `L²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T⁴⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻¹⋅I`>) = `T`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻¹⋅I`) = `T`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `M⁻¹⋅T⋅I`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `M⁻¹⋅T⋅I`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⁻¹⋅M`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⁻¹⋅M`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L⁻²`>) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L⁻²`) = `L⁻³⋅T⋅I`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `M⁻¹⋅T²⋅I`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅T⋅I`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅T⋅I`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅I²`(this.siValue / that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⁻¹⋅T⋅I`.times(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⁻¹⋅T⋅I`.times(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T1I1Theta0N0J0_per_L1_Multiply_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅T⋅I`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }


typealias `M⁻¹⋅N` = L0A0T0I0Theta0N1J0_per_M1
inline class L0A0T0I0Theta0N1J0_per_M1(internal val underlying: Double) : Quan<`M⁻¹⋅N`> {
    override val siValue get() = underlying
    override val abrev get() = "kg⁻¹⋅mol"

    override fun new(siValue: Double) = `M⁻¹⋅N`(siValue)

    override operator fun unaryPlus() = `M⁻¹⋅N`(+underlying)
    override operator fun unaryMinus() = `M⁻¹⋅N`(-underlying)

    override operator fun plus(that: `M⁻¹⋅N`) = `M⁻¹⋅N`(this.underlying + that.underlying)
    override operator fun minus(that: `M⁻¹⋅N`) = `M⁻¹⋅N`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M⁻¹⋅N`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M⁻¹⋅N`(this.underlying / that.toDouble())
    override operator fun rem(that: `M⁻¹⋅N`) = `M⁻¹⋅N`(this.underlying % that.underlying)

    override infix fun min(that: `M⁻¹⋅N`) = if (this < that) this else that
    override infix fun max(that: `M⁻¹⋅N`) = if (this > that) this else that

    override val abs get() = `M⁻¹⋅N`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M⁻¹⋅N`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M⁻¹⋅N` && this.siValue == other.siValue
}


typealias `Molality` = `M⁻¹⋅N`

@JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅N`.div(that: Quan<`Dimensionless`>) = `M⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅N`.div(that: `Dimensionless`) = `M⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`Dimensionless`>) = thiz.run { `M⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `M⁻¹⋅N`.div(that: Quan<`M⁻¹⋅N`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `M⁻¹⋅N`.div(that: `M⁻¹⋅N`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅N`.times(that: Quan<`Dimensionless`>) = `M⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅N`.times(that: `Dimensionless`) = `M⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`Dimensionless`>) = thiz.run { `M⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M1T0I0Theta0N0J0_generic")
operator fun `M⁻¹⋅N`.times(that: Quan<`M`>) = `N`(this.siValue * that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `M⁻¹⋅N`.times(that: `M`) = `N`(this.siValue * that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M1T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`M`>) = thiz.run { `N`(this.siValue * that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `M⁻¹⋅N`.times(that: Quan<`L⁻³⋅M`>) = `L⁻³⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `M⁻¹⋅N`.times(that: `L⁻³⋅M`) = `L⁻³⋅N`(this.siValue * that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L⁻³⋅N`(this.siValue * that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `M⁻¹⋅N`.div(that: Quan<`L³⋅M⁻¹`>) = `L⁻³⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `M⁻¹⋅N`.div(that: `L³⋅M⁻¹`) = `L⁻³⋅N`(this.siValue / that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L⁻³⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `M⁻¹⋅N`.div(that: Quan<`L⁻³⋅N`>) = `L³⋅M⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `M⁻¹⋅N`.div(that: `L⁻³⋅N`) = `L³⋅M⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Divide_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun div(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L³⋅M⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `M⁻¹⋅N`.times(that: Quan<`L³⋅N⁻¹`>) = `L³⋅M⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `M⁻¹⋅N`.times(that: `L³⋅N⁻¹`) = `L³⋅M⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L³⋅M⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L2A0M1I0J0_per_T2Theta1N1_generic")
operator fun `M⁻¹⋅N`.times(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L2A0M1I0J0_per_T2Theta1N1_concrete")
operator fun `M⁻¹⋅N`.times(that: `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`) = `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L2A0M1I0J0_per_T2Theta1N1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`>) = thiz.run { `L²⋅T⁻²⋅Θ⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L2A0M1I0Theta0J0_per_T2N1_generic")
operator fun `M⁻¹⋅N`.times(that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = `L²⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L2A0M1I0Theta0J0_per_T2N1_concrete")
operator fun `M⁻¹⋅N`.times(that: `L²⋅M⋅T⁻²⋅N⁻¹`) = `L²⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L2A0M1I0Theta0J0_per_T2N1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`L²⋅M⋅T⁻²⋅N⁻¹`>) = thiz.run { `L²⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `M⁻¹⋅N`.times(that: Quan<`M⋅N⁻¹`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `M⁻¹⋅N`.times(that: `M⋅N⁻¹`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M⁻¹⋅N`.times(that: Quan<`M⋅T⁻¹`>) = `T⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M⁻¹⋅N`.times(that: `M⋅T⁻¹`) = `T⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L0A0T0I0Theta0N1J0_per_M1_Multiply_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⁻¹⋅N`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `T⁻¹⋅N`(this.siValue * that.siValue) }


typealias `M⋅N⁻¹` = L0A0M1T0I0Theta0J0_per_N1
inline class L0A0M1T0I0Theta0J0_per_N1(internal val underlying: Double) : Quan<`M⋅N⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "kg⋅mol⁻¹"

    override fun new(siValue: Double) = `M⋅N⁻¹`(siValue)

    override operator fun unaryPlus() = `M⋅N⁻¹`(+underlying)
    override operator fun unaryMinus() = `M⋅N⁻¹`(-underlying)

    override operator fun plus(that: `M⋅N⁻¹`) = `M⋅N⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `M⋅N⁻¹`) = `M⋅N⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M⋅N⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M⋅N⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `M⋅N⁻¹`) = `M⋅N⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `M⋅N⁻¹`) = if (this < that) this else that
    override infix fun max(that: `M⋅N⁻¹`) = if (this > that) this else that

    override val abs get() = `M⋅N⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M⋅N⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M⋅N⁻¹` && this.siValue == other.siValue
}


typealias `MolarMass` = `M⋅N⁻¹`

@JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅N⁻¹`.div(that: Quan<`Dimensionless`>) = `M⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅N⁻¹`.div(that: `Dimensionless`) = `M⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `M⋅N⁻¹`.div(that: Quan<`M⋅N⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `M⋅N⁻¹`.div(that: `M⋅N⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅N⁻¹`.times(that: Quan<`Dimensionless`>) = `M⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅N⁻¹`.times(that: `Dimensionless`) = `M⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N1J0_generic")
operator fun `M⋅N⁻¹`.times(that: Quan<`N`>) = `M`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `M⋅N⁻¹`.times(that: `N`) = `M`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0M0T0I0Theta0N1J0_nonextension")
fun times(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`N`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M⋅N⁻¹`.times(that: Quan<`L²⋅T⁻²`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅N⁻¹`.times(that: `L²⋅T⁻²`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `M⋅N⁻¹`.times(that: Quan<`T⁻¹⋅N`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `M⋅N⁻¹`.times(that: `T⁻¹⋅N`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun times(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `M⋅N⁻¹`.div(that: Quan<`L⁻³⋅M`>) = `L³⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `M⋅N⁻¹`.div(that: `L⁻³⋅M`) = `L³⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L³⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `M⋅N⁻¹`.times(that: Quan<`L³⋅M⁻¹`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `M⋅N⁻¹`.times(that: `L³⋅M⁻¹`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `M⋅N⁻¹`.times(that: Quan<`L⁻³⋅N`>) = `L⁻³⋅M`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `M⋅N⁻¹`.times(that: `L⁻³⋅N`) = `L⁻³⋅M`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun times(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `L⁻³⋅M`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `M⋅N⁻¹`.div(that: Quan<`L³⋅N⁻¹`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `M⋅N⁻¹`.div(that: `L³⋅N⁻¹`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Divide_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `M⋅N⁻¹`.times(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `M⋅N⁻¹`.times(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅Θ⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `M⋅N⁻¹`.times(that: Quan<`M⁻¹⋅N`>) = `Dimensionless`(this.siValue * that.siValue)
// @JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `M⋅N⁻¹`.times(that: `M⁻¹⋅N`) = `Dimensionless`(this.siValue * that.siValue)
@JvmName("L0A0M1T0I0Theta0J0_per_N1_Multiply_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅N⁻¹`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `Dimensionless`(this.siValue * that.siValue) }


typealias `M⋅T⁻¹` = L0A0M1I0Theta0N0J0_per_T1
inline class L0A0M1I0Theta0N0J0_per_T1(internal val underlying: Double) : Quan<`M⋅T⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "kg⋅s⁻¹"

    override fun new(siValue: Double) = `M⋅T⁻¹`(siValue)

    override operator fun unaryPlus() = `M⋅T⁻¹`(+underlying)
    override operator fun unaryMinus() = `M⋅T⁻¹`(-underlying)

    override operator fun plus(that: `M⋅T⁻¹`) = `M⋅T⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `M⋅T⁻¹`) = `M⋅T⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `M⋅T⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `M⋅T⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `M⋅T⁻¹`) = `M⋅T⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `M⋅T⁻¹`) = if (this < that) this else that
    override infix fun max(that: `M⋅T⁻¹`) = if (this > that) this else that

    override val abs get() = `M⋅T⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `M⋅T⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `M⋅T⁻¹` && this.siValue == other.siValue
}


typealias `MassFlowRate` = `M⋅T⁻¹`

@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`Dimensionless`>) = `M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻¹`.div(that: `Dimensionless`) = `M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`M⋅T⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.div(that: `M⋅T⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`M⋅T⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`Dimensionless`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻¹`.times(that: `Dimensionless`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻¹`.div(that: `L`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`L`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻¹`.times(that: `L`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`M`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻¹`.div(that: `M`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`M`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`T`>) = `M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `M⋅T⁻¹`.div(that: `T`) = `M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`T`>) = `M`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `M⋅T⁻¹`.times(that: `T`) = `M`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`T`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`T⁻¹`>) = `M`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.div(that: `T⁻¹`) = `M`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`T⁻¹`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.times(that: `T⁻¹`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`T⋅I`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `M⋅T⁻¹`.div(that: `T⋅I`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻¹`.div(that: `M⋅T⁻²⋅I⁻¹`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`L²⋅T⁻²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻¹`.times(that: `L²⋅T⁻²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L²⋅T⁻²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N1J0_per_T1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`T⁻¹⋅N`>) = `M⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N1J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.div(that: `T⁻¹⋅N`) = `M⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M0I0Theta0N1J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`T⁻¹⋅N`>) = thiz.run { `M⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`L²`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `M⋅T⁻¹`.times(that: `L²`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L²`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⋅T⁻¹`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⋅T⁻¹`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`L⋅T⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.times(that: `L⋅T⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L³⋅T⁻¹`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`L⋅T⁻²`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻¹`.times(that: `L⋅T⁻²`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L1A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⋅T⁻²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⋅M⋅T⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L²⋅M⋅T⁻¹`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L²⋅M⋅T⁻¹`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⁻¹`>) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⁻¹`) = `L⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`L⁻¹`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻¹`.times(that: `L⁻¹`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⁻²⋅M`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⁻²⋅M`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⁻³⋅M`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⁻³⋅M`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`L³⋅M⁻¹`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `M⋅T⁻¹`.times(that: `L³⋅M⁻¹`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`M⋅T⁻²`>) = `T`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻¹`.div(that: `M⋅T⁻²`) = `T`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L²⋅T⁻¹`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L²⋅T⁻¹`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`L²⋅T⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `M⋅T⁻¹`.times(that: `L²⋅T⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⁻²⋅T⋅I`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⁻³⋅T⋅I`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⁻³⋅T⋅I`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `I`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `M⋅T⁻¹`.times(that: `M⁻¹⋅T⋅I`) = `I`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅M`>) = `L⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⁻¹⋅M`) = `L⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⁻¹⋅T⋅I`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T0I0Theta0N1J0_per_M1_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`M⁻¹⋅N`>) = `T⁻¹⋅N`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T0I0Theta0N1J0_per_M1_concrete")
operator fun `M⋅T⁻¹`.times(that: `M⁻¹⋅N`) = `T⁻¹⋅N`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T0I0Theta0N1J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`M⁻¹⋅N`>) = thiz.run { `T⁻¹⋅N`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0J0_per_N1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`M⋅N⁻¹`>) = `T⁻¹⋅N`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0J0_per_N1_concrete")
operator fun `M⋅T⁻¹`.div(that: `M⋅N⁻¹`) = `T⁻¹⋅N`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L0A0M1T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`M⋅N⁻¹`>) = thiz.run { `T⁻¹⋅N`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⁻²`>) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⁻²`) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `M⋅T⁻¹`.times(that: `M⁻¹⋅T²⋅I`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `M⋅T⁻¹`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `M⋅T⁻¹`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⁻³⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻³⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `M⋅T⁻¹`.times(that: Quan<`T⁻²`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `M⋅T⁻¹`.times(that: `T⁻²`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0A0M1I0Theta0N0J0_per_T1_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`M⋅T⁻¹`>, that: Quan<`T⁻²`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }


typealias `L²⋅I` = L2A0M0T0I1Theta0N0J0
inline class L2A0M0T0I1Theta0N0J0(internal val underlying: Double) : Quan<`L²⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅A"

    override fun new(siValue: Double) = `L²⋅I`(siValue)

    override operator fun unaryPlus() = `L²⋅I`(+underlying)
    override operator fun unaryMinus() = `L²⋅I`(-underlying)

    override operator fun plus(that: `L²⋅I`) = `L²⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅I`) = `L²⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅I`) = `L²⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅I`) = if (this < that) this else that
    override infix fun max(that: `L²⋅I`) = if (this > that) this else that

    override val abs get() = `L²⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅I` && this.siValue == other.siValue
}


typealias `MagneticDipoleMoment` = `L²⋅I`

@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅I`.div(that: Quan<`Dimensionless`>) = `L²⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅I`.div(that: `Dimensionless`) = `L²⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅I`.div(that: Quan<`L²⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅I`.div(that: `L²⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L²⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅I`.times(that: Quan<`Dimensionless`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅I`.times(that: `Dimensionless`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L²⋅I`.div(that: Quan<`I`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L²⋅I`.div(that: `I`) = `L²`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`I`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅I`.div(that: Quan<`L²⋅M⋅T⁻²`>) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅I`.div(that: `L²⋅M⋅T⁻²`) = `M⁻¹⋅T²⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `M⁻¹⋅T²⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L²⋅I`.div(that: Quan<`T⋅I`>) = `L²⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L²⋅I`.div(that: `T⋅I`) = `L²⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`T⋅I`>) = thiz.run { `L²⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅I`.times(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅I`.times(that: `M⋅T⁻²⋅I⁻¹`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Multiply_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun times(thiz: Quan<`L²⋅I`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅I`.div(that: Quan<`L²`>) = `I`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅I`.div(that: `L²`) = `I`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L²`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅I`.div(that: Quan<`L³`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅I`.div(that: `L³`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L³`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L3A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅I`.div(that: Quan<`L³⋅T⁻¹`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L3A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅I`.div(that: `L³⋅T⁻¹`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L3A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L³⋅T⁻¹`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅I`.div(that: Quan<`L²⋅M⋅T⁻¹`>) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅I`.div(that: `L²⋅M⋅T⁻¹`) = `M⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `M⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅I`.div(that: Quan<`L²⋅T⁻¹`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅I`.div(that: `L²⋅T⁻¹`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L2A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L²⋅T⁻¹`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L²⋅I`.times(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L²⋅I`.times(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Multiply_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun times(thiz: Quan<`L²⋅I`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅I`.div(that: Quan<`L⁻¹⋅I`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅I`.div(that: `L⁻¹⋅I`) = `L³`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅I`.div(that: Quan<`M⁻¹⋅T⋅I`>) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅I`.div(that: `M⁻¹⋅T⋅I`) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L²⋅I`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L³⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L²⋅I`.div(that: `L⁻¹⋅T⋅I`) = `L³⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L³⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅I`.times(that: Quan<`L⁻²`>) = `I`(this.siValue * that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅I`.times(that: `L⁻²`) = `I`(this.siValue * that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅I`>, that: Quan<`L⁻²`>) = thiz.run { `I`(this.siValue * that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L²⋅I`.div(that: Quan<`M⁻¹⋅T²⋅I`>) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L²⋅I`.div(that: `M⁻¹⋅T²⋅I`) = `L²⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L²⋅I`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L²⋅I`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹⋅M⁻¹⋅T²⋅I²`(this.siValue / that.siValue) }
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L²⋅I`.div(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M0T0I1Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L²⋅I`.div(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M0T0I1Theta0N0J0_Divide_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun div(thiz: Quan<`L²⋅I`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }


typealias `L⁻¹⋅M⋅T⁻³` = A0M1I0Theta0N0J0_per_L1T3
inline class A0M1I0Theta0N0J0_per_L1T3(internal val underlying: Double) : Quan<`L⁻¹⋅M⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹⋅kg⋅s⁻³"

    override fun new(siValue: Double) = `L⁻¹⋅M⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `L⁻¹⋅M⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `L⁻¹⋅M⋅T⁻³`(-underlying)

    override operator fun plus(that: `L⁻¹⋅M⋅T⁻³`) = `L⁻¹⋅M⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹⋅M⋅T⁻³`) = `L⁻¹⋅M⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹⋅M⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹⋅M⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹⋅M⋅T⁻³`) = `L⁻¹⋅M⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹⋅M⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹⋅M⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `L⁻¹⋅M⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹⋅M⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹⋅M⋅T⁻³` && this.siValue == other.siValue
}


typealias `SpectralIrradiance` = `L⁻¹⋅M⋅T⁻³`

typealias `PowerDensity` = `L⁻¹⋅M⋅T⁻³`

@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `Dimensionless`) = `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1I0Theta0N0J0_per_L1T3_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1I0Theta0N0J0_per_L1T3_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1I0Theta0N0J0_per_L1T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: `Dimensionless`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: Quan<`L`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: `L`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: Quan<`T`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: `T`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`T`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`T⁻¹`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `T⁻¹`) = `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`T⁻¹`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A2M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`∠²`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `∠²`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A2M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`∠²`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1I0Theta0N0J0_per_L1T2_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻²`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1I0Theta0N0J0_per_L1T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻²`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1I0Theta0N0J0_per_L1T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻²`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: Quan<`L²`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: `L²`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: Quan<`L³`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: `L³`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L³`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L1A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⋅T⁻³`>) = `L⁻²⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L1A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⋅T⁻³`) = `L⁻²⋅M`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L1A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⋅T⁻³`>) = thiz.run { `L⁻²⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻³`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻³`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⁻¹`>) = `M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⁻¹`) = `M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⁻²⋅M`>) = `L⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⁻²⋅M`) = `L⋅T⁻³`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⁻²⋅M`>) = thiz.run { `L⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1T0I0Theta0N0J0_per_L3_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⁻³⋅M`>) = `L²⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1T0I0Theta0N0J0_per_L3_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⁻³⋅M`) = `L²⋅T⁻³`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1T0I0Theta0N0J0_per_L3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⁻³⋅M`>) = thiz.run { `L²⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L3A0T0I0Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: Quan<`L³⋅M⁻¹`>) = `L²⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L3A0T0I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: `L³⋅M⁻¹`) = `L²⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L3A0T0I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L³⋅M⁻¹`>) = thiz.run { `L²⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`M⋅T⁻³`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `M⋅T⁻³`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `T⁻²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⁻¹⋅M⋅T⁻¹`) = `T⁻²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `T⁻²`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⁻²⋅I`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⁻²⋅I`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `L⁻²⋅I`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `L⁻²⋅I`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `L⁻²⋅I`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L2A0M0I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L²⋅T⁻³`>) = `L⁻³⋅M`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L2A0M0I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L²⋅T⁻³`) = `L⁻³⋅M`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L2A0M0I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L²⋅T⁻³`>) = thiz.run { `L⁻³⋅M`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⁻²`>) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⁻²`) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⁻²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: Quan<`L⋅M⁻¹⋅T²`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.times(that: `L⋅M⁻¹⋅T²`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Multiply_L1A0T2I0Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⋅M⁻¹⋅T²`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`T⁻²`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `T⁻²`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`T⁻²`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `∠²`(this.siValue / that.siValue)
// @JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `L⁻¹⋅M⋅T⁻³`.div(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `∠²`(this.siValue / that.siValue)
@JvmName("A0M1I0Theta0N0J0_per_L1T3_Divide_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `∠²`(this.siValue / that.siValue) }


typealias `L⁻²⋅M⁻¹⋅T³⋅Θ` = A0T3I0Theta1N0J0_per_L2M1
inline class A0T3I0Theta1N0J0_per_L2M1(internal val underlying: Double) : Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅kg⁻¹⋅s³⋅K"

    override fun new(siValue: Double) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅M⁻¹⋅T³⋅Θ`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅M⁻¹⋅T³⋅Θ`(-underlying)

    override operator fun plus(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅M⁻¹⋅T³⋅Θ`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅M⁻¹⋅T³⋅Θ` && this.siValue == other.siValue
}


typealias `ThermalResistance` = `L⁻²⋅M⁻¹⋅T³⋅Θ`

@JvmName("A0T3I0Theta1N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
// @JvmName("A0T3I0Theta1N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.div(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue) }
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Divide_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0T3I0Theta1N0J0_per_L2M1_Divide_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.div(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Divide_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue * that.siValue) }
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: Quan<`L²⋅M⋅T⁻³`>) = `Θ`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: `L²⋅M⋅T⁻³`) = `Θ`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `Θ`(this.siValue * that.siValue) }
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: Quan<`L⋅M⋅T⁻³`>) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: `L⋅M⋅T⁻³`) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue * that.siValue) }
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L2A0M1I0N0J0_per_T2Theta1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = `T`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L2A0M1I0N0J0_per_T2Theta1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `T`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L2A0M1I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `T`(this.siValue * that.siValue) }
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L1A0M1I0N0J0_per_T3Theta1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L1A0M1I0N0J0_per_T3Theta1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅Θ`.times(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta1N0J0_per_L2M1_Multiply_L1A0M1I0N0J0_per_T3Theta1_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>, that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }


typealias `L⁻¹⋅Θ` = A0M0T0I0Theta1N0J0_per_L1
inline class A0M0T0I0Theta1N0J0_per_L1(internal val underlying: Double) : Quan<`L⁻¹⋅Θ`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹⋅K"

    override fun new(siValue: Double) = `L⁻¹⋅Θ`(siValue)

    override operator fun unaryPlus() = `L⁻¹⋅Θ`(+underlying)
    override operator fun unaryMinus() = `L⁻¹⋅Θ`(-underlying)

    override operator fun plus(that: `L⁻¹⋅Θ`) = `L⁻¹⋅Θ`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹⋅Θ`) = `L⁻¹⋅Θ`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹⋅Θ`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹⋅Θ`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹⋅Θ`) = `L⁻¹⋅Θ`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹⋅Θ`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹⋅Θ`) = if (this > that) this else that

    override val abs get() = `L⁻¹⋅Θ`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹⋅Θ`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹⋅Θ` && this.siValue == other.siValue
}


typealias `TemperatureGradient` = `L⁻¹⋅Θ`

@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅Θ`.div(that: Quan<`Dimensionless`>) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅Θ`.div(that: `Dimensionless`) = `L⁻¹⋅Θ`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_A0M0T0I0Theta1N0J0_per_L1_generic")
operator fun `L⁻¹⋅Θ`.div(that: Quan<`L⁻¹⋅Θ`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_A0M0T0I0Theta1N0J0_per_L1_concrete")
operator fun `L⁻¹⋅Θ`.div(that: `L⁻¹⋅Θ`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_A0M0T0I0Theta1N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`L⁻¹⋅Θ`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅Θ`.times(that: Quan<`Dimensionless`>) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅Θ`.times(that: `Dimensionless`) = `L⁻¹⋅Θ`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅Θ`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅Θ`.times(that: Quan<`L`>) = `Θ`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅Θ`.times(that: `L`) = `Θ`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`L`>) = thiz.run { `Θ`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_L0A0M0T0I0Theta1N0J0_generic")
operator fun `L⁻¹⋅Θ`.div(that: Quan<`Θ`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_L0A0M0T0I0Theta1N0J0_concrete")
operator fun `L⁻¹⋅Θ`.div(that: `Θ`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_L0A0M0T0I0Theta1N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`Θ`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_L1A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻¹⋅Θ`.div(that: Quan<`L⋅M⋅T⁻³`>) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_L1A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻¹⋅Θ`.div(that: `L⋅M⋅T⁻³`) = `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_L1A0M1I0Theta0N0J0_per_T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`L⋅M⋅T⁻³`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅Θ`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅Θ`.div(that: Quan<`L⁻¹`>) = `Θ`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅Θ`.div(that: `L⁻¹`) = `Θ`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`L⁻¹`>) = thiz.run { `Θ`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L2A0M1I0N0J0_per_T2Theta1_generic")
operator fun `L⁻¹⋅Θ`.times(that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L2A0M1I0N0J0_per_T2Theta1_concrete")
operator fun `L⁻¹⋅Θ`.times(that: `L²⋅M⋅T⁻²⋅Θ⁻¹`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L2A0M1I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`L²⋅M⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L2A0M0I0N0J0_per_T2Theta1_generic")
operator fun `L⁻¹⋅Θ`.times(that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = `L⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L2A0M0I0N0J0_per_T2Theta1_concrete")
operator fun `L⁻¹⋅Θ`.times(that: `L²⋅T⁻²⋅Θ⁻¹`) = `L⋅T⁻²`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L2A0M0I0N0J0_per_T2Theta1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`L²⋅T⁻²⋅Θ⁻¹`>) = thiz.run { `L⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L1A0M1I0N0J0_per_T3Theta1_generic")
operator fun `L⁻¹⋅Θ`.times(that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L1A0M1I0N0J0_per_T3Theta1_concrete")
operator fun `L⁻¹⋅Θ`.times(that: `L⋅M⋅T⁻³⋅Θ⁻¹`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L1A0M1I0N0J0_per_T3Theta1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`L⋅M⋅T⁻³⋅Θ⁻¹`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_A0T3I0Theta1N0J0_per_L2M1_generic")
operator fun `L⁻¹⋅Θ`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_A0T3I0Theta1N0J0_per_L2M1_concrete")
operator fun `L⁻¹⋅Θ`.div(that: `L⁻²⋅M⁻¹⋅T³⋅Θ`) = `L⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Divide_A0T3I0Theta1N0J0_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅Θ`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L0A0M0T0I0N0J0_per_Theta1_generic")
operator fun `L⁻¹⋅Θ`.times(that: Quan<`Θ⁻¹`>) = `L⁻¹`(this.siValue * that.siValue)
// @JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L0A0M0T0I0N0J0_per_Theta1_concrete")
operator fun `L⁻¹⋅Θ`.times(that: `Θ⁻¹`) = `L⁻¹`(this.siValue * that.siValue)
@JvmName("A0M0T0I0Theta1N0J0_per_L1_Multiply_L0A0M0T0I0N0J0_per_Theta1_nonextension")
fun times(thiz: Quan<`L⁻¹⋅Θ`>, that: Quan<`Θ⁻¹`>) = thiz.run { `L⁻¹`(this.siValue * that.siValue) }


typealias `L⋅M⋅T⁻²⋅I⁻¹` = L1A0M1Theta0N0J0_per_T2I1
inline class L1A0M1Theta0N0J0_per_T2I1(internal val underlying: Double) : Quan<`L⋅M⋅T⁻²⋅I⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅kg⋅s⁻²⋅A⁻¹"

    override fun new(siValue: Double) = `L⋅M⋅T⁻²⋅I⁻¹`(siValue)

    override operator fun unaryPlus() = `L⋅M⋅T⁻²⋅I⁻¹`(+underlying)
    override operator fun unaryMinus() = `L⋅M⋅T⁻²⋅I⁻¹`(-underlying)

    override operator fun plus(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅M⋅T⁻²⋅I⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅M⋅T⁻²⋅I⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅M⋅T⁻²⋅I⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L⋅M⋅T⁻²⋅I⁻¹`) = if (this > that) this else that

    override val abs get() = `L⋅M⋅T⁻²⋅I⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅M⋅T⁻²⋅I⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅M⋅T⁻²⋅I⁻¹` && this.siValue == other.siValue
}


typealias `MagneticVectorPotential` = `L⋅M⋅T⁻²⋅I⁻¹`

typealias `MagneticRigidity` = `L⋅M⋅T⁻²⋅I⁻¹`

@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `Dimensionless`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`Dimensionless`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `Dimensionless`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`T`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `T`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`T`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`I`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `I`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`I`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `I`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`I`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`T⁻¹`>) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `T⁻¹`) = `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`T⋅I`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `T⋅I`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T1I1Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻³⋅I⁻²`) = `L⁻¹⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T³⋅I²`) = `L⁻¹⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻¹⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = `L⁻¹⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻²`) = `L⁻¹⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L⁻¹⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L²`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L²`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⋅T⁻¹`>) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⋅T⁻¹`) = `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L1A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹`) = `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻²⋅T⋅I`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⁻²⋅T⋅I`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅T⋅I`) = `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅I`>) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅I`) = `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⁻¹⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `L⁻²⋅T⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `I`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻²`) = `I`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T3I1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T3I1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⋅M⋅T⁻³⋅I⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T3I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻³⋅I⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻¹⋅I`>) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⁻¹⋅I`) = `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅I`>) = `M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅I`) = `M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `M⁻¹⋅T⋅I`) = `L⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `L⁻²⋅T⋅I`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `L⁻²⋅T⋅I`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻¹⋅T⋅I`>) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⁻¹⋅T⋅I`) = `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⁻²`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⁻²`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `M⁻¹⋅T²⋅I`) = `L`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L2M1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = `L⁻¹⋅I`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L2M1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅M⁻¹⋅T²⋅I²`) = `L⁻¹⋅I`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L2M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L⁻¹⋅I`(this.siValue * that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `I`(this.siValue * that.siValue)
// @JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `I`(this.siValue * that.siValue)
@JvmName("L1A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun times(thiz: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `I`(this.siValue * that.siValue) }


typealias `L³⋅M⋅T⁻²⋅I⁻¹` = L3A0M1Theta0N0J0_per_T2I1
inline class L3A0M1Theta0N0J0_per_T2I1(internal val underlying: Double) : Quan<`L³⋅M⋅T⁻²⋅I⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m³⋅kg⋅s⁻²⋅A⁻¹"

    override fun new(siValue: Double) = `L³⋅M⋅T⁻²⋅I⁻¹`(siValue)

    override operator fun unaryPlus() = `L³⋅M⋅T⁻²⋅I⁻¹`(+underlying)
    override operator fun unaryMinus() = `L³⋅M⋅T⁻²⋅I⁻¹`(-underlying)

    override operator fun plus(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = if (this > that) this else that

    override val abs get() = `L³⋅M⋅T⁻²⋅I⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L³⋅M⋅T⁻²⋅I⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L³⋅M⋅T⁻²⋅I⁻¹` && this.siValue == other.siValue
}


typealias `MagneticMoment` = `L³⋅M⋅T⁻²⋅I⁻¹`

@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`Dimensionless`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `Dimensionless`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `L³⋅M⋅T⁻²⋅I⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`Dimensionless`>) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `Dimensionless`) = `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `L`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`T⋅I`>) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `T⋅I`) = `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`T⋅I`>) = thiz.run { `L³⋅M⋅T⁻³⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = `L`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅M⋅T⁻²⋅I⁻¹`) = `L`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L2A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`M⋅T⁻²⋅I⁻¹`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `M⋅T⁻²⋅I⁻¹`) = `L³`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L0A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L³`>) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `L³`) = `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L³`>) = thiz.run { `M⋅T⁻²⋅I⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹`>) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹`) = `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅T⋅I`>) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅T⋅I`) = `L⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅T⋅I`>) = thiz.run { `L⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L3_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻³⋅T⋅I`>) = `M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L3_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻³⋅T⋅I`) = `M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻³⋅T⋅I`>) = thiz.run { `M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²⋅I`>) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²⋅I`) = `L⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²⋅I`>) = thiz.run { `L⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = `T⋅I`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T³⋅I²`) = `T⋅I`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0T3I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T³⋅I²`>) = thiz.run { `T⋅I`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I2_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = `L²⋅I`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I2_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻²`) = `L²⋅I`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I2_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻²`>) = thiz.run { `L²⋅I`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅I`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅I`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅I`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T⋅I`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `M⁻¹⋅T⋅I`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T1I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⁻¹⋅T⋅I`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `L³⋅M⋅T⁻³⋅I⁻²`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L3A0M1Theta0N0J0_per_T3I2_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L³⋅M⋅T⁻³⋅I⁻²`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅T⋅I`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅T⋅I`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T1I1Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅T⋅I`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻²`>) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻²`) = `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻²`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L2A0M0T0I1Theta0N0J0_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L²⋅I`>) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L2A0M0T0I1Theta0N0J0_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `L²⋅I`) = `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L2A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L²⋅I`>) = thiz.run { `L⋅M⋅T⁻²⋅I⁻²`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`M⁻¹⋅T²⋅I`>) = `L³`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `M⁻¹⋅T²⋅I`) = `L³`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_L0A0T2I1Theta0N0J0_per_M1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`M⁻¹⋅T²⋅I`>) = thiz.run { `L³`(this.siValue * that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.div(that: `L⋅M⋅T⁻²⋅I⁻¹`) = `L²`(this.siValue / that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Divide_L1A0M1Theta0N0J0_per_T2I1_nonextension")
fun div(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⋅M⋅T⁻²⋅I⁻¹`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L1M1_generic")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = `L²⋅I`(this.siValue * that.siValue)
// @JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L1M1_concrete")
operator fun `L³⋅M⋅T⁻²⋅I⁻¹`.times(that: `L⁻¹⋅M⁻¹⋅T²⋅I²`) = `L²⋅I`(this.siValue * that.siValue)
@JvmName("L3A0M1Theta0N0J0_per_T2I1_Multiply_A0T2I2Theta0N0J0_per_L1M1_nonextension")
fun times(thiz: Quan<`L³⋅M⋅T⁻²⋅I⁻¹`>, that: Quan<`L⁻¹⋅M⁻¹⋅T²⋅I²`>) = thiz.run { `L²⋅I`(this.siValue * that.siValue) }


typealias `L³⋅T⁻¹⋅N⁻¹` = L3A0M0I0Theta0J0_per_T1N1
inline class L3A0M0I0Theta0J0_per_T1N1(internal val underlying: Double) : Quan<`L³⋅T⁻¹⋅N⁻¹`> {
    override val siValue get() = underlying
    override val abrev get() = "m³⋅s⁻¹⋅mol⁻¹"

    override fun new(siValue: Double) = `L³⋅T⁻¹⋅N⁻¹`(siValue)

    override operator fun unaryPlus() = `L³⋅T⁻¹⋅N⁻¹`(+underlying)
    override operator fun unaryMinus() = `L³⋅T⁻¹⋅N⁻¹`(-underlying)

    override operator fun plus(that: `L³⋅T⁻¹⋅N⁻¹`) = `L³⋅T⁻¹⋅N⁻¹`(this.underlying + that.underlying)
    override operator fun minus(that: `L³⋅T⁻¹⋅N⁻¹`) = `L³⋅T⁻¹⋅N⁻¹`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L³⋅T⁻¹⋅N⁻¹`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L³⋅T⁻¹⋅N⁻¹`(this.underlying / that.toDouble())
    override operator fun rem(that: `L³⋅T⁻¹⋅N⁻¹`) = `L³⋅T⁻¹⋅N⁻¹`(this.underlying % that.underlying)

    override infix fun min(that: `L³⋅T⁻¹⋅N⁻¹`) = if (this < that) this else that
    override infix fun max(that: `L³⋅T⁻¹⋅N⁻¹`) = if (this > that) this else that

    override val abs get() = `L³⋅T⁻¹⋅N⁻¹`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L³⋅T⁻¹⋅N⁻¹`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L³⋅T⁻¹⋅N⁻¹` && this.siValue == other.siValue
}


typealias `CatalyticEfficiency` = `L³⋅T⁻¹⋅N⁻¹`

@JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.div(that: Quan<`Dimensionless`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.div(that: `Dimensionless`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L3A0M0I0Theta0J0_per_T1N1_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.div(that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L3A0M0I0Theta0J0_per_T1N1_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.div(that: `L³⋅T⁻¹⋅N⁻¹`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L3A0M0I0Theta0J0_per_T1N1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`L³⋅T⁻¹⋅N⁻¹`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: Quan<`Dimensionless`>) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: `Dimensionless`) = `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`Dimensionless`>) = thiz.run { `L³⋅T⁻¹⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: Quan<`T`>) = `L³⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: `T`) = `L³⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_L0A0M0T1I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`T`>) = thiz.run { `L³⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_L0A0M0T0I0Theta0N1J0_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: Quan<`N`>) = `L³⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_L0A0M0T0I0Theta0N1J0_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: `N`) = `L³⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_L0A0M0T0I0Theta0N1J0_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`N`>) = thiz.run { `L³⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.div(that: Quan<`T⁻¹`>) = `L³⋅N⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.div(that: `T⁻¹`) = `L³⋅N⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`T⁻¹`>) = thiz.run { `L³⋅N⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: Quan<`L⁻³⋅N`>) = `T⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: `L⁻³⋅N`) = `T⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_A0M0T0I0Theta0N1J0_per_L3_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`L⁻³⋅N`>) = thiz.run { `T⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L3A0M0T0I0Theta0J0_per_N1_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.div(that: Quan<`L³⋅N⁻¹`>) = `T⁻¹`(this.siValue / that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L3A0M0T0I0Theta0J0_per_N1_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.div(that: `L³⋅N⁻¹`) = `T⁻¹`(this.siValue / that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Divide_L3A0M0T0I0Theta0J0_per_N1_nonextension")
fun div(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`L³⋅N⁻¹`>) = thiz.run { `T⁻¹`(this.siValue / that.siValue) }
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_A0M1I0Theta0N0J0_per_L1T1_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_A0M1I0Theta0N0J0_per_L1T1_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: `L⁻¹⋅M⋅T⁻¹`) = `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_A0M1I0Theta0N0J0_per_L1T1_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`L⁻¹⋅M⋅T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻²⋅N⁻¹`(this.siValue * that.siValue) }
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_A0T4I2Theta0N0J0_per_L3M1_generic")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
// @JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_A0T4I2Theta0N0J0_per_L3M1_concrete")
operator fun `L³⋅T⁻¹⋅N⁻¹`.times(that: `L⁻³⋅M⁻¹⋅T⁴⋅I²`) = `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue)
@JvmName("L3A0M0I0Theta0J0_per_T1N1_Multiply_A0T4I2Theta0N0J0_per_L3M1_nonextension")
fun times(thiz: Quan<`L³⋅T⁻¹⋅N⁻¹`>, that: Quan<`L⁻³⋅M⁻¹⋅T⁴⋅I²`>) = thiz.run { `M⁻¹⋅T³⋅I²⋅N⁻¹`(this.siValue * that.siValue) }


typealias `L²⋅M` = L2A0M1T0I0Theta0N0J0
inline class L2A0M1T0I0Theta0N0J0(internal val underlying: Double) : Quan<`L²⋅M`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅kg"

    override fun new(siValue: Double) = `L²⋅M`(siValue)

    override operator fun unaryPlus() = `L²⋅M`(+underlying)
    override operator fun unaryMinus() = `L²⋅M`(-underlying)

    override operator fun plus(that: `L²⋅M`) = `L²⋅M`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅M`) = `L²⋅M`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅M`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅M`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅M`) = `L²⋅M`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅M`) = if (this < that) this else that
    override infix fun max(that: `L²⋅M`) = if (this > that) this else that

    override val abs get() = `L²⋅M`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅M`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅M` && this.siValue == other.siValue
}


typealias `MomentOfInertia` = `L²⋅M`

@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M`.div(that: Quan<`Dimensionless`>) = `L²⋅M`(this.siValue / that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M`.div(that: `Dimensionless`) = `L²⋅M`(this.siValue / that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M`(this.siValue / that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L2A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅M`.div(that: Quan<`L²⋅M`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Divide_L2A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅M`.div(that: `L²⋅M`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L2A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M`>, that: Quan<`L²⋅M`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M`.times(that: Quan<`Dimensionless`>) = `L²⋅M`(this.siValue * that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M`.times(that: `Dimensionless`) = `L²⋅M`(this.siValue * that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅M`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅M`(this.siValue * that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_generic")
operator fun `L²⋅M`.div(that: Quan<`M`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_concrete")
operator fun `L²⋅M`.div(that: `M`) = `L²`(this.siValue / that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L0A0M1T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M`>, that: Quan<`M`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_generic")
operator fun `L²⋅M`.div(that: Quan<`T`>) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_concrete")
operator fun `L²⋅M`.div(that: `T`) = `L²⋅M⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L0A0M0T1I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M`>, that: Quan<`T`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M`.times(that: Quan<`T⁻¹`>) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M`.times(that: `T⁻¹`) = `L²⋅M⋅T⁻¹`(this.siValue * that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T1_nonextension")
fun times(thiz: Quan<`L²⋅M`>, that: Quan<`T⁻¹`>) = thiz.run { `L²⋅M⋅T⁻¹`(this.siValue * that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M`.div(that: Quan<`L²`>) = `M`(this.siValue / that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M`.div(that: `L²`) = `M`(this.siValue / that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M`>, that: Quan<`L²`>) = thiz.run { `M`(this.siValue / that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅M`.div(that: Quan<`L³`>) = `L⁻¹⋅M`(this.siValue / that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅M`.div(that: `L³`) = `L⁻¹⋅M`(this.siValue / that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅M`>, that: Quan<`L³`>) = thiz.run { `L⁻¹⋅M`(this.siValue / that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T1_generic")
operator fun `L²⋅M`.div(that: Quan<`L²⋅M⋅T⁻¹`>) = `T`(this.siValue / that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T1_concrete")
operator fun `L²⋅M`.div(that: `L²⋅M⋅T⁻¹`) = `T`(this.siValue / that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_L2A0M1I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`L²⋅M`>, that: Quan<`L²⋅M⋅T⁻¹`>) = thiz.run { `T`(this.siValue / that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅M`.div(that: Quan<`L⁻¹⋅M`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅M`.div(that: `L⁻¹⋅M`) = `L³`(this.siValue / that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Divide_A0M1T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L²⋅M`>, that: Quan<`L⁻¹⋅M`>) = thiz.run { `L³`(this.siValue / that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅M`.times(that: Quan<`L⁻²`>) = `M`(this.siValue * that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅M`.times(that: `L⁻²`) = `M`(this.siValue * that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅M`>, that: Quan<`L⁻²`>) = thiz.run { `M`(this.siValue * that.siValue) }
@JvmName("L2A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_generic")
operator fun `L²⋅M`.times(that: Quan<`T⁻²`>) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
// @JvmName("L2A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_concrete")
operator fun `L²⋅M`.times(that: `T⁻²`) = `L²⋅M⋅T⁻²`(this.siValue * that.siValue)
@JvmName("L2A0M1T0I0Theta0N0J0_Multiply_L0A0M0I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L²⋅M`>, that: Quan<`T⁻²`>) = thiz.run { `L²⋅M⋅T⁻²`(this.siValue * that.siValue) }


typealias `L⁻²⋅M⁻¹⋅T³⋅J` = A0T3I0Theta0N0J1_per_L2M1
inline class A0T3I0Theta0N0J1_per_L2M1(internal val underlying: Double) : Quan<`L⁻²⋅M⁻¹⋅T³⋅J`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻²⋅kg⁻¹⋅s³⋅cd"

    override fun new(siValue: Double) = `L⁻²⋅M⁻¹⋅T³⋅J`(siValue)

    override operator fun unaryPlus() = `L⁻²⋅M⁻¹⋅T³⋅J`(+underlying)
    override operator fun unaryMinus() = `L⁻²⋅M⁻¹⋅T³⋅J`(-underlying)

    override operator fun plus(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = if (this < that) this else that
    override infix fun max(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = if (this > that) this else that

    override val abs get() = `L⁻²⋅M⁻¹⋅T³⋅J`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻²⋅M⁻¹⋅T³⋅J`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻²⋅M⁻¹⋅T³⋅J` && this.siValue == other.siValue
}


typealias `LuminousEfficacy` = `L⁻²⋅M⁻¹⋅T³⋅J`

@JvmName("A0T3I0Theta0N0J1_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.div(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
// @JvmName("A0T3I0Theta0N0J1_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.div(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue)
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue / that.siValue) }
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Divide_A0T3I0Theta0N0J1_per_L2M1_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.div(that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("A0T3I0Theta0N0J1_per_L2M1_Divide_A0T3I0Theta0N0J1_per_L2M1_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.div(that: `L⁻²⋅M⁻¹⋅T³⋅J`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Divide_A0T3I0Theta0N0J1_per_L2M1_nonextension")
fun div(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>, that: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: Quan<`Dimensionless`>) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: `Dimensionless`) = `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻²⋅M⁻¹⋅T³⋅J`(this.siValue * that.siValue) }
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L2A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: Quan<`L²⋅M⋅T⁻²`>) = `T⋅J`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L2A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: `L²⋅M⋅T⁻²`) = `T⋅J`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L2A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>, that: Quan<`L²⋅M⋅T⁻²`>) = thiz.run { `T⋅J`(this.siValue * that.siValue) }
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L2A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: Quan<`L²⋅M⋅T⁻³`>) = `J`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L2A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: `L²⋅M⋅T⁻³`) = `J`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L2A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>, that: Quan<`L²⋅M⋅T⁻³`>) = thiz.run { `J`(this.siValue * that.siValue) }
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L0A0M1I0Theta0N0J0_per_T2_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: Quan<`M⋅T⁻²`>) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L0A0M1I0Theta0N0J0_per_T2_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: `M⋅T⁻²`) = `L⁻²⋅T⋅J`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L0A0M1I0Theta0N0J0_per_T2_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>, that: Quan<`M⋅T⁻²`>) = thiz.run { `L⁻²⋅T⋅J`(this.siValue * that.siValue) }
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L0A0M1I0Theta0N0J0_per_T3_generic")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: Quan<`M⋅T⁻³`>) = `L⁻²⋅J`(this.siValue * that.siValue)
// @JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L0A0M1I0Theta0N0J0_per_T3_concrete")
operator fun `L⁻²⋅M⁻¹⋅T³⋅J`.times(that: `M⋅T⁻³`) = `L⁻²⋅J`(this.siValue * that.siValue)
@JvmName("A0T3I0Theta0N0J1_per_L2M1_Multiply_L0A0M1I0Theta0N0J0_per_T3_nonextension")
fun times(thiz: Quan<`L⁻²⋅M⁻¹⋅T³⋅J`>, that: Quan<`M⋅T⁻³`>) = thiz.run { `L⁻²⋅J`(this.siValue * that.siValue) }


typealias `∠⋅I` = L0A1M0T0I1Theta0N0J0
inline class L0A1M0T0I1Theta0N0J0(internal val underlying: Double) : Quan<`∠⋅I`> {
    override val siValue get() = underlying
    override val abrev get() = "rad⋅A"

    override fun new(siValue: Double) = `∠⋅I`(siValue)

    override operator fun unaryPlus() = `∠⋅I`(+underlying)
    override operator fun unaryMinus() = `∠⋅I`(-underlying)

    override operator fun plus(that: `∠⋅I`) = `∠⋅I`(this.underlying + that.underlying)
    override operator fun minus(that: `∠⋅I`) = `∠⋅I`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `∠⋅I`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `∠⋅I`(this.underlying / that.toDouble())
    override operator fun rem(that: `∠⋅I`) = `∠⋅I`(this.underlying % that.underlying)

    override infix fun min(that: `∠⋅I`) = if (this < that) this else that
    override infix fun max(that: `∠⋅I`) = if (this > that) this else that

    override val abs get() = `∠⋅I`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `∠⋅I`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `∠⋅I` && this.siValue == other.siValue
}


typealias `MagnetomotiveForce` = `∠⋅I`

@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠⋅I`.div(that: Quan<`Dimensionless`>) = `∠⋅I`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⋅I`.div(that: `Dimensionless`) = `∠⋅I`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `∠⋅I`(this.siValue / that.siValue) }
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A1M0T0I1Theta0N0J0_generic")
operator fun `∠⋅I`.div(that: Quan<`∠⋅I`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A1M0T0I1Theta0N0J0_concrete")
operator fun `∠⋅I`.div(that: `∠⋅I`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A1M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅I`>, that: Quan<`∠⋅I`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0A1M0T0I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠⋅I`.times(that: Quan<`Dimensionless`>) = `∠⋅I`(this.siValue * that.siValue)
// @JvmName("L0A1M0T0I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⋅I`.times(that: `Dimensionless`) = `∠⋅I`(this.siValue * that.siValue)
@JvmName("L0A1M0T0I1Theta0N0J0_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⋅I`>, that: Quan<`Dimensionless`>) = thiz.run { `∠⋅I`(this.siValue * that.siValue) }
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_generic")
operator fun `∠⋅I`.div(that: Quan<`I`>) = `∠`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_concrete")
operator fun `∠⋅I`.div(that: `I`) = `∠`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A0M0T0I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅I`>, that: Quan<`I`>) = thiz.run { `∠`(this.siValue / that.siValue) }
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A1M0T0I0Theta0N0J0_generic")
operator fun `∠⋅I`.div(that: Quan<`∠`>) = `I`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A1M0T0I0Theta0N0J0_concrete")
operator fun `∠⋅I`.div(that: `∠`) = `I`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A1M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅I`>, that: Quan<`∠`>) = thiz.run { `I`(this.siValue / that.siValue) }
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_generic")
operator fun `∠⋅I`.div(that: Quan<`T⋅I`>) = `∠⋅T⁻¹`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_concrete")
operator fun `∠⋅I`.div(that: `T⋅I`) = `∠⋅T⁻¹`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A0M0T1I1Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⋅I`>, that: Quan<`T⋅I`>) = thiz.run { `∠⋅T⁻¹`(this.siValue / that.siValue) }
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A1M0I0Theta0N0J0_per_T1_generic")
operator fun `∠⋅I`.div(that: Quan<`∠⋅T⁻¹`>) = `T⋅I`(this.siValue / that.siValue)
// @JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A1M0I0Theta0N0J0_per_T1_concrete")
operator fun `∠⋅I`.div(that: `∠⋅T⁻¹`) = `T⋅I`(this.siValue / that.siValue)
@JvmName("L0A1M0T0I1Theta0N0J0_Divide_L0A1M0I0Theta0N0J0_per_T1_nonextension")
fun div(thiz: Quan<`∠⋅I`>, that: Quan<`∠⋅T⁻¹`>) = thiz.run { `T⋅I`(this.siValue / that.siValue) }


typealias `L²⋅∠⁻²⋅M⋅T⁻³` = L2M1I0Theta0N0J0_per_A2T3
inline class L2M1I0Theta0N0J0_per_A2T3(internal val underlying: Double) : Quan<`L²⋅∠⁻²⋅M⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "m²⋅rad⁻²⋅kg⋅s⁻³"

    override fun new(siValue: Double) = `L²⋅∠⁻²⋅M⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `L²⋅∠⁻²⋅M⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `L²⋅∠⁻²⋅M⋅T⁻³`(-underlying)

    override operator fun plus(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `L²⋅∠⁻²⋅M⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L²⋅∠⁻²⋅M⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L²⋅∠⁻²⋅M⋅T⁻³` && this.siValue == other.siValue
}


typealias `RadiantIntensity` = `L²⋅∠⁻²⋅M⋅T⁻³`

@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: `Dimensionless`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L2M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L2M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L2M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.times(that: `Dimensionless`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: `L`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_L0A2M0T0I0Theta0N0J0_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`∠²`>) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.times(that: `∠²`) = `L²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_L0A2M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`∠²`>) = thiz.run { `L²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L²`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: `L²`) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L²`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L³`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: `L³`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L3A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L³`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L⁻¹`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.times(that: `L⁻¹`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L⁻²`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.times(that: `L⁻²`) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻²`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `L`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: `∠⁻²⋅M⋅T⁻³`) = `L²`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L²`(this.siValue / that.siValue) }
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `L³`(this.siValue / that.siValue)
// @JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `L²⋅∠⁻²⋅M⋅T⁻³`.div(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L³`(this.siValue / that.siValue)
@JvmName("L2M1I0Theta0N0J0_per_A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun div(thiz: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L³`(this.siValue / that.siValue) }


typealias `L⋅∠⁻²⋅M⋅T⁻³` = L1M1I0Theta0N0J0_per_A2T3
inline class L1M1I0Theta0N0J0_per_A2T3(internal val underlying: Double) : Quan<`L⋅∠⁻²⋅M⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "m⋅rad⁻²⋅kg⋅s⁻³"

    override fun new(siValue: Double) = `L⋅∠⁻²⋅M⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `L⋅∠⁻²⋅M⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `L⋅∠⁻²⋅M⋅T⁻³`(-underlying)

    override operator fun plus(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⋅∠⁻²⋅M⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⋅∠⁻²⋅M⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `L⋅∠⁻²⋅M⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `L⋅∠⁻²⋅M⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `L⋅∠⁻²⋅M⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⋅∠⁻²⋅M⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⋅∠⁻²⋅M⋅T⁻³` && this.siValue == other.siValue
}


typealias `SpectralIntensity` = `L⋅∠⁻²⋅M⋅T⁻³`

@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: `Dimensionless`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: `Dimensionless`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: `L`) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: `L`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_L0A2M0T0I0Theta0N0J0_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`∠²`>) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: `∠²`) = `L⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_L0A2M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`∠²`>) = thiz.run { `L⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L²`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: `L²`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L2A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L²`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⁻¹`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: `L⁻¹`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L⁻¹`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: `L⁻¹`) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L⁻²`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.times(that: `L⁻²`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun times(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻²`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L2M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L2M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L2M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `L`(this.siValue / that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: `∠⁻²⋅M⋅T⁻³`) = `L`(this.siValue / that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L`(this.siValue / that.siValue) }
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `L²`(this.siValue / that.siValue)
// @JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `L⋅∠⁻²⋅M⋅T⁻³`.div(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L²`(this.siValue / that.siValue)
@JvmName("L1M1I0Theta0N0J0_per_A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun div(thiz: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L²`(this.siValue / that.siValue) }


typealias `∠⁻²⋅M⋅T⁻³` = L0M1I0Theta0N0J0_per_A2T3
inline class L0M1I0Theta0N0J0_per_A2T3(internal val underlying: Double) : Quan<`∠⁻²⋅M⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "rad⁻²⋅kg⋅s⁻³"

    override fun new(siValue: Double) = `∠⁻²⋅M⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `∠⁻²⋅M⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `∠⁻²⋅M⋅T⁻³`(-underlying)

    override operator fun plus(that: `∠⁻²⋅M⋅T⁻³`) = `∠⁻²⋅M⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `∠⁻²⋅M⋅T⁻³`) = `∠⁻²⋅M⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `∠⁻²⋅M⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `∠⁻²⋅M⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `∠⁻²⋅M⋅T⁻³`) = `∠⁻²⋅M⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `∠⁻²⋅M⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `∠⁻²⋅M⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `∠⁻²⋅M⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `∠⁻²⋅M⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `∠⁻²⋅M⋅T⁻³` && this.siValue == other.siValue
}


typealias `Radiance` = `∠⁻²⋅M⋅T⁻³`

@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: `Dimensionless`) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: `∠⁻²⋅M⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: `Dimensionless`) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L1A0M0T0I0Theta0N0J0_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: `L`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L1A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: `L`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L0A2M0T0I0Theta0N0J0_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: Quan<`∠²`>) = `M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: `∠²`) = `M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L0A2M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`∠²`>) = thiz.run { `M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L²`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: `L²`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`L²`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⁻¹`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: `L⁻¹`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L⁻¹`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.times(that: `L⁻¹`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Multiply_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun times(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⁻²`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: `L⁻²`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻²`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L2M1I0Theta0N0J0_per_A2T3_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L2M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: `L²⋅∠⁻²⋅M⋅T⁻³`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L2M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`L²⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `L`(this.siValue / that.siValue)
// @JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `∠⁻²⋅M⋅T⁻³`.div(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L`(this.siValue / that.siValue)
@JvmName("L0M1I0Theta0N0J0_per_A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun div(thiz: Quan<`∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L`(this.siValue / that.siValue) }


typealias `L⁻¹⋅∠⁻²⋅M⋅T⁻³` = M1I0Theta0N0J0_per_L1A2T3
inline class M1I0Theta0N0J0_per_L1A2T3(internal val underlying: Double) : Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`> {
    override val siValue get() = underlying
    override val abrev get() = "m⁻¹⋅rad⁻²⋅kg⋅s⁻³"

    override fun new(siValue: Double) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(siValue)

    override operator fun unaryPlus() = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(+underlying)
    override operator fun unaryMinus() = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(-underlying)

    override operator fun plus(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.underlying + that.underlying)
    override operator fun minus(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.underlying - that.underlying)
    override operator fun times(that: Number) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.underlying * that.toDouble())
    override operator fun div(that: Number) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.underlying / that.toDouble())
    override operator fun rem(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.underlying % that.underlying)

    override infix fun min(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = if (this < that) this else that
    override infix fun max(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = if (this > that) this else that

    override val abs get() = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(abs(underlying))
    override val signum get() = underlying.sign
    override val isNegative get() = underlying < 0
    override val isZero get() = underlying == 0.0
    override val isPositive get() = underlying > 0

    override fun compareTo(other: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = this.underlying.compareTo(other.underlying)

    override fun toString() = "$underlying $abrev"
    // override fun equals(other: Any?) = other is `L⁻¹⋅∠⁻²⋅M⋅T⁻³` && this.siValue == other.siValue
}


typealias `SpectralRadiance` = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`

@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`Dimensionless`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: `Dimensionless`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_L0A0M0T0I0Theta0N0J0_nonextension")
fun div(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = `Dimensionless`(this.siValue / that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: `L⁻¹⋅∠⁻²⋅M⋅T⁻³`) = `Dimensionless`(this.siValue / that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_M1I0Theta0N0J0_per_L1A2T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `Dimensionless`(this.siValue / that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L0A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`Dimensionless`>) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L0A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: `Dimensionless`) = `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L0A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`Dimensionless`>) = thiz.run { `L⁻¹⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L1A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L1A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: `L`) = `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L1A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L0A2M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`∠²`>) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L0A2M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: `∠²`) = `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L0A2M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`∠²`>) = thiz.run { `L⁻¹⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L2A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L²`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L2A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: `L²`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L2A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L²`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L3A0M0T0I0Theta0N0J0_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: Quan<`L³`>) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L3A0M0T0I0Theta0N0J0_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.times(that: `L³`) = `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Multiply_L3A0M0T0I0Theta0N0J0_nonextension")
fun times(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L³`>) = thiz.run { `L²⋅∠⁻²⋅M⋅T⁻³`(this.siValue * that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_A0M0T0I0Theta0N0J0_per_L1_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⁻¹`>) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_A0M0T0I0Theta0N0J0_per_L1_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: `L⁻¹`) = `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_A0M0T0I0Theta0N0J0_per_L1_nonextension")
fun div(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻¹`>) = thiz.run { `∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_A0M0T0I0Theta0N0J0_per_L2_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⁻²`>) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_A0M0T0I0Theta0N0J0_per_L2_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: `L⁻²`) = `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_A0M0T0I0Theta0N0J0_per_L2_nonextension")
fun div(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⁻²`>) = thiz.run { `L⋅∠⁻²⋅M⋅T⁻³`(this.siValue / that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = `L⁻²`(this.siValue / that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: `L⋅∠⁻²⋅M⋅T⁻³`) = `L⁻²`(this.siValue / that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_L1M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`L⋅∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⁻²`(this.siValue / that.siValue) }
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_generic")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: Quan<`∠⁻²⋅M⋅T⁻³`>) = `L⁻¹`(this.siValue / that.siValue)
// @JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_concrete")
operator fun `L⁻¹⋅∠⁻²⋅M⋅T⁻³`.div(that: `∠⁻²⋅M⋅T⁻³`) = `L⁻¹`(this.siValue / that.siValue)
@JvmName("M1I0Theta0N0J0_per_L1A2T3_Divide_L0M1I0Theta0N0J0_per_A2T3_nonextension")
fun div(thiz: Quan<`L⁻¹⋅∠⁻²⋅M⋅T⁻³`>, that: Quan<`∠⁻²⋅M⋅T⁻³`>) = thiz.run { `L⁻¹`(this.siValue / that.siValue) }

